.upstream.dat\c	setf upstreamdat
au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c	setf upstreamlog
au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c	setf usserverlog
au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c	setf usw2kagtlog

" Ipfilter
au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter

" Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl

" .INI file for MSDOS
au BufNewFile,BufRead *.ini			setf dosini

" SysV Inittab
au BufNewFile,BufRead inittab			setf inittab

" Inno Setup
au BufNewFile,BufRead *.iss			setf iss

" J
au BufNewFile,BufRead *.ijs			setf j

" JAL
au BufNewFile,BufRead *.jal,*.JAL		setf jal

" Jam
au BufNewFile,BufRead *.jpl,*.jpr		setf jam

" Java
au BufNewFile,BufRead *.java,*.jav		setf java

" JavaCC
au BufNewFile,BufRead *.jj,*.jjt		setf javacc

" JavaScript, ECMAScript, ES module script, CommonJS script
au BufNewFile,BufRead *.js,*.javascript,*.es,*.mjs,*.cjs   setf javascript

" JavaScript with React
au BufNewFile,BufRead *.jsx			setf javascriptreact

" Java Server Pages
au BufNewFile,BufRead *.jsp			setf jsp

" Java Properties resource file (note: doesn't catch font.properties.pl)
au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties

" Jess
au BufNewFile,BufRead *.clp			setf jess

" Jgraph
au BufNewFile,BufRead *.jgr			setf jgraph

" Jovial
au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial

" JSON
au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json

" JSON Patch (RFC 6902)
au BufNewFile,BufRead *.json-patch			setf json

" Jupyter Notebook is also json
au BufNewFile,BufRead *.ipynb				setf json

" Other files that look like json
au BufNewFile,BufRead .babelrc,.eslintrc,.prettierrc,.firebaserc  setf json

" JSONC
au BufNewFile,BufRead *.jsonc			setf jsonc

" Julia
au BufNewFile,BufRead *.jl			setf julia

" Kixtart
au BufNewFile,BufRead *.kix			setf kix

" Kimwitu[++]
au BufNewFile,BufRead *.k			setf kwt

" Kivy
au BufNewFile,BufRead *.kv			setf kivy

" Kotlin
au BufNewFile,BufRead *.kt,*.ktm,*.kts		setf kotlin

" KDE script
au BufNewFile,BufRead *.ks			setf kscript

" Kconfig
au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig

" Lace (ISE)
au BufNewFile,BufRead *.ace,*.ACE		setf lace

" Latte
au BufNewFile,BufRead *.latte,*.lte		setf latte

" Limits
au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits

" LambdaProlog (*.mod too, see Modsim)
au BufNewFile,BufRead *.sig			setf lprolog

" LDAP LDIF
au BufNewFile,BufRead *.ldif			setf ldif

" Ld loader
au BufNewFile,BufRead *.ld			setf ld

" Less
au BufNewFile,BufRead *.less			setf less

" Lex
au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex

" Libao
au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao

" Libsensors
au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors

" LFTP
au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp

" Lifelines (or Lex for C++!)
au BufNewFile,BufRead *.ll			setf lifelines

" Lilo: Linux loader
au BufNewFile,BufRead lilo.conf			setf lilo

" Lisp (*.el = ELisp, *.cl = Common Lisp)
" *.jl was removed, it's also used for Julia, better skip than guess wrong.
if has("fname_case")
  au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.L,.emacs,.sawfishrc setf lisp
else
  au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,.emacs,.sawfishrc setf lisp
endif

" SBCL implementation of Common Lisp
au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp

" Liquid
au BufNewFile,BufRead *.liquid			setf liquid

" Lite
au BufNewFile,BufRead *.lite,*.lt		setf lite

" LiteStep RC files
au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep

" Login access
au BufNewFile,BufRead */etc/login.access	setf loginaccess

" Login defs
au BufNewFile,BufRead */etc/login.defs		setf logindefs

" Logtalk
au BufNewFile,BufRead *.lgt			setf logtalk

" LOTOS
au BufNewFile,BufRead *.lot,*.lotos		setf lotos

" Lout (also: *.lt)
au BufNewFile,BufRead *.lou,*.lout		setf lout

" Lua
au BufNewFile,BufRead *.lua			setf lua

" Luarocks
au BufNewFile,BufRead *.rockspec		setf lua

" Linden Scripting Language (Second Life)
au BufNewFile,BufRead *.lsl			setf lsl

" Lynx style file (or LotusScript!)
au BufNewFile,BufRead *.lss			setf lss

" M4
au BufNewFile,BufRead *.m4
	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif

" MaGic Point
au BufNewFile,BufRead *.mgp			setf mgp

" Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail

" Mail aliases
au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases

" Mailcap configuration file
au BufNewFile,BufRead .mailcap,mailcap		setf mailcap

" Makefile
au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make

" MakeIndex
au BufNewFile,BufRead *.ist,*.mst		setf ist

" Mallard
au BufNewFile,BufRead *.page			setf mallard

" Manpage
au BufNewFile,BufRead *.man			setf man

" Man config
au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf

" Maple V
au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple

" Map (UMN mapserver config file)
au BufNewFile,BufRead *.map			setf map

" Markdown
au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown

" Mason
au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason

" Mathematica, Matlab, Murphi, Objective C or Octave
au BufNewFile,BufRead *.m			call dist#ft#FTm()

" Mathematica notebook
au BufNewFile,BufRead *.nb			setf mma

" Maya Extension Language
au BufNewFile,BufRead *.mel			setf mel

" Mercurial (hg) commit file
au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit

" Mercurial config (looks like generic config file)
au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg

" Meson Build system config
au BufNewFile,BufRead meson.build,meson_options.txt setf meson
au BufNewFile,BufRead *.wrap			setf dosini

" Messages (logs mostly)
au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages

" Metafont
au BufNewFile,BufRead *.mf			setf mf

" MetaPost
au BufNewFile,BufRead *.mp			setf mp

" MGL
au BufNewFile,BufRead *.mgl			setf mgl

" MIX - Knuth assembly
au BufNewFile,BufRead *.mix,*.mixal		setf mix

" MMIX or VMS makefile
au BufNewFile,BufRead *.mms			call dist#ft#FTmms()

" Symbian meta-makefile definition (MMP)
au BufNewFile,BufRead *.mmp			setf mmp

" Modsim III (or LambdaProlog)
au BufNewFile,BufRead *.mod
	\ if getline(1) =~ '\<module\>' |
	\   setf lprolog |
	\ else |
	\   setf modsim3 |
	\ endif

" Modula-2  (.md removed in favor of Markdown)
au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2

" Modula-3 (.m3, .i3, .mg, .ig)
au BufNewFile,BufRead *.[mi][3g]		setf modula3

" Monk
au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk

" MOO
au BufNewFile,BufRead *.moo			setf moo

" Modconf
au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf

" MPD is based on XML
au BufNewFile,BufRead *.mpd			setf xml

" Mplayer config
au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf

" Motorola S record
au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec

" Mrxvtrc
au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc

" Msql
au BufNewFile,BufRead *.msql			setf msql

" Mysql
au BufNewFile,BufRead *.mysql			setf mysql

" Mutt setup files (must be before catch *.rc)
au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')

" Tcl Shell RC file
au BufNewFile,BufRead tclsh.rc			setf tcl

" M$ Resource files
au BufNewFile,BufRead *.rc,*.rch		setf rc

" MuPAD source
au BufRead,BufNewFile *.mu			setf mupad

" Mush
au BufNewFile,BufRead *.mush			setf mush

" Mutt setup file (also for Muttng)
au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc

" N1QL
au BufRead,BufNewfile *.n1ql,*.nql		setf n1ql

" Nano
au BufNewFile,BufRead */etc/nanorc,*.nanorc	setf nanorc

" Nastran input/DMAP
"au BufNewFile,BufRead *.dat			setf nastran

" Natural
au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural

" Noemutt setup file
au BufNewFile,BufRead Neomuttrc			setf neomuttrc

" Netrc
au BufNewFile,BufRead .netrc			setf netrc

" Nginx
au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf			setf nginx

" Ninja file
au BufNewFile,BufRead *.ninja			setf ninja

" NPM RC file
au BufNewFile,BufRead npmrc,.npmrc		setf dosini

" Novell netware batch files
au BufNewFile,BufRead *.ncf			setf ncf

" Nroff/Troff (*.ms and *.t are checked below)
au BufNewFile,BufRead *.me
	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
	\   setf nroff |
	\ endif
au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
au BufNewFile,BufRead *.[1-9]			call dist#ft#FTnroff()

" Nroff or Objective C++
au BufNewFile,BufRead *.mm			call dist#ft#FTmm()

" Not Quite C
au BufNewFile,BufRead *.nqc			setf nqc

" NSE - Nmap Script Engine - uses Lua syntax
au BufNewFile,BufRead *.nse			setf lua

" NSIS
au BufNewFile,BufRead *.nsi,*.nsh		setf nsis

" OCaml
au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml

" Occam
au BufNewFile,BufRead *.occ			setf occam

" Octave
au BufNewFile,BufRead octave.conf,.octaverc,octaverc	setf octave

" Omnimark
au BufNewFile,BufRead *.xom,*.xin		setf omnimark

" OPAM
au BufNewFile,BufRead opam,*.opam,*.opam.template setf opam

" OpenROAD
au BufNewFile,BufRead *.or			setf openroad

" OPL
au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl

" Oracle config file
au BufNewFile,BufRead *.ora			setf ora

" Packet filter conf
au BufNewFile,BufRead pf.conf			setf pf

" Pacman Config (close enough to dosini)
au BufNewFile,BufRead */etc/pacman.conf		setf dosini

" Pacman hooks
au BufNewFile,BufRead *.hook
	\ if getline(1) == '[Trigger]' |
	\   setf dosini |
	\ endif

" Pam conf
au BufNewFile,BufRead */etc/pam.conf			setf pamconf

" Pam environment
au BufNewFile,BufRead pam_env.conf,.pam_environment	setf pamenv

" PApp
au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp

" Password file
au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd

" Pascal (also *.p, *.pp, *.inc)
au BufNewFile,BufRead *.pas			setf pascal

" Pascal or Puppet manifest
au BufNewFile,BufRead *.pp			call dist#ft#FTpp()

" Delphi or Lazarus program file
au BufNewFile,BufRead *.dpr,*.lpr		setf pascal

" Free Pascal makefile definition file
au BufNewFile,BufRead *.fpc			setf fpcmake

" PDF
au BufNewFile,BufRead *.pdf			setf pdf

" PCMK - HAE - crm configure edit
au BufNewFile,BufRead *.pcmk			setf pcmk

" Perl
if has("fname_case")
  au BufNewFile,BufRead *.pl,*.PL		call dist#ft#FTpl()
else
  au BufNewFile,BufRead *.pl			call dist#ft#FTpl()
endif
au BufNewFile,BufRead *.plx,*.al,*.psgi		setf perl

" Perl, XPM or XPM2
au BufNewFile,BufRead *.pm
	\ if getline(1) =~ "XPM2" |
	\   setf xpm2 |
	\ elseif getline(1) =~ "XPM" |
	\   setf xpm |
	\ else |
	\   setf perl |
	\ endif

" Perl POD
au BufNewFile,BufRead *.pod			setf pod

" Php, php3, php4, etc.
" Also Phtml (was used for PHP 2 in the past)
" Also .ctp for Cake template file
au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php

" PHP config
au BufNewFile,BufRead php.ini-*			setf dosini

" Pike and Cmod
au BufNewFile,BufRead *.pike,*.pmod		setf pike
au BufNewFile,BufRead *.cmod			setf cmod

" Pinfo config
au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo

" Palm Resource compiler
au BufNewFile,BufRead *.rcp			setf pilrc

" Pine config
au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine

" Pipenv Pipfiles
au BufNewFile,BufRead Pipfile			setf toml
au BufNewFile,BufRead Pipfile.lock		setf json

" PL/1, PL/I
au BufNewFile,BufRead *.pli,*.pl1		setf pli

" PL/M (also: *.inp)
au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm

" PL/SQL
au BufNewFile,BufRead *.pls,*.plsql		setf plsql

" PLP
au BufNewFile,BufRead *.plp			setf plp

" PO and PO template (GNU gettext)
au BufNewFile,BufRead *.po,*.pot		setf po

" Postfix main config
au BufNewFile,BufRead main.cf			setf pfmain

" PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr

" PostScript Printer Description
au BufNewFile,BufRead *.ppd			setf ppd

" Povray
au BufNewFile,BufRead *.pov			setf pov

" Povray configuration
au BufNewFile,BufRead .povrayrc			setf povini

" Povray, Pascal, PHP or assembly
au BufNewFile,BufRead *.inc			call dist#ft#FTinc()

" PowerShell
au BufNewFile,BufRead	*.ps1,*.psd1,*.psm1,*.pssc	setf ps1
au BufNewFile,BufRead	*.ps1xml			setf ps1xml
au BufNewFile,BufRead	*.cdxml,*.psc1			setf xml

" Printcap and Termcap
au BufNewFile,BufRead *printcap
	\ let b:ptcap_type = "print" | setf ptcap
au BufNewFile,BufRead *termcap
	\ let b:ptcap_type = "term" | setf ptcap

" PCCTS / ANTLR
"au BufNewFile,BufRead *.g			setf antlr
au BufNewFile,BufRead *.g			setf pccts

" PPWizard
au BufNewFile,BufRead *.it,*.ih			setf ppwiz

" Puppet
au BufNewFile,BufRead Puppetfile		setf ruby

" Embedded Puppet
au BufNewFile,BufRead *.epp			setf epuppet

" Obj 3D file format
" TODO: is there a way to avoid MS-Windows Object files?
au BufNewFile,BufRead *.obj			setf obj

" Oracle Pro*C/C++
au BufNewFile,BufRead *.pc			setf proc

" Privoxy actions file
au BufNewFile,BufRead *.action			setf privoxy

" Procmail
au BufNewFile,BufRead .procmail,.procmailrc	setf procmail

" Progress or CWEB
au BufNewFile,BufRead *.w			call dist#ft#FTprogress_cweb()

" Progress or assembly
au BufNewFile,BufRead *.i			call dist#ft#FTprogress_asm()

" Progress or Pascal
au BufNewFile,BufRead *.p			call dist#ft#FTprogress_pascal()

" Software Distributor Product Specification File (POSIX 1387.2-1995)
au BufNewFile,BufRead *.psf			setf psf
au BufNewFile,BufRead INDEX,INFO
	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
	\   setf psf |
	\ endif

" Prolog
au BufNewFile,BufRead *.pdb			setf prolog

" Promela
au BufNewFile,BufRead *.pml			setf promela

" Property Specification Language (PSL)
au BufNewFile,BufRead *.psl			setf psl

" Google protocol buffers
au BufNewFile,BufRead *.proto			setf proto
au BufNewFile,BufRead *.pbtxt			setf pbtxt

" Poke
au BufNewFile,BufRead *.pk			setf poke

" Protocols
au BufNewFile,BufRead */etc/protocols		setf protocols

" Pyret
au BufNewFile,BufRead *.arr			setf pyret

" Pyrex
au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex

" Python, Python Shell Startup and Python Stub Files
" Quixote (Python-based web framework)
au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc  setf python
au BufNewFile,BufRead *.ptl,*.pyi,SConstruct		   setf python

" Radiance
au BufNewFile,BufRead *.rad,*.mat		setf radiance

" Raku (formerly Perl6)
au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku

" Ratpoison config/command files
au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison

" RCS file
au BufNewFile,BufRead *\,v			setf rcs

" Readline
au BufNewFile,BufRead .inputrc,inputrc		setf readline

" Registry for MS-Windows
au BufNewFile,BufRead *.reg
	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif

" Renderman Interface Bytestream
au BufNewFile,BufRead *.rib			setf rib

" Rego Policy Language
au BufNewFile,BufRead *.rego			setf rego

" Rexx
au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx

" R Help file
if has("fname_case")
  au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
else
  au BufNewFile,BufRead *.rd			setf rhelp
endif

" R noweb file
if has("fname_case")
  au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
else
  au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
endif

" R Markdown file
if has("fname_case")
  au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
else
  au BufNewFile,BufRead *.rmd,*.smd			setf rmd
endif

" RSS looks like XML
au BufNewFile,BufRead *.rss				setf xml

" R reStructuredText file
if has("fname_case")
  au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
else
  au BufNewFile,BufRead *.rrst,*.srst			setf rrst
endif

" Rexx, Rebol or R
au BufNewFile,BufRead *.r,*.R				call dist#ft#FTr()

" Remind
au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind

" Resolv.conf
au BufNewFile,BufRead resolv.conf		setf resolv

" Relax NG Compact
au BufNewFile,BufRead *.rnc			setf rnc

" Relax NG XML
au BufNewFile,BufRead *.rng			setf rng

" RPL/2
au BufNewFile,BufRead *.rpl			setf rpl

" Robots.txt
au BufNewFile,BufRead robots.txt		setf robots

" Rpcgen
au BufNewFile,BufRead *.x			setf rpcgen

" MikroTik RouterOS script
au BufRead,BufNewFile *.rsc			setf routeros

" reStructuredText Documentation Format
au BufNewFile,BufRead *.rst			setf rst

" RTF
au BufNewFile,BufRead *.rtf			setf rtf

" Interactive Ruby shell
au BufNewFile,BufRead .irbrc,irbrc		setf ruby

" Ruby
au BufNewFile,BufRead *.rb,*.rbw		setf ruby

" RubyGems
au BufNewFile,BufRead *.gemspec			setf ruby

" RBS (Ruby Signature)
au BufNewFile,BufRead *.rbs			setf rbs

" Rackup
au BufNewFile,BufRead *.ru			setf ruby

" Bundler
au BufNewFile,BufRead Gemfile			setf ruby

" Ruby on Rails
au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby

" Rantfile and Rakefile is like Ruby
au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby

" Rust
au BufNewFile,BufRead *.rs			setf rust
au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials	setf toml

" S-lang (or shader language, or SmallLisp)
au BufNewFile,BufRead *.sl			setf slang

" Samba config
au BufNewFile,BufRead smb.conf			setf samba

" SAS script
au BufNewFile,BufRead *.sas			setf sas

" Sass
au BufNewFile,BufRead *.sass			setf sass

" Sather
au BufNewFile,BufRead *.sa			setf sather

" Scala
au BufNewFile,BufRead *.scala,*.sc		setf scala

" SBT - Scala Build Tool
au BufNewFile,BufRead *.sbt			setf sbt

" Scilab
au BufNewFile,BufRead *.sci,*.sce		setf scilab

" scdoc
au BufNewFile,BufRead *.scd			setf scdoc

" SCSS
au BufNewFile,BufRead *.scss			setf scss

" SD: Streaming Descriptors
au BufNewFile,BufRead *.sd			setf sd

" SDL
au BufNewFile,BufRead *.sdl,*.pr		setf sdl

" sed
au BufNewFile,BufRead *.sed			setf sed

" svelte
au BufNewFile,BufRead *.svelte			setf svelte

" Sieve (RFC 3028, 5228)
au BufNewFile,BufRead *.siv,*.sieve		setf sieve

" Sendmail
au BufNewFile,BufRead sendmail.cf		setf sm

" Sendmail .mc files are actually m4.  Could also be MS Message text file.
au BufNewFile,BufRead *.mc			call dist#ft#McSetf()

" Services
au BufNewFile,BufRead */etc/services		setf services

" Service Location config
au BufNewFile,BufRead */etc/slp.conf		setf slpconf

" Service Location registration
au BufNewFile,BufRead */etc/slp.reg		setf slpreg

" Service Location SPI
au BufNewFile,BufRead */etc/slp.spi		setf slpspi

" Setserial config
au BufNewFile,BufRead */etc/serial.conf		setf setserial

" SGML
au BufNewFile,BufRead *.sgm,*.sgml
	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
	\   setf sgmllnx |
	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
	\   let b:docbk_type = "sgml" |
	\   let b:docbk_ver = 4 |
	\   setf docbk |
	\ else |
	\   setf sgml |
	\ endif

" SGMLDECL
au BufNewFile,BufRead *.decl,*.dcl,*.dec
	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
	\    setf sgmldecl |
	\ endif

" SGML catalog file
au BufNewFile,BufRead catalog			setf catalog

" Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
" Gentoo ebuilds, Arch Linux PKGBUILDs and Alpine Linux APKBUILDs are actually
" bash scripts.
" NOTE: Patterns ending in a star are further down, these have lower priority.
au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,APKBUILD call dist#ft#SetFileTypeSH("bash")
au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))

" Shell script (Arch Linux) or PHP file (Drupal)
au BufNewFile,BufRead *.install
	\ if getline(1) =~ '<?php' |
	\   setf php |
	\ else |
	\   call dist#ft#SetFileTypeSH("bash") |
	\ endif

" tcsh scripts (patterns ending in a star further below)
au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login	call dist#ft#SetFileTypeShell("tcsh")

" csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
" (patterns ending in a start further below)
au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()

" Z-Shell script (patterns ending in a star further below)
au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
au BufNewFile,BufRead *.zsh			setf zsh

" Scheme
au BufNewFile,BufRead *.scm,*.ss,*.rkt,*.rktd,*.rktl 	setf scheme

" Screen RC
au BufNewFile,BufRead .screenrc,screenrc	setf screen

" Sexplib
au BufNewFile,BufRead *.sexp setf sexplib

" Simula
au BufNewFile,BufRead *.sim			setf simula

" SINDA
au BufNewFile,BufRead *.sin,*.s85		setf sinda

" SiSU
au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu

" SKILL
au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill

" SLRN
au BufNewFile,BufRead .slrnrc			setf slrnrc
au BufNewFile,BufRead *.score			setf slrnsc

" Smalltalk (and TeX)
au BufNewFile,BufRead *.st			setf st
au BufNewFile,BufRead *.cls
	\ if getline(1) =~ '^%' |
	\  setf tex |
	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
	\  setf rexx |
	\ else |
	\  setf st |
	\ endif

" Smarty templates
au BufNewFile,BufRead *.tpl			setf smarty

" SMIL or XML
au BufNewFile,BufRead *.smil
	\ if getline(1) =~ '<?\s*xml.*?>' |
	\   setf xml |
	\ else |
	\   setf smil |
	\ endif

" SMIL or SNMP MIB file
au BufNewFile,BufRead *.smi
	\ if getline(1) =~ '\<smil\>' |
	\   setf smil |
	\ else |
	\   setf mib |
	\ endif

" SMITH
au BufNewFile,BufRead *.smt,*.smith		setf smith

" Snobol4 and spitbol
au BufNewFile,BufRead *.sno,*.spt		setf snobol4

" SNMP MIB files
au BufNewFile,BufRead *.mib,*.my		setf mib

" Snort Configuration
au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
au BufNewFile,BufRead *.rules			call dist#ft#FTRules()

" SPARQL queries
au BufNewFile,BufRead *.rq,*.sparql		setf sparql

" Spec (Linux RPM)
au BufNewFile,BufRead *.spec			setf spec

" Speedup (AspenTech plant simulator)
au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup

" Slice
au BufNewFile,BufRead *.ice			setf slice

" Spice
au BufNewFile,BufRead *.sp,*.spice		setf spice

" Spyce
au BufNewFile,BufRead *.spy,*.spi		setf spyce

" Squid
au BufNewFile,BufRead squid.conf		setf squid

" SQL for Oracle Designer
au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql

" SQL
au BufNewFile,BufRead *.sql			call dist#ft#SQL()

" SQLJ
au BufNewFile,BufRead *.sqlj			setf sqlj

" SQR
au BufNewFile,BufRead *.sqr,*.sqi		setf sqr

" OpenSSH configuration
au BufNewFile,BufRead ssh_config,*/.ssh/config		setf sshconfig
au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf	setf sshconfig

" OpenSSH server configuration
au BufNewFile,BufRead sshd_config			setf sshdconfig
au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf	setf sshdconfig

" Stata
au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
" Also *.class, but not when it's a Java bytecode file
au BufNewFile,BufRead *.class
	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif

" SMCL
au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl

" Stored Procedures
au BufNewFile,BufRead *.stp			setf stp

" Standard ML
au BufNewFile,BufRead *.sml			setf sml

" Sratus VOS command macro
au BufNewFile,BufRead *.cm			setf voscm

" Swift
au BufNewFile,BufRead *.swift			setf swift
au BufNewFile,BufRead *.swift.gyb		setf swiftgyb

" Swift Intermediate Language
au BufNewFile,BufRead *.sil			setf sil

" Sysctl
au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl

" Systemd unit files
au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}	setf systemd
" Systemd overrides
au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf	setf systemd
au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf	setf systemd
au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf	setf systemd
" Systemd temp files
au BufNewFile,BufRead */etc/systemd/system/*.d/.#*	setf systemd
au BufNewFile,BufRead */etc/systemd/system/.#*		setf systemd
au BufNewFile,BufRead */.config/systemd/user/*.d/.#*	setf systemd
au BufNewFile,BufRead */.config/systemd/user/.#*	setf systemd

" Synopsys Design Constraints
au BufNewFile,BufRead *.sdc			setf sdc

" Sudoers
au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers

" SVG (Scalable Vector Graphics)
au BufNewFile,BufRead *.svg			setf svg

" Tads (or Nroff or Perl test file)
au BufNewFile,BufRead *.t
	\ if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif

" Tags
au BufNewFile,BufRead tags			setf tags

" TAK
au BufNewFile,BufRead *.tak			setf tak

" Task
au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
au BufRead,BufNewFile *.task			setf taskedit

" Tcl (JACL too)
au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc	setf tcl

" TealInfo
au BufNewFile,BufRead *.tli			setf tli

" Telix Salt
au BufNewFile,BufRead *.slt			setf tsalt

" Tera Term Language or Turtle
au BufRead,BufNewFile *.ttl
	\ if getline(1) =~ '^@\?\(prefix\|base\)' |
	\   setf turtle |
	\ else |
	\   setf teraterm |
	\ endif

" Terminfo
au BufNewFile,BufRead *.ti			setf terminfo

" TeX
au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
au BufNewFile,BufRead *.tex			call dist#ft#FTtex()

" ConTeXt
au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context

" Texinfo
au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo

" TeX configuration
au BufNewFile,BufRead texmf.cnf			setf texmf

" Tidy config
au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf	setf tidy

" TF mud client
au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf

" tmux configuration
au BufNewFile,BufRead {.,}tmux*.conf		setf tmux

" TOML
au BufNewFile,BufRead *.toml			setf toml

" TPP - Text Presentation Program
au BufNewFile,BufReadPost *.tpp			setf tpp

" Treetop
au BufRead,BufNewFile *.treetop			setf treetop

" Trustees
au BufNewFile,BufRead trustees.conf		setf trustees

" TSS - Geometry
au BufNewFile,BufReadPost *.tssgm		setf tssgm

" TSS - Optics
au BufNewFile,BufReadPost *.tssop		setf tssop

" TSS - Command Line (temporary)
au BufNewFile,BufReadPost *.tsscl		setf tsscl

" TWIG files
au BufNewFile,BufReadPost *.twig		setf twig

" Typescript or Qt translation file (which is XML)
au BufNewFile,BufReadPost *.ts
	\ if getline(1) =~ '<?xml' |
	\   setf xml |
	\ else |
	\   setf typescript |
	\ endif

" TypeScript with React
au BufNewFile,BufRead *.tsx			setf typescriptreact

" Motif UIT/UIL files
au BufNewFile,BufRead *.uit,*.uil		setf uil

" Udev conf
au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf

" Udev permissions
au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
"
" Udev symlinks config
au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh

" UnrealScript
au BufNewFile,BufRead *.uc			setf uc

" Updatedb
au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb

" Upstart (init(8)) config files
au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart

" Vera
au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera

" Verilog HDL
au BufNewFile,BufRead *.v			setf verilog

" Verilog-AMS HDL
au BufNewFile,BufRead *.va,*.vams		setf verilogams

" SystemVerilog
au BufNewFile,BufRead *.sv,*.svh		setf systemverilog

" VHDL
au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl

" Vim script
au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim

" Viminfo file
au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo

" Virata Config Script File or Drupal module
au BufRead,BufNewFile *.hw,*.module,*.pkg
	\ if getline(1) =~ '<?php' |
	\   setf php |
	\ else |
	\   setf virata |
	\ endif

" Visual Basic (also uses *.bas) or FORM
au BufNewFile,BufRead *.frm			call dist#ft#FTVB("form")

" SaxBasic is close to Visual Basic
au BufNewFile,BufRead *.sba			setf vb

" Vgrindefs file
au BufNewFile,BufRead vgrindefs			setf vgrindefs

" VRML V1.0c
au BufNewFile,BufRead *.wrl			setf vrml

" Vroom (vim testing and executable documentation)
au BufNewFile,BufRead *.vroom			setf vroom

" Vue.js Single File Component
au BufNewFile,BufRead *.vue			setf vue

" WebAssembly
au BufNewFile,BufRead *.wast,*.wat		setf wast

" Webmacro
au BufNewFile,BufRead *.wm			setf webmacro

" Wget config
au BufNewFile,BufRead .wgetrc,wgetrc		setf wget

" Website MetaLanguage
au BufNewFile,BufRead *.wml			setf wml

" Winbatch
au BufNewFile,BufRead *.wbt			setf winbatch

" WSML
au BufNewFile,BufRead *.wsml			setf wsml

" WPL
au BufNewFile,BufRead *.wpl			setf xml

" WvDial
au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial

" CVS RC file
au BufNewFile,BufRead .cvsrc			setf cvsrc

" CVS commit file
au BufNewFile,BufRead cvs\d\+			setf cvs

" WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
" lines in a WEB file).
au BufNewFile,BufRead *.web
	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
	\   setf web |
	\ else |
	\   setf winbatch |
	\ endif

" Windows Scripting Host and Windows Script Component
au BufNewFile,BufRead *.ws[fc]			setf wsh

" XHTML
au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml

" X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make
" it work better, but that breaks setting 'filetype' manually)
au BufNewFile,BufRead *.xpm
	\ if getline(1) =~ "XPM2" |
	\   setf xpm2 |
	\ else |
	\   setf xpm |
	\ endif
au BufNewFile,BufRead *.xpm2			setf xpm2

" XFree86 config
au BufNewFile,BufRead XF86Config
	\ if getline(1) =~ '\<XConfigurator\>' |
	\   let b:xf86conf_xfree86_version = 3 |
	\ endif |
	\ setf xf86conf
au BufNewFile,BufRead */xorg.conf.d/*.conf
	\ let b:xf86conf_xfree86_version = 4 |
	\ setf xf86conf

" Xorg config
au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf

" Xinetd conf
au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd

" XS Perl extension interface language
au BufNewFile,BufRead *.xs			setf xs

" X resources file
au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults

" Xmath
au BufNewFile,BufRead *.msc,*.msf		setf xmath
au BufNewFile,BufRead *.ms
	\ if !dist#ft#FTnroff() | setf xmath | endif

" XML  specific variants: docbk and xbl
au BufNewFile,BufRead *.xml			call dist#ft#FTxml()

" XMI (holding UML models) is also XML
au BufNewFile,BufRead *.xmi			setf xml

" CSPROJ files are Visual Studio.NET's XML-based C# project config files
au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml

" FSPROJ files are Visual Studio.NET's XML-based F# project config files
au BufNewFile,BufRead *.fsproj,*.fsproj.user	setf xml

" VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files
au BufNewFile,BufRead *.vbproj,*.vbproj.user	setf xml

" Qt Linguist translation source and Qt User Interface Files are XML
" However, for .ts Typescript is more common.
au BufNewFile,BufRead *.ui			setf xml

" TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
au BufNewFile,BufRead *.tpm			setf xml

" Xdg menus
au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml

" ATI graphics driver configuration
au BufNewFile,BufRead fglrxrc			setf xml

" Web Services Description Language (WSDL)
au BufNewFile,BufRead *.wsdl			setf xml

" XLIFF (XML Localisation Interchange File Format) is also XML
au BufNewFile,BufRead *.xlf			setf xml
au BufNewFile,BufRead *.xliff			setf xml

" XML User Interface Language
au BufNewFile,BufRead *.xul			setf xml

" X11 xmodmap (also see below)
au BufNewFile,BufRead *Xmodmap			setf xmodmap

" Xquery
au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery

" XSD
au BufNewFile,BufRead *.xsd			setf xsd

" Xslt
au BufNewFile,BufRead *.xsl,*.xslt		setf xslt

" Yacc
au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc

" Yacc or racc
au BufNewFile,BufRead *.y			call dist#ft#FTy()

" Yaml
au BufNewFile,BufRead *.yaml,*.yml		setf yaml

" Raml
au BufNewFile,BufRead *.raml			setf raml

" yum conf (close enough to dosini)
au BufNewFile,BufRead */etc/yum.conf		setf dosini

" Zimbu
au BufNewFile,BufRead *.zu			setf zimbu
" Zimbu Templates
au BufNewFile,BufRead *.zut			setf zimbutempl

" Zope
"   dtml (zope dynamic template markup language), pt (zope page template),
"   cpt (zope form controller page template)
au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call dist#ft#FThtml()
"   zsql (zope sql method)
au BufNewFile,BufRead *.zsql			call dist#ft#SQL()

" Z80 assembler asz80
au BufNewFile,BufRead *.z8a			setf z8a

augroup END


" Source the user-specified filetype file, for backwards compatibility with
" Vim 5.x.
if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
  execute "source " . myfiletypefile
endif


" Check for "*" after loading myfiletypefile, so that scripts.vim is only used
" when there are no matching file name extensions.
" Don't do this for compressed files.
augroup filetypedetect
au BufNewFile,BufRead *
	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
	\ | runtime! scripts.vim | endif
au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif


" Extra checks for when no filetype has been detected now.  Mostly used for
" patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
" script file.
" Most of these should call s:StarSetf() to avoid names ending in .gz and the
" like are used.

" More Apache style config files
au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*	call s:StarSetf('apachestyle')
au BufNewFile,BufRead proftpd.conf*					call s:StarSetf('apachestyle')

" More Apache config files
au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')

" Asterisk config file
au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')

" Bazaar version control
au BufNewFile,BufRead bzr_log.*			setf bzr

" Bazel build file
if !has("fname_case")
  au BufNewFile,BufRead *.BUILD,BUILD		setf bzl
endif

" BIND zone
au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')

au BufNewFile,BufRead cabal.project.*		call s:StarSetf('cabalproject')

" Calendar
au BufNewFile,BufRead */.calendar/*,
	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
	\					call s:StarSetf('calendar')

" Changelog
au BufNewFile,BufRead [cC]hange[lL]og*
	\ if getline(1) =~ '; urgency='
	\|  call s:StarSetf('debchangelog')
	\|else
	\|  call s:StarSetf('changelog')
	\|endif

" Crontab
au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')

" dnsmasq(8) configuration
au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')

" Dracula
au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')

" Fvwm
au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
au BufNewFile,BufRead *fvwm2rc*
	\ if expand("<afile>:e") == "m4"
	\|  call s:StarSetf('fvwm2m4')
	\|else
	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
	\|endif

" Gedcom
au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')

" Git
au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/*	call s:StarSetf('gitconfig')

" Gitolite
au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')

" GTK RC
au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')

" Jam
au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')

" Jargon
au! BufNewFile,BufRead *jarg*
	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
	\|  call s:StarSetf('jargon')
	\|endif

" Java Properties resource file (note: doesn't catch font.properties.pl)
au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')

" Kconfig
au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')

" Lilo: Linux loader
au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')

" Logcheck
au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')

" Makefile
au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')

" Ruby Makefile
au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')

" Mail (also matches muttrc.vim, so this is below the other checks)
au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail

au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')

" Modconf
au BufNewFile,BufRead */etc/modutils/*
	\ if executable(expand("<afile>")) != 1
	\|  call s:StarSetf('modconf')
	\|endif
au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')

" Mutt setup file
au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')

" Neomutt setup file
au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')

" Nroff macros
au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')

" OpenBSD hostname.if
au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')

" Pam conf
au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')

" Printcap and Termcap
au BufNewFile,BufRead *printcap*
	\ if !did_filetype()
	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
	\|endif
au BufNewFile,BufRead *termcap*
	\ if !did_filetype()
	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
	\|endif

" ReDIF
" Only used when the .rdf file was not detected to be XML.
au BufRead,BufNewFile *.rdf			call dist#ft#Redif()

" Remind
au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')

" SGML catalog file
au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')

" avoid doc files being recognized a shell files
au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text

" Shell scripts ending in a star
au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")
au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))

" Sudoers
au BufNewFile,BufRead */etc/sudoers.d/*		call s:StarSetf('sudoers')

" tcsh scripts ending in a star
au BufNewFile,BufRead .tcshrc*	call dist#ft#SetFileTypeShell("tcsh")

" csh scripts ending in a star
au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()

" tmux configuration with arbitrary extension
au BufNewFile,BufRead {.,}tmux*.conf*		setf tmux

" VHDL
au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')

" Vim script
au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')

" Subversion commit file
au BufNewFile,BufRead svn-commit*.tmp		setf svn

" X resources file
au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')

" XFree86 config
au BufNewFile,BufRead XF86Config-4*
	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
au BufNewFile,BufRead XF86Config*
	\ if getline(1) =~ '\<XConfigurator\>'
	\|  let b:xf86conf_xfree86_version = 3
	\|endif
	\|call s:StarSetf('xf86conf')

" X11 xmodmap
au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')

" Xinetd conf
au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')

" yum conf (close enough to dosini)
au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')

" Z-Shell script ending in a star
au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')


" Plain text files, needs to be far down to not override others.  This avoids
" the "conf" type being used if there is a line starting with '#'.
au BufNewFile,BufRead *.text,README		setf text

" Help files match *.txt but should have a last line that is a modeline.
au BufNewFile,BufRead *.txt
	\  if getline('$') !~ 'vim:.*ft=help'
	\|   setf text
	\| endif


" Use the filetype detect plugins.  They may overrule any of the previously
" detected filetypes.
runtime! ftdetect/*.vim

" NOTE: The above command could have ended the filetypedetect autocmd group
" and started another one. Let's make sure it has ended to get to a consistent
" state.
augroup END

" Generic configuration file. Use FALLBACK, it's just guessing!
au filetypedetect BufNewFile,BufRead,StdinReadPost *
	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
	\   setf FALLBACK conf |
	\ endif


" If the GUI is already running, may still need to install the Syntax menu.
" Don't do it when the 'M' flag is included in 'guioptions'.
if has("menu") && has("gui_running")
      \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
  source <sfile>:p:h/menu.vim
endif

" Function called for testing all functions defined here.  These are
" script-local, thus need to be executed here.
" Returns a string with error messages (hopefully empty).
func! TestFiletypeFuncs(testlist)
  let output = ''
  for f in a:testlist
    try
      exe f
    catch
      let output = output . "\n" . f . ": " . v:exception
    endtry
  endfor
  return output
endfunc

" Restore 'cpoptions'
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                    " Vim support file to switch off detection of file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last change:	2001 Jun 11

if exists("did_load_filetypes")
  unlet did_load_filetypes
endif

" Remove all autocommands in the filetypedetect group
silent! au! filetypedetect *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        %   .   n   ..  &   8th.vim '   
README.txt  (   a2ps.vim)   aap.vim *   abap.vim+   
abaqus.vim  ,   ada.vim -   alsaconf.vim.   ant.vim /   arch.vim0   art.vim 1   asm.vim 2   
aspvbs.vim  3   automake.vim4   awk.vim 5   bash.vim6   	basic.vim   7   bdf.vim 8   bst.vim 9   btm.vim :   bzl.vim ;   c.vim   <   calendar.vim=   cdrdaoconf.vim  >   cfg.vim ?   ch.vim  @   changelog.vim   A   chicken.vim B   clojure.vim C   	cmake.vim   D   	cobol.vim   E   conf.vimF   
config.vim  G   context.vim H   cpp.vim I   crm.vim J   cs.vim  K   csc.vim L   csh.vim M   css.vim N   cucumber.vimO   	cvsrc.vim   P   debchangelog.vimQ   debcontrol.vim  R   denyhosts.vim   S   dictconf.vimT   dictdconf.vim   U   diff.vimV   dircolors.vim   W   	docbk.vim   X   dockerfile.vim  Y   dosbatch.vimZ    
dosini.vim              " Vim ftplugin file
" Language:	8th
" Version:	any
" Last Change:	2021 Sep 20
" Last Change:	2021/09/20
" Maintainer:	Ron Aaron <ron@aaron-tech.com>
" URL:		https://8th-dev.com/
" Filetypes:	*.8th
" NOTE: 	8th allows any non-whitespace in a name, so you need to do:
" 		setlocal iskeyword=!,@,33-35,%,$,38-64,A-Z,91-96,a-z,123-126,128-255
" 		This goes with the syntax/8th.vim file.

" Only do this when not done yet for this buffer
if exists("b:did_8thplugin")
 finish
endif

" Don't load another 8th plugin for this buffer
let b:did_8thplugin = 1

setlocal ts=2 sts=2 sw=2 et
setlocal com=s1:/*,mb:*,ex:*/,b:--,be:\\
setlocal fo=tcrqol
setlocal matchpairs+=\::;
setlocal iskeyword=!,@,33-35,%,$,38-64,A-Z,91-96,a-z,123-126,128-255
setlocal suffixesadd=.8th
let b:undo_ftplugin = "setlocal ts< sts< sw< et< com< fo< mps< isk< sua<"
                                                                                                                                                                                               The ftplugin directory is for Vim plugin scripts that are only used for a
specific filetype.

All files ending in .vim in this directory and subdirectories will be sourced
by Vim when it detects the filetype that matches the name of the file or
subdirectory.
For example, these are all loaded for the "c" filetype:

	c.vim
	c_extra.vim
	c/settings.vim

Note that the "_" in "c_extra.vim" is required to separate the filetype name
from the following arbitrary name.

The filetype plugins are only loaded when the ":filetype plugin" command has
been used.

The default filetype plugin files contain settings that 95% of the users will
want to use.  They do not contain personal preferences, like the value of
'shiftwidth'.

If you want to do additional settings, or overrule the default filetype
plugin, you can create your own plugin file.  See ":help ftplugin" in Vim.
                                                                                                                                                           " Vim filetype plugin file
" Language:             a2ps(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*Include:
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:	Aap recipe
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Nov 14

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Reset 'formatoptions', 'comments', 'commentstring' and 'expandtab' to undo
" this plugin.
let b:undo_ftplugin = "setl fo< com< cms< et<"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=s:#\ -,m:#\ \ ,e:#,n:#,fb:-
setlocal commentstring=#\ %s

" Expand tabs to spaces to avoid trouble.
setlocal expandtab

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Aap Recipe Files (*.aap)\t*.aap\nAll Files (*.*)\t*.*\n"
  let b:undo_ftplugin ..= " | unlet! b:browsefilter"
endif
                                             " Vim filetype plugin file
" Language:	ABAP
" Author:	Steven Oliver <oliver.steven@gmail.com>
" Copyright:	Copyright (c) 2013 Steven Oliver
" License:	You may redistribute this under the same terms as Vim itself
" --------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal softtabstop=2 shiftwidth=2
setlocal suffixesadd=.abap

" Windows allows you to filter the open file dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "ABAP Source Files (*.abap)\t*.abap\n" .
                     \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 sts=4 et tw=80 :
                                                                                                                                                                                                                                " Vim filetype plugin file
" Language:     Abaqus finite element input file (www.abaqus.com)
" Maintainer:   Carl Osterwisch <osterwischc@asme.org>
" Last Change:  2012 Apr 30

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin") | finish | endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Save the compatibility options and temporarily switch to vim defaults
let s:cpo_save = &cpoptions
set cpoptions&vim

" Set the format of the include file specification for Abaqus
" Used in :check gf ^wf [i and other commands
setlocal include=\\<\\cINPUT\\s*=

" Remove characters up to the first = when evaluating filenames
setlocal includeexpr=substitute(v:fname,'.\\{-}=','','')

" Remove comma from valid filename characters since it is used to
" separate keyword parameters
setlocal isfname-=,

" Define format of comment lines (see 'formatoptions' for uses)
setlocal comments=:**
setlocal commentstring=**%s

" Definitions start with a * and assign a NAME, NSET, or ELSET
" Used in [d ^wd and other commands
setlocal define=^\\*\\a.*\\c\\(NAME\\\|NSET\\\|ELSET\\)\\s*=

" Abaqus keywords and identifiers may include a - character
setlocal iskeyword+=-

let b:undo_ftplugin = "setlocal include< includeexpr< isfname<"
    \ . " comments< commentstring< define< iskeyword<"

if has("folding")
    " Fold all lines that do not begin with *
    setlocal foldexpr=getline(v:lnum)[0]!=\"\*\"
    setlocal foldmethod=expr
    let b:undo_ftplugin .= " foldexpr< foldmethod<"
endif

" Set the file browse filter (currently only supported under Win32 gui)
if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "Abaqus Input Files (*.inp *.inc)\t*.inp;*.inc\n" .
    \ "Abaqus Results (*.dat)\t*.dat\n" .
    \ "Abaqus Messages (*.pre *.msg *.sta)\t*.pre;*.msg;*.sta\n" .
    \ "All Files (*.*)\t*.*\n"
    let b:undo_ftplugin .= "|unlet! b:browsefilter"
endif

" Define patterns for the matchit plugin
if exists("loaded_matchit") && !exists("b:match_words")
    let b:match_ignorecase = 1
    let b:match_words = 
    \ '\*part:\*end\s*part,' .
    \ '\*assembly:\*end\s*assembly,' .
    \ '\*instance:\*end\s*instance,' .
    \ '\*step:\*end\s*step'
    let b:undo_ftplugin .= "|unlet! b:match_ignorecase b:match_words"
endif

" Define keys used to move [count] keywords backward or forward.
noremap <silent><buffer> [[ ?^\*\a<CR>:nohlsearch<CR>
noremap <silent><buffer> ]] /^\*\a<CR>:nohlsearch<CR>

" Define key to toggle commenting of the current line or range
noremap <silent><buffer> <LocalLeader><LocalLeader> 
    \ :call <SID>Abaqus_ToggleComment()<CR>j
function! <SID>Abaqus_ToggleComment() range
    if strpart(getline(a:firstline), 0, 2) == "**"
        " Un-comment all lines in range
        silent execute a:firstline . ',' . a:lastline . 's/^\*\*//'
    else
        " Comment all lines in range
        silent execute a:firstline . ',' . a:lastline . 's/^/**/'
    endif
endfunction

let b:undo_ftplugin .= "|unmap <buffer> [[|unmap <buffer> ]]"
    \ . "|unmap <buffer> <LocalLeader><LocalLeader>"

" Undo must be done in nocompatible mode for <LocalLeader>.
let b:undo_ftplugin = "let s:cpo_save = &cpoptions|"
    \ . "set cpoptions&vim|"
    \ . b:undo_ftplugin
    \ . "|let &cpoptions = s:cpo_save"
    \ . "|unlet s:cpo_save"

" Restore saved compatibility options
let &cpoptions = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 "------------------------------------------------------------------------------
"  Description: Perform Ada specific completion & tagging.
"     Language: Ada (2005)
"	   $Id: ada.vim 887 2008-07-08 14:29:01Z krischik $
"   Maintainer: Martin Krischik <krischik@users.sourceforge.net>
"		Taylor Venable <taylor@metasyntax.net>
"		Neil Bird <neil@fnxweb.com>
"      $Author: krischik $
"	 $Date: 2008-07-08 16:29:01 +0200 (Di, 08 Jul 2008) $
"      Version: 4.6 with patch from David Brgin
"    $Revision: 887 $
"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/ftplugin/ada.vim $
"      History: 24.05.2006 MK Unified Headers
"		26.05.2006 MK ' should not be in iskeyword.
"		16.07.2006 MK Ada-Mode as vim-ball
"		02.10.2006 MK Better folding.
"		15.10.2006 MK Bram's suggestion for runtime integration
"               05.11.2006 MK Bram suggested not to use include protection for
"                             autoload
"		05.11.2006 MK Bram suggested to save on spaces
"		08.07.2007 TV fix default compiler problems.
"    Help Page: ft-ada-plugin
"------------------------------------------------------------------------------
" Provides mapping overrides for tag jumping that figure out the current
" Ada object and tag jump to that, not the 'simple' vim word.
" Similarly allows <Ctrl-N> matching of full-length ada entities from tags.
"------------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if exists ("b:did_ftplugin") || version < 700
   finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 45

"
" Temporarily set cpoptions to ensure the script loads OK
"
let s:cpoptions = &cpoptions
set cpoptions-=C

" Section: Comments  {{{1
"
setlocal comments=O:--,:--\ \ 
setlocal commentstring=--\ \ %s
setlocal complete=.,w,b,u,t,i

" Section: case	     {{{1
"
setlocal nosmartcase
setlocal ignorecase

" Section: formatoptions {{{1
"
setlocal formatoptions+=ron

" Section: Tagging {{{1
"
if exists ("g:ada_extended_tagging")
   " Make local tag mappings for this buffer (if not already set)
   if g:ada_extended_tagging == 'jump'
      if mapcheck('<C-]>','n') == ''
	 nnoremap <unique> <buffer> <C-]>    :call ada#Jump_Tag ('', 'tjump')<cr>
      endif
      if mapcheck('g<C-]>','n') == ''
	 nnoremap <unique> <buffer> g<C-]>   :call ada#Jump_Tag ('','stjump')<cr>
      endif
   elseif g:ada_extended_tagging == 'list'
      if mapcheck('<C-]>','n') == ''
	 nnoremap <unique> <buffer> <C-]>    :call ada#List_Tag ()<cr>
      endif
      if mapcheck('g<C-]>','n') == ''
	 nnoremap <unique> <buffer> g<C-]>   :call ada#List_Tag ()<cr>
      endif
   endif
endif

" Section: Completion {{{1
"
setlocal completefunc=ada#User_Complete
setlocal omnifunc=adacomplete#Complete

if exists ("g:ada_extended_completion")
   if mapcheck ('<C-N>','i') == ''
      inoremap <unique> <buffer> <C-N> <C-R>=ada#Completion("\<lt>C-N>")<cr>
   endif
   if mapcheck ('<C-P>','i') == ''
      inoremap <unique> <buffer> <C-P> <C-R>=ada#Completion("\<lt>C-P>")<cr>
   endif
   if mapcheck ('<C-X><C-]>','i') == ''
      inoremap <unique> <buffer> <C-X><C-]> <C-R>=<SID>ada#Completion("\<lt>C-X>\<lt>C-]>")<cr>
   endif
   if mapcheck ('<bs>','i') == ''
      inoremap <silent> <unique> <buffer> <bs> <C-R>=ada#Insert_Backspace ()<cr>
   endif
endif

" Section: Matchit {{{1
"
" Only do this when not done yet for this buffer & matchit is used
"
if !exists ("b:match_words")  &&
  \ exists ("loaded_matchit")
   "
   " The following lines enable the macros/matchit.vim plugin for
   " Ada-specific extended matching with the % key.
   "
   let s:notend      = '\%(\<end\s\+\)\@<!'
   let b:match_words =
      \ s:notend . '\<if\>:\<elsif\>:\<else\>:\<end\>\s\+\<if\>,' .
      \ s:notend . '\<case\>:\<when\>:\<end\>\s\+\<case\>,' .
      \ '\%(\<while\>.*\|\<for\>.*\|'.s:notend.'\)\<loop\>:\<end\>\s\+\<loop\>,' .
      \ '\%(\<do\>\|\<begin\>\):\<exception\>:\<end\>\s*\%($\|[;A-Z]\),' .
      \ s:notend . '\<record\>:\<end\>\s\+\<record\>'
endif


" Section: Compiler {{{1
"
if ! exists("g:ada_default_compiler")
   if has("vms")
      let g:ada_default_compiler = 'decada'
   else
      let g:ada_default_compiler = 'gnat'
   endif
endif

if ! exists("current_compiler")			||
   \ current_compiler != g:ada_default_compiler
   execute "compiler " . g:ada_default_compiler
endif

" Section: Folding {{{1
"
if exists("g:ada_folding")
   if g:ada_folding[0] == 'i'
      setlocal foldmethod=indent
      setlocal foldignore=--
      setlocal foldnestmax=5
   elseif g:ada_folding[0] == 'g'
      setlocal foldmethod=expr
      setlocal foldexpr=ada#Pretty_Print_Folding(v:lnum)
   elseif g:ada_folding[0] == 's'
      setlocal foldmethod=syntax
   endif
   setlocal tabstop=8
   setlocal softtabstop=3
   setlocal shiftwidth=3
endif

" Section: Abbrev {{{1
"
if exists("g:ada_abbrev")
   iabbrev ret	return
   iabbrev proc procedure
   iabbrev pack package
   iabbrev func function
endif

" Section: Commands, Mapping, Menus {{{1
if !exists(':AdaTagFile')
  call ada#Map_Popup (
     \ 'Tag.List',
     \  'l',
     \ 'call ada#List_Tag ()')
  call ada#Map_Popup (
     \'Tag.Jump',
     \'j',
     \'call ada#Jump_Tag ()')
  call ada#Map_Menu (
     \'Tag.Create File',
     \':AdaTagFile',
     \'call ada#Create_Tags (''file'')')
  call ada#Map_Menu (
     \'Tag.Create Dir',
     \':AdaTagDir',
     \'call ada#Create_Tags (''dir'')')

  call ada#Map_Menu (
     \'Highlight.Toggle Space Errors',
     \ ':AdaSpaces',
     \'call ada#Switch_Syntax_Option (''space_errors'')')
  call ada#Map_Menu (
     \'Highlight.Toggle Lines Errors',
     \ ':AdaLines',
     \'call ada#Switch_Syntax_Option (''line_errors'')')
  call ada#Map_Menu (
     \'Highlight.Toggle Rainbow Color',
     \ ':AdaRainbow',
     \'call ada#Switch_Syntax_Option (''rainbow_color'')')
  call ada#Map_Menu (
     \'Highlight.Toggle Standard Types',
     \ ':AdaTypes',
     \'call ada#Switch_Syntax_Option (''standard_types'')')
endif

" 1}}}
" Reset cpoptions
let &cpoptions = s:cpoptions
unlet s:cpoptions

finish " 1}}}

"------------------------------------------------------------------------------
"   Copyright (C) 2006	Martin Krischik
"
"   Vim is Charityware - see ":help license" or uganda.txt for licence details.
"------------------------------------------------------------------------------
" vim: textwidth=78 nowrap tabstop=8 shiftwidth=3 softtabstop=3 noexpandtab
" vim: foldmethod=marker
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:             alsaconf(8) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:	ant
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "XML Files (*.xml)\t*.xml\n" .
	    \	     "All Files (*.*)\t*.*\n"

runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show Ant-related files.
if has("gui_win32")
    let b:browsefilter = "Build Files (build.xml)\tbuild.xml\n" .
		\	 "Java Files (*.java)\t*.java\n" .
		\	 "Properties Files (*.prop*)\t*.prop*\n" .
		\	 "Manifest Files (*.mf)\t*.mf\n" .
		\	 s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:             GNU Arch inventory file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin
" Language:      ART-IM and ART*Enterprise
" Maintainer:    Dorai Sitaram <ds26@gte.com>
" URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
" Last Change:   Apr 2, 2003

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

run ftplugin/lisp.vim

setl lw-=if
setl lw+=def-art-fun,deffacts,defglobal,defrule,defschema,for,schema,while
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:	asm
" Maintainer:	Colin Caine <cmcaine at the common googlemail domain>
" Last Changed: 23 May 2020

if exists("b:did_ftplugin") | finish | endif

setl comments=:;,s1:/*,mb:*,ex:*/,://
setl commentstring=;%s

let b:did_ftplugin = 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	aspvbs
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "HTML Files (*.html, *.htm)\t*.htm*\n" .
	    \	     "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
endif

" ASP:  Active Server Pages (with Visual Basic Script)
" thanks to Gontran BAERTS
if exists("loaded_matchit")
  let s:notend = '\%(\<end\s\+\)\@<!'
  let b:match_ignorecase = 1
  let b:match_words =
  \ s:notend . '\<if\>\%(.\{-}then\s\+\w\)\@!:\<elseif\>:^\s*\<else\>:\<end\s\+\<if\>,' .
  \ s:notend . '\<select\s\+case\>:\<case\>:\<case\s\+else\>:\<end\s\+select\>,' .
  \ '^\s*\<sub\>:\<end\s\+sub\>,' .
  \ '^\s*\<function\>:\<end\s\+function\>,' .
  \ '\<class\>:\<end\s\+class\>,' .
  \ '^\s*\<do\>:\<loop\>,' .
  \ '^\s*\<for\>:\<next\>,' .
  \ '\<while\>:\<wend\>,' .
  \ s:match_words
endif

" Change the :browse e filter to primarily show ASP-related files.
if has("gui_win32")
    let  b:browsefilter="ASP Files (*.asp)\t*.asp\n" . s:browsefilter
endif

let b:undo_ftplugin = "unlet! b:match_words b:match_ignorecase b:browsefilter | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                    " Vim filetype plugin file
" Language:             Automake
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

runtime! ftplugin/make.vim ftplugin/make_*.vim ftplugin/make/*.vim

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin
" Language:		awk, nawk, gawk, mawk
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Antonio Colombo <azc100@gmail.com>
" Last Change:		2020 Sep 28

" This plugin was prepared by Mark Sikora
" This plugin was updated as proposed by Doug Kearns

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=:#
setlocal commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql

setlocal define=function
setlocal suffixesadd+=.awk

let b:undo_ftplugin = "setl fo< com< cms< def< sua<" .
		    \ " | unlet! b:browsefilter"

" TODO: set this in scripts.vim?
if exists("g:awk_is_gawk")
  setlocal include=@include
  setlocal suffixesadd+=.gawk
  if has("unix") || has("win32unix")
    setlocal formatprg=gawk\ -f-\ -o/dev/stdout
    let b:undo_ftplugin .= " | setl fp<"
  endif

  let path = system("gawk 'BEGIN { printf ENVIRON[\"AWKPATH\"] }'")
  let path = substitute(path, '^\.\=:\|:\.\=$\|:\.\=:', ',,', 'g') " POSIX cwd
  let path = substitute(path, ':', ',', 'g')

  let &l:path = path
  let b:undo_ftplugin .= " | setl inc< path<"
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Awk Source Files (*.awk,*.gawk)\t*.awk;*.gawk\n" .
		     \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	bash
" Maintainer:	Bram Moolenaar
" Last Changed: 2019 Jan 12
"
" This is not a real filetype plugin.  It allows for someone to set 'filetype'
" to "bash" in the modeline, and gets the effect of filetype "sh" with
" b:is_bash set.  Idea from Mahmode Al-Qudsi.

if exists("b:did_ftplugin")
  finish
endif

unlet! b:is_sh
unlet! b:is_kornshell
let b:is_bash = 1

runtime! ftplugin/sh.vim ftplugin/sh_*.vim ftplugin/sh/*.vim

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:	BASIC
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2015 Jan 10

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=:REM,:'
setlocal commentstring='\ %s
setlocal formatoptions-=t formatoptions+=croql

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "BASIC Source Files (*.bas)\t*.bas\n" .
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< com< cms< sua<" .
		    \ " | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:             BDF font definition
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=b:COMMENT commentstring=COMMENT\ %s
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:	bst
" Author:	Tim Pope <vimNOSPAM@tpope.info>
" $Id: bst.vim,v 1.1 2007/05/05 17:37:57 vimboss Exp $

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

setlocal commentstring=%\ %s
setlocal comments=:%
setlocal fo-=t fo+=croql

let b:undo_ftplugin = "setlocal com< cms< fo<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	BTM
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2004 Jul 06

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like dosbatch
runtime! ftplugin/dosbatch.vim ftplugin/dosbatch_*.vim ftplugin/dosbatch/*.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:	Bazel (http://bazel.io)
" Maintainer:	David Barnett (https://github.com/google/vim-ft-bzl)
" Last Change:	2021 Jan 19

""
" @section Introduction, intro
" Core settings for the bzl filetype, used for BUILD and *.bzl files for the
" Bazel build system (http://bazel.io/).

if exists('b:did_ftplugin')
  finish
endif


" Vim 7.4.051 has opinionated settings in ftplugin/python.vim that try to force
" PEP8 conventions on every python file, but these conflict with Google's
" indentation guidelines. As a workaround, we explicitly source the system
" ftplugin, but save indentation settings beforehand and restore them after.
let s:save_expandtab = &l:expandtab
let s:save_shiftwidth = &l:shiftwidth
let s:save_softtabstop = &l:softtabstop
let s:save_tabstop = &l:tabstop

" NOTE: Vim versions before 7.3.511 had a ftplugin/python.vim that was broken
" for compatible mode.
let s:save_cpo = &cpo
set cpo&vim

" Load base python ftplugin (also defines b:did_ftplugin).
source $VIMRUNTIME/ftplugin/python.vim

" NOTE: Vim versions before 7.4.104 and later set this in ftplugin/python.vim.
setlocal comments=b:#,fb:-

" Restore pre-existing indentation settings.
let &l:expandtab = s:save_expandtab
let &l:shiftwidth = s:save_shiftwidth
let &l:softtabstop = s:save_softtabstop
let &l:tabstop = s:save_tabstop

setlocal formatoptions-=t

" Make gf work with imports in BUILD files.
setlocal includeexpr=substitute(v:fname,'//','','')

" Enable syntax-based folding, if specified.
if get(g:, 'ft_bzl_fold', 0)
  setlocal foldmethod=syntax
  setlocal foldtext=BzlFoldText()
endif

if exists('*BzlFoldText')
  let &cpo = s:save_cpo
  unlet s:save_cpo
  finish
endif

function BzlFoldText() abort
  let l:start_num = nextnonblank(v:foldstart)
  let l:end_num = prevnonblank(v:foldend)

  if l:end_num <= l:start_num + 1
    " If the fold is empty, don't print anything for the contents.
    let l:content = ''
  else
    " Otherwise look for something matching the content regex.
    " And if nothing matches, print an ellipsis.
    let l:content = '...'
    for l:line in getline(l:start_num + 1, l:end_num - 1)
      let l:content_match = matchstr(l:line, '\m\C^\s*name = \zs.*\ze,$')
      if !empty(l:content_match)
        let l:content = l:content_match
        break
      endif
    endfor
  endif

  " Enclose content with start and end
  let l:start_text = getline(l:start_num)
  let l:end_text = substitute(getline(l:end_num), '^\s*', '', '')
  let l:text = l:start_text . ' ' . l:content . ' ' . l:end_text

  " Compute the available width for the displayed text.
  let l:width = winwidth(0) - &foldcolumn - (&number ? &numberwidth : 0)
  let l:lines_folded = ' ' . string(1 + v:foldend - v:foldstart) . ' lines'

  " Expand tabs, truncate, pad, and concatenate
  let l:text = substitute(l:text, '\t', repeat(' ', &tabstop), 'g')
  let l:text = strpart(l:text, 0, l:width - len(l:lines_folded))
  let l:padding = repeat(' ', l:width - len(l:lines_folded) - len(l:text))
  return l:text . l:padding . l:lines_folded
endfunction

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:	C
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Sep 21

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< ofu< cms< def< inc< | if has('vms') | setl isk< | endif"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" These options have the right value as default, but the user may have
" overruled that.
setlocal commentstring& define& include&

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&ofu')
  setlocal ofu=ccomplete#Complete
endif

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" In VMS C keywords contain '$' characters.
if has("vms")
  setlocal iskeyword+=$
endif

" When the matchit plugin is loaded, this makes the % command skip parens and
" braces in comments properly.
if !exists("b:match_words")
  let b:match_words = '^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
  let b:match_skip = 's:comment\|string\|character\|special'
  let b:undo_ftplugin ..= " | unlet! b:match_skip b:match_words"
endif

" Win32 can filter files in the browse dialog
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  if &ft == "cpp"
    let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
	  \ "C Header Files (*.h)\t*.h\n" .
	  \ "C Source Files (*.c)\t*.c\n" .
	  \ "All Files (*.*)\t*.*\n"
  elseif &ft == "ch"
    let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
	  \ "C Header Files (*.h)\t*.h\n" .
	  \ "C Source Files (*.c)\t*.c\n" .
	  \ "All Files (*.*)\t*.*\n"
  else
    let b:browsefilter = "C Source Files (*.c)\t*.c\n" .
	  \ "C Header Files (*.h)\t*.h\n" .
	  \ "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
	  \ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
	  \ "All Files (*.*)\t*.*\n"
  endif
  let b:undo_ftplugin ..= " | unlet! b:browsefilter"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:             calendar(1) input file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring& include&
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:		Configuration File
" Maintainer:		Christian Brabandt <cb@256bit.org>
" Latest Revision:	2018-12-24

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl cms< fo<"

setlocal commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:     Ch
" Maintainer:   SoftIntegration, Inc. <info@softintegration.com>
" URL:		http://www.softintegration.com/download/vim/ftplugin/ch.vim
" Last change:	2004 May 16
"		Created based on cpp.vim
"
" Ch is a C/C++ interpreter with many high level extensions
"

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves just like C
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin file
" Language:             generic Changelog file
" Maintainer:           Martin Florian <marfl@posteo.de>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2021-10-17
" Variables:
"   g:changelog_timeformat (deprecated: use g:changelog_dateformat instead) -
"       description: the timeformat used in ChangeLog entries.
"       default: "%Y-%m-%d".
"   g:changelog_dateformat -
"       description: the format sent to strftime() to generate a date string.
"       default: "%Y-%m-%d".
"   g:changelog_username -
"       description: the username to use in ChangeLog entries
"       default: try to deduce it from environment variables and system files.
" Local Mappings:
"   <Leader>o -
"       adds a new changelog entry for the current user for the current date.
" Global Mappings:
"   <Leader>o -
"       switches to the ChangeLog buffer opened for the current directory, or
"       opens it in a new buffer if it exists in the current directory.  Then
"       it does the same as the local <Leader>o described above.
" Notes:
"   run 'runtime ftplugin/changelog.vim' to enable the global mapping for
"   changelog files.
" TODO:
"  should we perhaps open the ChangeLog file even if it doesn't exist already?
"  Problem is that you might end up with ChangeLog files all over the place.

" If 'filetype' isn't "changelog", we must have been to add ChangeLog opener
if &filetype == 'changelog'
  if exists('b:did_ftplugin')
    finish
  endif
  let b:did_ftplugin = 1

  let s:cpo_save = &cpo
  set cpo&vim

  " Set up the format used for dates.
  if !exists('g:changelog_dateformat')
    if exists('g:changelog_timeformat')
      let g:changelog_dateformat = g:changelog_timeformat
    else
      let g:changelog_dateformat = "%Y-%m-%d"
    endif
  endif

  function! s:username()
    if exists('g:changelog_username')
      return g:changelog_username
    elseif $EMAIL != ""
      return $EMAIL
    elseif $EMAIL_ADDRESS != ""
      return $EMAIL_ADDRESS
    endif

    let login = s:login()
    return printf('%s <%s@%s>', s:name(login), login, s:hostname())
  endfunction

  function! s:login()
    return s:trimmed_system_with_default('whoami', 'unknown')
  endfunction

  function! s:trimmed_system_with_default(command, default)
    return s:first_line(s:system_with_default(a:command, a:default))
  endfunction

  function! s:system_with_default(command, default)
    let output = system(a:command)
    if v:shell_error
      return default
    endif
    return output
  endfunction

  function! s:first_line(string)
    return substitute(a:string, '\n.*$', "", "")
  endfunction

  function! s:name(login)
    for name in [s:gecos_name(a:login), $NAME, s:capitalize(a:login)]
      if name != ""
        return name
      endif
    endfor
  endfunction

  function! s:gecos_name(login)
    for line in s:try_reading_file('/etc/passwd')
      if line =~ '^' . a:login . ':'
        return substitute(s:passwd_field(line, 5), '&', s:capitalize(a:login), "")
      endif
    endfor
    return ""
  endfunction

  function! s:try_reading_file(path)
    try
      return readfile(a:path)
    catch
      return []
    endtry
  endfunction

  function! s:passwd_field(line, field)
    let fields = split(a:line, ':', 1)
    if len(fields) < a:field
      return ""
    endif
    return fields[a:field - 1]
  endfunction

  function! s:capitalize(word)
    return toupper(a:word[0]) . strpart(a:word, 1)
  endfunction

  function! s:hostname()
    return s:trimmed_system_with_default('hostname', 'localhost')
  endfunction

  " Format used for new date entries.
  if !exists('g:changelog_new_date_format')
    let g:changelog_new_date_format = "%d  %u\n\n\t* %p%c\n\n"
  endif

  " Format used for new entries to current date entry.
  if !exists('g:changelog_new_entry_format')
    let g:changelog_new_entry_format = "\t* %p%c"
  endif

  " Regular expression used to find a given date entry.
  if !exists('g:changelog_date_entry_search')
    let g:changelog_date_entry_search = '^\s*%d\_s*%u'
  endif

  " Regular expression used to find the end of a date entry
  if !exists('g:changelog_date_end_entry_search')
    let g:changelog_date_end_entry_search = '^\s*$'
  endif


  " Substitutes specific items in new date-entry formats and search strings.
  " Can be done with substitute of course, but unclean, and need \@! then.
  function! s:substitute_items(str, date, user, prefix)
    let str = a:str
    let middles = {'%': '%', 'd': a:date, 'u': a:user, 'p': a:prefix, 'c': '{cursor}'}
    let i = stridx(str, '%')
    while i != -1
      let inc = 0
      if has_key(middles, str[i + 1])
        let mid = middles[str[i + 1]]
        let str = strpart(str, 0, i) . mid . strpart(str, i + 2)
        let inc = strlen(mid) - 1
      endif
      let i = stridx(str, '%', i + 1 + inc)
    endwhile
    return str
  endfunction

  " Position the cursor once we've done all the funky substitution.
  function! s:position_cursor()
    if search('{cursor}') > 0
      let lnum = line('.')
      let line = getline(lnum)
      let cursor = stridx(line, '{cursor}')
      call setline(lnum, substitute(line, '{cursor}', '', ''))
    endif
    startinsert
  endfunction

  " Internal function to create a new entry in the ChangeLog.
  function! s:new_changelog_entry(prefix)
    " Deal with 'paste' option.
    let save_paste = &paste
    let &paste = 1
    call cursor(1, 1)
    " Look for an entry for today by our user.
    let date = strftime(g:changelog_dateformat)
    let search = s:substitute_items(g:changelog_date_entry_search, date,
                                  \ s:username(), a:prefix)
    if search(search) > 0
      " Ok, now we look for the end of the date entry, and add an entry.
      call cursor(nextnonblank(line('.') + 1), 1)
      if search(g:changelog_date_end_entry_search, 'W') > 0
	let p = (line('.') == line('$')) ? line('.') : line('.') - 1
      else
        let p = line('.')
      endif
      let ls = split(s:substitute_items(g:changelog_new_entry_format, '', '', a:prefix),
                   \ '\n')
      call append(p, ls)
      call cursor(p + 1, 1)
    else
      " Flag for removing empty lines at end of new ChangeLogs.
      let remove_empty = line('$') == 1

      " No entry today, so create a date-user header and insert an entry.
      let todays_entry = s:substitute_items(g:changelog_new_date_format,
                                          \ date, s:username(), a:prefix)
      " Make sure we have a cursor positioning.
      if stridx(todays_entry, '{cursor}') == -1
        let todays_entry = todays_entry . '{cursor}'
      endif

      " Now do the work.
      call append(0, split(todays_entry, '\n'))

      " Remove empty lines at end of file.
      if remove_empty
        $-/^\s*$/-1,$delete
      endif

      " Reposition cursor once we're done.
      call cursor(1, 1)
    endif

    call s:position_cursor()

    " And reset 'paste' option
    let &paste = save_paste
  endfunction

  let b:undo_ftplugin = "setl com< fo< et< ai<"

  setlocal comments=
  setlocal formatoptions+=t
  setlocal noexpandtab
  setlocal autoindent

  if &textwidth == 0
    setlocal textwidth=78
    let b:undo_ftplugin .= " tw<"
  endif

  if !exists("no_plugin_maps") && !exists("no_changelog_maps") && exists(":NewChangelogEntry") != 2
    nnoremap <buffer> <silent> <Leader>o :<C-u>call <SID>new_changelog_entry('')<CR>
    xnoremap <buffer> <silent> <Leader>o :<C-u>call <SID>new_changelog_entry('')<CR>
    command! -buffer -nargs=0 NewChangelogEntry call s:new_changelog_entry('')
    let b:undo_ftplugin .= " | sil! exe 'nunmap <buffer> <Leader>o'" .
          \                " | sil! exe 'vunmap <buffer> <Leader>o'" .
          \                " | sil! delc NewChangelogEntry"
  endif

  let &cpo = s:cpo_save
  unlet s:cpo_save
else
  let s:cpo_save = &cpo
  set cpo&vim

  if !exists("no_plugin_maps") && !exists("no_changelog_maps")
    " Add the Changelog opening mapping
    nnoremap <silent> <Leader>o :call <SID>open_changelog()<CR>
    let b:undo_ftplugin .= " | silent! exe 'nunmap <buffer> <Leader>o"
  endif

  function! s:open_changelog()
    let path = expand('%:p:h')
    if exists('b:changelog_path')
      let changelog = b:changelog_path
    else
      if exists('b:changelog_name')
        let name = b:changelog_name
      else
        let name = 'ChangeLog'
      endif
      while isdirectory(path)
        let changelog = path . '/' . name
        if filereadable(changelog)
          break
        endif
        let parent = substitute(path, '/\+[^/]*$', "", "")
        if path == parent
          break
        endif
        let path = parent
      endwhile
    endif
    if !filereadable(changelog)
      return
    endif

    if exists('b:changelog_entry_prefix')
      let prefix = call(b:changelog_entry_prefix, [])
    else
      let prefix = substitute(strpart(expand('%:p'), strlen(path)), '^/\+', "", "")
    endif

    let buf = bufnr(changelog)
    if buf != -1
      if bufwinnr(buf) != -1
        execute bufwinnr(buf) . 'wincmd w'
      else
        execute 'sbuffer' buf
      endif
    else
      execute 'split' fnameescape(changelog)
    endif

    call s:new_changelog_entry(prefix)
  endfunction

  let &cpo = s:cpo_save
  unlet s:cpo_save
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " CHICKEN-specific Vim customizations
" Last Change: 2018-03-05
" Author: Evan Hanson <evhan@foldling.org>
" Maintainer: Evan Hanson <evhan@foldling.org>
" Repository: https://git.foldling.org/vim-scheme.git
" URL: https://foldling.org/vim/ftplugin/chicken.vim
" Notes: These are supplemental settings, to be loaded after the core
" Scheme ftplugin file (ftplugin/scheme.vim). Enable it by setting
" b:is_chicken=1 and filetype=scheme.

if !exists('b:did_scheme_ftplugin')
  finish
endif

setl keywordprg=chicken-doc

setl lispwords+=and-let*
setl lispwords+=compiler-typecase
setl lispwords+=condition-case
setl lispwords+=define-compiler-syntax
setl lispwords+=define-constant
setl lispwords+=define-external
setl lispwords+=define-for-syntax
setl lispwords+=define-foreign-type
setl lispwords+=define-inline
setl lispwords+=define-location
setl lispwords+=define-record
setl lispwords+=define-record-printer
setl lispwords+=define-specialization
setl lispwords+=fluid-let
setl lispwords+=foreign-lambda*
setl lispwords+=foreign-primitive
setl lispwords+=foreign-safe-lambda*
setl lispwords+=functor
setl lispwords+=handle-exceptions
setl lispwords+=let-compiler-syntax
setl lispwords+=let-location
setl lispwords+=let-optionals
setl lispwords+=let-optionals*
setl lispwords+=letrec-values
setl lispwords+=match
setl lispwords+=match-let
setl lispwords+=match-let*
setl lispwords+=match-letrec
setl lispwords+=module
setl lispwords+=receive
setl lispwords+=set!-values
setl lispwords+=test-group

let b:undo_ftplugin = b:undo_ftplugin . ' keywordprg<'

if exists('g:loaded_matchit') && !exists('b:match_words')
  let b:match_words = '#>:<#'
  let b:undo_ftplugin = b:undo_ftplugin . ' | unlet! b:match_words'
endif
                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:           Clojure
" Maintainer:         Alex Vear <alex@vear.uk>
" Former Maintainers: Sung Pae <self@sungpae.com>
"                     Meikel Brandmeyer <mb@kotka.de>
" URL:                https://github.com/clojure-vim/clojure.vim
" License:            Vim (see :h license)
" Last Change:        2021-10-26

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = 'setlocal iskeyword< define< formatoptions< comments< commentstring< lispwords<'

setlocal iskeyword+=?,-,*,!,+,/,=,<,>,.,:,$,%,&,\|

" There will be false positives, but this is better than missing the whole set
" of user-defined def* definitions.
setlocal define=\\v[(/]def(ault)@!\\S*

" Remove 't' from 'formatoptions' to avoid auto-wrapping code.
setlocal formatoptions-=t

" Lisp comments are routinely nested (e.g. ;;; SECTION HEADING)
setlocal comments=n:;
setlocal commentstring=;\ %s

" Specially indented symbols from clojure.core and clojure.test.
"
" Clojure symbols are indented in the defn style when they:
"
"   * Define vars and anonymous functions
"   * Create new lexical scopes or scopes with altered environments
"   * Create conditional branches from a predicate function or value
"
" The arglists for these functions are generally in the form of [x & body];
" Functions that accept a flat list of forms do not treat the first argument
" specially and hence are not indented specially.
"
" -*- LISPWORDS -*-
" Generated from https://github.com/clojure-vim/clojure.vim/blob/62b215f079ce0f3834fd295c7a7f6bd8cc54bcc3/clj/src/vim_clojure_static/generate.clj
setlocal lispwords=as->,binding,bound-fn,case,catch,cond->,cond->>,condp,def,definline,definterface,defmacro,defmethod,defmulti,defn,defn-,defonce,defprotocol,defrecord,defstruct,deftest,deftest-,deftype,doseq,dotimes,doto,extend,extend-protocol,extend-type,fn,for,if,if-let,if-not,if-some,let,letfn,locking,loop,ns,proxy,reify,set-test,testing,when,when-first,when-let,when-not,when-some,while,with-bindings,with-in-str,with-local-vars,with-open,with-precision,with-redefs,with-redefs-fn,with-test

" Provide insert mode completions for special forms and clojure.core. As
" 'omnifunc' is set by popular Clojure REPL client plugins, we also set
" 'completefunc' so that the user has some form of completion available when
" 'omnifunc' is set and no REPL connection exists.
for s:setting in ['omnifunc', 'completefunc']
	if exists('&' . s:setting) && empty(eval('&' . s:setting))
		execute 'setlocal ' . s:setting . '=clojurecomplete#Complete'
		let b:undo_ftplugin .= ' | setlocal ' . s:setting . '<'
	endif
endfor

" Skip brackets in ignored syntax regions when using the % command
if exists('loaded_matchit')
	let b:match_words = &matchpairs
	let b:match_skip = 's:comment\|string\|regex\|character'
	let b:undo_ftplugin .= ' | unlet! b:match_words b:match_skip'
endif

" Filter files in the browse dialog
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
	let b:browsefilter = "Clojure Source Files (*.clj)\t*.clj\n" .
	                   \ "ClojureScript Source Files (*.cljs)\t*.cljs\n" .
	                   \ "Java Source Files (*.java)\t*.java\n" .
	                   \ "All Files (*.*)\t*.*\n"
	let b:undo_ftplugin .= ' | unlet! b:browsefilter'
endif

let &cpo = s:cpo_save

unlet! s:cpo_save s:setting s:dir

" vim:sts=8:sw=8:ts=8:noet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin
" Language:    CMake
" Maintainer:  Keith Smiley <keithbsmiley@gmail.com>
" Last Change: 2018 Aug 30

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" save 'cpo' for restoration at the end of this file
let s:cpo_save = &cpo
set cpo&vim

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl commentstring<"

if exists('loaded_matchit')
  let b:match_words = '\<if\>:\<elseif\>\|\<else\>:\<endif\>'
        \ . ',\<foreach\>\|\<while\>:\<break\>:\<endforeach\>\|\<endwhile\>'
        \ . ',\<macro\>:\<endmacro\>'
        \ . ',\<function\>:\<endfunction\>'
  let b:match_ignorecase = 1

  let b:undo_ftplugin .= "| unlet b:match_words"
endif

setlocal commentstring=#\ %s

" restore 'cpo' and clean up buffer variable
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                             " Vim filetype plugin file
" Language:	cobol
" Maintainer: Ankit Jain <ajatkj@yahoo.co.in>
"     (formerly Tim Pope <vimNOSPAM@tpope.info>)
" Last Update:	By Ankit Jain (add gtk support) on 15.08.2020

" Insert mode mappings: <C-T> <C-D> <Tab>
" Normal mode mappings: < > << >> [[ ]] [] ][
" Visual mode mappings: < >

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal commentstring=\ \ \ \ \ \ *%s
setlocal comments=:*
setlocal fo+=croqlt
setlocal expandtab
setlocal textwidth=72

" matchit support
if exists("loaded_matchit")
    let s:ordot = '\|\ze\.\%( \@=\|$\)'
    let b:match_ignorecase=1
    "let b:match_skip = 'getline(".") =~ "^.\\{6\\}[*/C]"'
    let b:match_words=
    \ '\$if\>:$else\>:\$endif\>,' .
    \ '[$-]\@<!\<if\>:\<\%(then\|else\)\>:\<end-if\>'.s:ordot.',' .
    \ '-\@<!\<perform\s\+\%(\d\+\s\+times\|until\|varying\|with\s\+test\)\>:\<end-perform\>'.s:ordot . ',' .
    \ '-\@<!\<\%(search\|evaluate\)\>:\<\%(when\)\>:\<end-\%(search\|evaluate\)\>' .s:ordot . ',' .
    \ '-\@<!\<\%(add\|compute\|divide\|multiply\|subtract\)\>\%(.*\(\%$\|\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*\%(not\s\+\)\=on\s\+size\s\+error\>\)\)\@=:\%(\<not\s\+\)\@<!\<\%(not\s\+\)\=on\s\+size\s\+error\>:\<end-\%(add\|compute\|divide\|multiply\|subtract\)\>' .s:ordot . ',' .
    \ '-\@<!\<\%(string\|unstring\|accept\|display\|call\)\>\%(.*\(\%$\|\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*\%(not\s\+\)\=on\s\+\%(overflow\|exception\)\>\)\)\@=:\%(\<not\s\+\)\@<!\<\%(not\s\+\)\=on\s\+\%(overflow\|exception\)\>:\<end-\%(string\|unstring\|accept\|display\|call\)\>' .s:ordot . ',' .
    \ '-\@<!\<\%(delete\|rewrite\|start\|write\|read\)\>\%(.*\(\%$\|\%(\n\%(\%(\s*\|.\{6\}\)[*/].*\n\)*\)\=\s*\%(invalid\s\+key\|at\s\+end\|no\s\+data\|at\s\+end-of-page\)\>\)\)\@=:\%(\<not\s\+\)\@<!\<\%(not\s\+\)\=\%(invalid\s\+key\|at\s\+end\|no\s\+data\|at\s\+end-of-page\)\>:\<end-\%(delete\|rewrite\|start\|write\|read\)\>' .s:ordot
endif

" add gtk support
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "COBOL Source Files (*.cbl, *.cob)\t*.cbl;*.cob;*.lib\n".
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal com< cms< fo< et< tw<" .
            \ " | unlet! b:browsefilter b:match_words b:match_ignorecase b:match_skip"
if !exists("g:no_plugin_maps") && !exists("g:no_cobol_maps")
    let b:undo_ftplugin = b:undo_ftplugin .
            \ " | sil! exe 'nunmap <buffer> <'" .
            \ " | sil! exe 'nunmap <buffer> >'" .
            \ " | sil! exe 'nunmap <buffer> <<'" .
            \ " | sil! exe 'nunmap <buffer> >>'" .
            \ " | sil! exe 'vunmap <buffer> <'" .
            \ " | sil! exe 'vunmap <buffer> >'" .
            \ " | sil! exe 'iunmap <buffer> <C-D>'" .
            \ " | sil! exe 'iunmap <buffer> <C-T>'" .
            \ " | sil! exe 'iunmap <buffer> <Tab>'" .
            \ " | sil! exe 'nunmap <buffer> <Plug>Traditional'" .
            \ " | sil! exe 'nunmap <buffer> <Plug>Comment'" .
            \ " | sil! exe 'nunmap <buffer> <Plug>DeComment'" .
            \ " | sil! exe 'vunmap <buffer> <Plug>VisualTraditional'" .
            \ " | sil! exe 'vunmap <buffer> <Plug>VisualComment'" .
            \ " | sil! exe 'iunmap <buffer> <Plug>VisualDeComment'" .
            \ " | sil! exe 'unmap  <buffer> [['" .
            \ " | sil! exe 'unmap  <buffer> ]]'" .
            \ " | sil! exe 'unmap  <buffer> []'" .
            \ " | sil! exe 'unmap  <buffer> ]['"
endif

if !exists("g:no_plugin_maps") && !exists("g:no_cobol_maps")
    if version >= 700
        nnoremap <silent> <buffer> > :set opfunc=<SID>IncreaseFunc<CR>g@
        nnoremap <silent> <buffer> < :set opfunc=<SID>DecreaseFunc<CR>g@
    endif
    nnoremap <silent> <buffer> >> :call CobolIndentBlock(1)<CR>
    nnoremap <silent> <buffer> << :call CobolIndentBlock(-1)<CR>
    vnoremap <silent> <buffer> > :call CobolIndentBlock(v:count1)<CR>
    vnoremap <silent> <buffer> < :call CobolIndentBlock(-v:count1)<CR>
    inoremap <silent> <buffer> <C-T> <C-R>=<SID>IncreaseIndent()<CR><C-R>=<SID>RestoreShiftwidth()<CR>
    inoremap <silent> <buffer> <C-D> <C-R>=<SID>DecreaseIndent()<CR><C-R>=<SID>RestoreShiftwidth()<CR>
    if !maparg("<Tab>","i")
        inoremap <silent> <buffer> <Tab> <C-R>=<SID>Tab()<CR><C-R>=<SID>RestoreShiftwidth()<CR>
    endif
    noremap <silent> <buffer> [[ m':call search('\c^\%(\s*\<Bar>.\{6\}\s\+\)\zs[A-Za-z0-9-]\+\s\+\%(division\<Bar>section\)\s*\.','bW')<CR>
    noremap <silent> <buffer> ]] m':call search('\c^\%(\s*\<Bar>.\{6\}\s\+\)\zs[A-Za-z0-9-]\+\s\+\%(division\<Bar>section\)\.','W')<CR>
    noremap <silent> <buffer> [] m':call <SID>toend('b')<CR>
    noremap <silent> <buffer> ][ m':call <SID>toend('')<CR>
    " For EnhancedCommentify
    noremap <silent> <buffer> <Plug>Traditional      :call <SID>Comment('t')<CR>
    noremap <silent> <buffer> <Plug>Comment          :call <SID>Comment('c')<CR>
    noremap <silent> <buffer> <Plug>DeComment        :call <SID>Comment('u')<CR>
    noremap <silent> <buffer> <Plug>VisualTraditional :'<,'>call <SID>Comment('t')<CR>
    noremap <silent> <buffer> <Plug>VisualComment     :'<,'>call <SID>Comment('c')<CR>
    noremap <silent> <buffer> <Plug>VisualDeComment   :'<,'>call <SID>Comment('u')<CR>
endif

let &cpo = s:cpo_save
unlet s:cpo_save

if exists("g:did_cobol_ftplugin_functions")
    finish
endif
let g:did_cobol_ftplugin_functions = 1

function! s:repeat(str,count)
    let i = 0
    let ret = ""
    while i < a:count
        let ret = ret . a:str
        let i = i + 1
    endwhile
    return ret
endfunction

function! s:increase(...)
    let lnum = '.'
    let sw = shiftwidth()
    let i = a:0 ? a:1 : indent(lnum)
    if i >= 11
        return sw - (i - 11) % sw
    elseif i >= 7
        return 11-i
    elseif i == 6
        return 1
    else
        return 6-i
    endif
endfunction

function! s:decrease(...)
    let lnum = '.'
    let sw = shiftwidth()
    let i = indent(a:0 ? a:1 : lnum)
    if i >= 11 + sw
        return 1 + (i + 12) % sw
    elseif i > 11
        return i-11
    elseif i > 7
        return i-7
    elseif i == 7
        return 1
    else
        return i
    endif
endfunction

function! CobolIndentBlock(shift)
    let head = strpart(getline('.'),0,7)
    let tail = strpart(getline('.'),7)
    let indent = match(tail,'[^ ]')
    let sw = shiftwidth()
    let shift = a:shift
    if shift > 0
        if indent < 4
            let tail = s:repeat(" ",4-indent).tail
            let shift = shift - 1
        endif
        let tail = s:repeat(" ",shift*sw).tail
        let shift = 0
    elseif shift < 0
        if (indent-4) > -shift * sw
            let tail = strpart(tail,-shift * sw)
        elseif (indent-4) > (-shift-1) * sw
            let tail = strpart(tail,indent - 4)
        else
            let tail = strpart(tail,indent)
        endif
    endif
    call setline('.',head.tail)
endfunction

function! s:IncreaseFunc(type)
    '[,']call CobolIndentBlock(1)
endfunction

function! s:DecreaseFunc(type)
    '[,']call CobolIndentBlock(-1)
endfunction

function! s:IncreaseIndent()
    let c = "\<C-T>"
    if exists("*InsertCtrlTWrapper")
        let key = InsertCtrlTWrapper()
        if key != c
            return key
        endif
    endif
    let interval = s:increase()
    let b:cobol_shiftwidth = &shiftwidth
    let &shiftwidth = 1
    let lastchar = strpart(getline('.'),col('.')-2,1)
    if lastchar == '0' || lastchar == '^'
        return "\<BS>".lastchar.c
    else
        return s:repeat(c,interval)
    endif
endfunction

function! s:DecreaseIndent()
    let c = "\<C-D>"
    if exists("*InsertCtrlDWrapper")
        " I hack Ctrl-D to delete when not at the end of the line.
        let key = InsertCtrlDWrapper()
        if key != c
            return key
        endif
    endif
    let interval = s:decrease()
    let b:cobol_shiftwidth = &shiftwidth
    let &shiftwidth = 1
    return s:repeat(c,interval)
endfunction

function! s:RestoreShiftwidth()
    if exists("b:cobol_shiftwidth")
        let &shiftwidth=b:cobol_shiftwidth
        unlet b:cobol_shiftwidth
    endif
    return ""
endfunction

function! s:Tab()
    if (strpart(getline('.'),0,col('.')-1) =~ '^\s*$' && &sta)
        return s:IncreaseIndent()
    " &softtabstop < 0: &softtabstop follows &shiftwidth
    elseif (&sts < 0 || &sts == shiftwidth()) && &sts != 8 && &et
        return s:repeat(" ",s:increase(col('.')-1))
    else
        return "\<Tab>"
    endif
endfunction

function! s:Comment(arg)
    " For EnhancedCommentify
    let line = getline('.')
    if (line =~ '^.\{6\}[*/C]' || a:arg == 'c') && a:arg != 'u'
        let line = substitute(line,'^.\{6\}\zs.',' ','')
    else
        let line = substitute(line,'^.\{6\}\zs.','*','')
    endif
    call setline('.',line)
endfunction

function! s:toend(direction)
    let ignore = '^\(\s*\|.\{6\}\)\%([*/]\|\s*$\)'
    let keep = line('.')
    keepjumps +
    while line('.') < line('$') && getline('.') =~ ignore
        keepjumps +
    endwhile
    let res = search('\c^\%(\s*\|.\{6\}\s\+\)\zs[A-Za-z0-9-]\+\s\+\%(division\|section\)\s*\.',a:direction.'W')
    if a:direction != 'b' && !res
        let res = line('$')
        keepjumps $
    elseif res
        keepjumps -
    endif
    if res
        while line('.') > 1 && getline('.') =~ ignore
            keepjumps -
        endwhile
        if line('.') == 1 && getline('.') =~ ignore
            exe "keepjumps ".keep
        endif
    else
        exe "keepjumps ".keep
    endif
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:             generic configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:	config
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "Bourne Shell Files (*.sh)\t*.sh\n" .
	    \	 "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/sh.vim ftplugin/sh_*.vim ftplugin/sh/*.vim
let b:did_ftplugin = 1

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
endif

" Change the :browse e filter to primarily show configure-related files.
if has("gui_win32")
    let  b:browsefilter="Configure Scripts (configure.*, config.*)\tconfigure*;config.*\n" .
		\	s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter | " . b:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin file
" Language:           ConTeXt typesetting engine
" Maintainer:         Nicola Vitacolonna <nvitacolonna@gmail.com>
" Former Maintainers: Nikolai Weibull <now@bitwi.se>
" Latest Revision:    2021 Oct 15

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

if !exists('current_compiler')
  compiler context
endif

let b:undo_ftplugin = "setl com< cms< def< inc< sua< fo< ofu<"

setlocal comments=b:%D,b:%C,b:%M,:% commentstring=%\ %s formatoptions+=tjcroql2
if get(b:, 'context_metapost', get(g:, 'context_metapost', 1))
  setlocal omnifunc=contextcomplete#Complete
  let g:omni_syntax_group_include_context = 'mf\w\+,mp\w\+'
  let g:omni_syntax_group_exclude_context = 'mfTodoComment'
endif

let &l:define='\\\%([egx]\|char\|mathchar\|count\|dimen\|muskip\|skip\|toks\)\='
        \ .     'def\|\\font\|\\\%(future\)\=let'
        \ . '\|\\new\%(count\|dimen\|skip\|muskip\|box\|toks\|read\|write'
        \ .     '\|fam\|insert\|if\)'

let &l:include = '^\s*\\\%(input\|component\|product\|project\|environment\)'

setlocal suffixesadd=.tex

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0
  let b:match_skip = 'r:\\\@<!\%(\\\\\)*%'
  let b:match_words = '(:),\[:],{:},\\(:\\),\\\[:\\],' .
        \ '\\start\(\a\+\):\\stop\1'
  let b:undo_ftplugin .= " | unlet! b:match_ignorecase b:match_words b:match_skip"
endif

let s:context_regex = {
      \ 'beginsection' : '\\\%(start\)\=\%(\%(sub\)*section\|\%(sub\)*subject\|chapter\|part\|component\|product\|title\)\>',
      \ 'endsection'   : '\\\%(stop\)\=\%(\%(sub\)*section\|\%(sub\)*subject\|chapter\|part\|component\|product\|title\)\>',
      \ 'beginblock'   : '\\\%(start\|setup\|define\)',
      \ 'endblock'     : '\\\%(stop\|setup\|define\)'
      \ }

function! s:move_around(count, what, flags, visual)
  if a:visual
    exe "normal! gv"
  endif
  call search(s:context_regex[a:what], a:flags.'s') " 's' sets previous context mark
  call map(range(2, a:count), 'search(s:context_regex[a:what], a:flags)')
endfunction

if !exists("no_plugin_maps") && !exists("no_context_maps")
  " Move around macros.
  nnoremap <silent><buffer> [[ :<C-U>call <SID>move_around(v:count1, "beginsection", "bW", v:false) <CR>
  vnoremap <silent><buffer> [[ :<C-U>call <SID>move_around(v:count1, "beginsection", "bW", v:true)  <CR>
  nnoremap <silent><buffer> ]] :<C-U>call <SID>move_around(v:count1, "beginsection", "W",  v:false) <CR>
  vnoremap <silent><buffer> ]] :<C-U>call <SID>move_around(v:count1, "beginsection", "W",  v:true)  <CR>
  nnoremap <silent><buffer> [] :<C-U>call <SID>move_around(v:count1, "endsection",   "bW", v:false) <CR>
  vnoremap <silent><buffer> [] :<C-U>call <SID>move_around(v:count1, "endsection",   "bW", v:true)  <CR>
  nnoremap <silent><buffer> ][ :<C-U>call <SID>move_around(v:count1, "endsection",   "W",  v:false) <CR>
  vnoremap <silent><buffer> ][ :<C-U>call <SID>move_around(v:count1, "endsection",   "W",  v:true)  <CR>
  nnoremap <silent><buffer> [{ :<C-U>call <SID>move_around(v:count1, "beginblock",   "bW", v:false) <CR>
  vnoremap <silent><buffer> [{ :<C-U>call <SID>move_around(v:count1, "beginblock",   "bW", v:true)  <CR>
  nnoremap <silent><buffer> ]} :<C-U>call <SID>move_around(v:count1, "endblock",     "W",  v:false) <CR>
  vnoremap <silent><buffer> ]} :<C-U>call <SID>move_around(v:count1, "endblock",     "W",  v:true)  <CR>

  let b:undo_ftplugin .= " | sil! exe 'nunmap <buffer> [[' | sil! exe 'vunmap <buffer> [['" .
	\                " | sil! exe 'nunmap <buffer> ]]' | sil! exe 'vunmap <buffer> ]]'" .
	\                " | sil! exe 'nunmap <buffer> []' | sil! exe 'vunmap <buffer> []'" .
	\                " | sil! exe 'nunmap <buffer> ][' | sil! exe 'vunmap <buffer> ]['" .
	\                " | sil! exe 'nunmap <buffer> [{' | sil! exe 'vunmap <buffer> [{'" .
	\                " | sil! exe 'nunmap <buffer> ]}' | sil! exe 'vunmap <buffer> ]}'"
end

" Other useful mappings
if get(g:, 'context_mappings', 1)
  let s:tp_regex = '?^$\|^\s*\\\(item\|start\|stop\|blank\|\%(sub\)*section\|chapter\|\%(sub\)*subject\|title\|part\)'

  fun! s:tp()
    call cursor(search(s:tp_regex, 'bcW') + 1, 1)
    normal! V
    call cursor(search(s:tp_regex, 'W') - 1, 1)
  endf

  if !exists("no_plugin_maps") && !exists("no_context_maps")
    " Reflow paragraphs with commands like gqtp ("gq TeX paragraph")
    onoremap <silent><buffer> tp :<c-u>call <sid>tp()<cr>
    " Select TeX paragraph
    vnoremap <silent><buffer> tp <esc>:<c-u>call <sid>tp()<cr>

    " $...$ text object
    onoremap <silent><buffer> i$ :<c-u>normal! T$vt$<cr>
    onoremap <silent><buffer> a$ :<c-u>normal! F$vf$<cr>
    vnoremap <buffer> i$ T$ot$
    vnoremap <buffer> a$ F$of$

    let b:undo_ftplugin .= " | sil! exe 'ounmap <buffer> tp' | sil! exe 'vunmap <buffer> tp'" .
	  \                " | sil! exe 'ounmap <buffer> i$' | sil! exe 'vunmap <buffer> i$'" .
	  \                " | sil! exe 'ounmap <buffer> a$' | sil! exe 'vunmap <buffer> a$'"
    endif
endif

" Commands for asynchronous typesetting
command! -buffer -nargs=? -complete=file ConTeXt          call context#typeset(<q-args>)
command!         -nargs=0                ConTeXtJobStatus call context#job_status()
command!         -nargs=0                ConTeXtStopJobs  call context#stop_jobs()

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin file
" Language:	C++
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2020 Jul 26

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Behaves mostly just like C
runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim

" C++ uses templates with <things>
" Disabled, because it gives an error for typing an unmatched ">".
" set matchpairs+=<:>
" let b:undo_ftplugin ..= ' | setl matchpairs<'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:             CRM114
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:	C#
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Tue, 09 Mar 2004 14:09:33 CET

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1
let s:keepcpo= &cpo
set cpo&vim

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,:///,://

if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "C# Source Files (*.cs)\t*.cs\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:	csc
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

if exists("loaded_matchit")
    let b:match_words=
	\ '\<fix\>:\<endfix\>,' .
	\ '\<if\>:\<else\%(if\)\=\>:\<endif\>,' .
	\ '\<!loopondimensions\>\|\<!looponselected\>:\<!endloop\>'
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:match_words"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                  " Vim filetype plugin file
" Language:		csh
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Contributor:		Johannes Zellner <johannes@zellner.org>
" Last Change:		2021 Oct 15

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo-=C

setlocal comments=:#
setlocal commentstring=#%s
setlocal formatoptions-=t
setlocal formatoptions+=crql

let b:undo_ftplugin = "setlocal com< cms< fo<"

" Csh:  thanks to Johannes Zellner
" - Both foreach and end must appear alone on separate lines.
" - The words else and endif must appear at the beginning of input lines;
"   the if must appear alone on its input line or after an else.
" - Each case label and the default label must appear at the start of a
"   line.
" - while and end must appear alone on their input lines.
if exists("loaded_matchit") && !exists("b:match_words")
  let s:line_start = '\%(^\s*\)\@<='
  let b:match_words =
	\ s:line_start .. 'if\s*(.*)\s*then\>:' ..
	\   s:line_start .. 'else\s\+if\s*(.*)\s*then\>:' .. s:line_start .. 'else\>:' ..
	\   s:line_start .. 'endif\>,' ..
	\ s:line_start .. '\%(\<foreach\s\+\h\w*\|while\)\s*(:' ..
	\   '\<break\>:\<continue\>:' ..
	\   s:line_start .. 'end\>,' ..
	\ s:line_start .. 'switch\s*(:' ..
	\   s:line_start .. 'case\s\+:' .. s:line_start .. 'default\>:\<breaksw\>:' ..
	\   s:line_start .. 'endsw\>'
  unlet s:line_start
  let b:undo_ftplugin ..= " | unlet b:match_words"
endif

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let  b:browsefilter="csh Scripts (*.csh)\t*.csh\n" ..
	\	      "All Files (*.*)\t*.*\n"
  let b:undo_ftplugin ..= " | unlet b:browsefilter"
endif

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:		CSS
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Nikolai Weibull <now@bitwi.se>
" Last Change:		2020 Dec 21

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo< ofu< isk<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring&
setlocal formatoptions-=t formatoptions+=croql
setlocal omnifunc=csscomplete#CompleteCSS
setlocal iskeyword+=-

let &l:include = '^\s*@import\s\+\%(url(\)\='

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin
" Language:	Cucumber
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2016 Aug 29

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:keepcpo= &cpo
set cpo&vim

setlocal formatoptions-=t formatoptions+=croql
setlocal comments=:# commentstring=#\ %s
setlocal omnifunc=CucumberComplete

let b:undo_ftplugin = "setl fo< com< cms< ofu<"

let b:cucumber_root = expand('%:p:h:s?.*[\/]\%(features\|stories\)\zs[\/].*??')
if !exists("b:cucumber_steps_glob")
  let b:cucumber_steps_glob = b:cucumber_root.'/**/*.rb'
endif

if !exists("g:no_plugin_maps") && !exists("g:no_cucumber_maps")
  cnoremap <SID>foldopen <Bar>if &foldopen =~# 'tag'<Bar>exe 'norm! zv'<Bar>endif
  nnoremap <silent> <script> <buffer> [<C-D>      :<C-U>exe <SID>jump('edit',v:count)<SID>foldopen<CR>
  nnoremap <silent> <script> <buffer> ]<C-D>      :<C-U>exe <SID>jump('edit',v:count)<SID>foldopen<CR>
  nnoremap <silent> <script> <buffer> <C-W>d      :<C-U>exe <SID>jump('split',v:count)<SID>foldopen<CR>
  nnoremap <silent> <script> <buffer> <C-W><C-D>  :<C-U>exe <SID>jump('split',v:count)<SID>foldopen<CR>
  nnoremap <silent> <script> <buffer> [d          :<C-U>exe <SID>jump('pedit',v:count)<CR>
  nnoremap <silent> <script> <buffer> ]d          :<C-U>exe <SID>jump('pedit',v:count)<CR>
  let b:undo_ftplugin .=
        \ "|sil! nunmap <buffer> [<C-D>" .
        \ "|sil! nunmap <buffer> ]<C-D>" .
        \ "|sil! nunmap <buffer> <C-W>d" .
        \ "|sil! nunmap <buffer> <C-W><C-D>" .
        \ "|sil! nunmap <buffer> [d" .
        \ "|sil! nunmap <buffer> ]d"
endif

function! s:jump(command,count)
  let steps = s:steps('.')
  if len(steps) == 0 || len(steps) < a:count
    return 'echoerr "No matching step found"'
  elseif len(steps) > 1 && !a:count
    return 'echoerr "Multiple matching steps found"'
  else
    let c = a:count ? a:count-1 : 0
    return a:command.' +'.steps[c][1].' '.escape(steps[c][0],' %#')
  endif
endfunction

function! s:allsteps()
  let step_pattern = '\C^\s*\K\k*\>\s*(\=\s*\zs\S.\{-\}\ze\s*)\=\s*\%(do\|{\)\s*\%(|[^|]*|\s*\)\=\%($\|#\)'
  let steps = []
  for file in split(glob(b:cucumber_steps_glob),"\n")
    let lines = readfile(file)
    let num = 0
    for line in lines
      let num += 1
      if line =~ step_pattern
        let type = matchstr(line,'\w\+')
        let steps += [[file,num,type,matchstr(line,step_pattern)]]
      endif
    endfor
  endfor
  return steps
endfunction

function! s:steps(lnum)
  let c = match(getline(a:lnum), '\S') + 1
  while synIDattr(synID(a:lnum,c,1),'name') !~# '^$\|Region$'
    let c = c + 1
  endwhile
  let step = matchstr(getline(a:lnum)[c-1 : -1],'^\s*\zs.\{-\}\ze\s*$')
  return filter(s:allsteps(),'s:stepmatch(v:val[3],step)')
endfunction

function! s:stepmatch(receiver,target)
  if a:receiver =~ '^[''"].*[''"]$'
    let pattern = '^'.escape(substitute(a:receiver[1:-2],'$\w\+','(.*)','g'),'/').'$'
  elseif a:receiver =~ '^/.*/$'
    let pattern = a:receiver[1:-2]
  elseif a:receiver =~ '^%r..*.$'
    let pattern = escape(a:receiver[3:-2],'/')
  else
    return 0
  endif
  try
    let vimpattern = substitute(substitute(pattern,'\\\@<!(?:','%(','g'),'\\\@<!\*?','{-}','g')
    if a:target =~# '\v'.vimpattern
      return 1
    endif
  catch
  endtry
  if has("ruby") && pattern !~ '\\\@<!#{'
    ruby VIM.command("return #{if (begin; Kernel.eval('/'+VIM.evaluate('pattern')+'/'); rescue SyntaxError; end) === VIM.evaluate('a:target') then 1 else 0 end}")
  else
    return 0
  endif
endfunction

function! s:bsub(target,pattern,replacement)
  return  substitute(a:target,'\C\\\@<!'.a:pattern,a:replacement,'g')
endfunction

function! CucumberComplete(findstart,base) abort
  let indent = indent('.')
  let group = synIDattr(synID(line('.'),indent+1,1),'name')
  let type = matchstr(group,'\Ccucumber\zs\%(Given\|When\|Then\)')
  let e = matchend(getline('.'),'^\s*\S\+\s')
  if type == '' || col('.') < col('$') || e < 0
    return -1
  endif
  if a:findstart
    return e
  endif
  let steps = []
  for step in s:allsteps()
    if step[2] ==# type
      if step[3] =~ '^[''"]'
        let steps += [step[3][1:-2]]
      elseif step[3] =~ '^/\^.*\$/$'
        let pattern = step[3][2:-3]
        let pattern = substitute(pattern,'\C^(?:|I )','I ','')
        let pattern = s:bsub(pattern,'\\[Sw]','w')
        let pattern = s:bsub(pattern,'\\d','1')
        let pattern = s:bsub(pattern,'\\[sWD]',' ')
        let pattern = s:bsub(pattern,'\[\^\\\="\]','_')
        let pattern = s:bsub(pattern,'[[:alnum:]. _-][?*]?\=','')
        let pattern = s:bsub(pattern,'\[\([^^]\).\{-\}\]','\1')
        let pattern = s:bsub(pattern,'+?\=','')
        let pattern = s:bsub(pattern,'(\([[:alnum:]. -]\{-\}\))','\1')
        let pattern = s:bsub(pattern,'\\\([[:punct:]]\)','\1')
        if pattern !~ '[\\()*?]'
          let steps += [pattern]
        endif
      endif
    endif
  endfor
  call filter(steps,'strpart(v:val,0,strlen(a:base)) ==# a:base')
  return sort(steps)
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:set sts=2 sw=2:
     " Vim filetype plugin file
" Language:             cvs(1) RC file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file (GUI menu, folding and completion)
" Language:     Debian Changelog
" Maintainer:   Debian Vim Maintainers
" Former Maintainers:   Michael Piefel <piefel@informatik.hu-berlin.de>
"                       Stefano Zacchiroli <zack@debian.org>
" Last Change:  2018-01-28
" License:      Vim License
" URL:          https://salsa.debian.org/vim-team/vim-debian/blob/master/ftplugin/debchangelog.vim

" Bug completion requires apt-listbugs installed for Debian packages or
" python-launchpadlib installed for Ubuntu packages

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin=1

" {{{1 Local settings (do on every load)
if exists('g:debchangelog_fold_enable')
  setlocal foldmethod=expr
  setlocal foldexpr=DebGetChangelogFold(v:lnum)
  setlocal foldtext=DebChangelogFoldText()
endif

" Debian changelogs are not supposed to have any other text width,
" so the user cannot override this setting
setlocal tw=78
setlocal comments=f:* 

" Clean unloading
let b:undo_ftplugin = 'setlocal tw< comments< foldmethod< foldexpr< foldtext<'
" }}}1

if exists('g:did_changelog_ftplugin')
  finish
endif

" Don't load another plugin (this is global)
let g:did_changelog_ftplugin = 1

" {{{1 GUI menu

" Helper functions returning various data.
" Returns full name, either from $DEBFULLNAME or debianfullname.
" TODO Is there a way to determine name from anywhere else?
function <SID>FullName()
    if exists('$DEBFULLNAME')
	return $DEBFULLNAME
    elseif exists('g:debianfullname')
	return g:debianfullname
    else
	return 'Your Name'
    endif
endfunction

" Returns email address, from $DEBEMAIL, $EMAIL or debianemail.
function <SID>Email()
    if exists('$DEBEMAIL')
	return $DEBEMAIL
    elseif exists('$EMAIL')
	return $EMAIL
    elseif exists('g:debianemail')
	return g:debianemail
    else
	return 'your@email.address'
    endif
endfunction

" Returns date in RFC822 format.
function <SID>Date()
    let savelang = v:lc_time
    execute 'language time C'
    let dateandtime = strftime('%a, %d %b %Y %X %z')
    execute 'language time ' . savelang
    return dateandtime
endfunction

function <SID>WarnIfNotUnfinalised()
    if match(getline('.'), ' -- [[:alpha:]][[:alnum:].]')!=-1
	echohl WarningMsg
	echo 'The entry has not been unfinalised before editing.'
	echohl None
	return 1
    endif
    return 0
endfunction

function <SID>Finalised()
    let savelinenum = line('.')
    1
    call search('^ -- ')
    if match(getline('.'), ' -- [[:alpha:]][[:alnum:].]')!=-1
	let returnvalue = 1
    else
	let returnvalue = 0
    endif
    execute savelinenum
    return returnvalue
endfunction

" These functions implement the menus
function NewVersion()
    " The new entry is unfinalised and shall be changed
    amenu disable Changelog.New\ Version
    amenu enable Changelog.Add\ Entry
    amenu enable Changelog.Close\ Bug
    amenu enable Changelog.Set\ Distribution
    amenu enable Changelog.Set\ Urgency
    amenu disable Changelog.Unfinalise
    amenu enable Changelog.Finalise
    call append(0, substitute(getline(1), '-\([[:digit:]]\+\))', '-$$\1)', ''))
    call append(1, '')
    call append(2, '')
    call append(3, ' -- ')
    call append(4, '')
    call Urgency('low')
    normal! 1G0
    call search(')')
    normal! h
    normal! 
    call setline(1, substitute(getline(1), '-\$\$', '-', ''))
    if exists('g:debchangelog_fold_enable')
        foldopen
    endif
    call AddEntry()
endfunction

function AddEntry()
    1
    call search('^ -- ')
    .-2
    call append('.', '  * ')
    .+3
    let warn=<SID>WarnIfNotUnfinalised()
    .-2
    if warn
	echohl MoreMsg
	call input('Hit ENTER')
	echohl None
    endif
    startinsert!
endfunction

function CloseBug()
    1
    call search('^ -- ')
    let warn=<SID>WarnIfNotUnfinalised()
    .-2
    call append('.', '  *  (closes: #' . input('Bug number to close: ') . ')')
    normal! j^ll
    startinsert
endfunction

function Distribution(dist)
    call setline(1, substitute(getline(1), ')  *\%(UNRELEASED\|\l\+\);', ') ' . a:dist . ';', ''))
endfunction

function Urgency(urg)
    call setline(1, substitute(getline(1), 'urgency=.*$', 'urgency=' . a:urg, ''))
endfunction

function <SID>UnfinaliseMenu()
    " This means the entry shall be changed
    amenu disable Changelog.New\ Version
    amenu enable Changelog.Add\ Entry
    amenu enable Changelog.Close\ Bug
    amenu enable Changelog.Set\ Distribution
    amenu enable Changelog.Set\ Urgency
    amenu disable Changelog.Unfinalise
    amenu enable Changelog.Finalise
endfunction

function Unfinalise()
    call <SID>UnfinaliseMenu()
    1
    call search('^ -- ')
    call setline('.', ' -- ')
endfunction

function <SID>FinaliseMenu()
    " This means the entry should not be changed anymore
    amenu enable Changelog.New\ Version
    amenu disable Changelog.Add\ Entry
    amenu disable Changelog.Close\ Bug
    amenu disable Changelog.Set\ Distribution
    amenu disable Changelog.Set\ Urgency
    amenu enable Changelog.Unfinalise
    amenu disable Changelog.Finalise
endfunction

function Finalise()
    call <SID>FinaliseMenu()
    1
    call search('^ -- ')
    call setline('.', ' -- ' . <SID>FullName() . ' <' . <SID>Email() . '>  ' . <SID>Date())
endfunction


function <SID>MakeMenu()
    amenu &Changelog.&New\ Version			:call NewVersion()<CR>
    amenu Changelog.&Add\ Entry				:call AddEntry()<CR>
    amenu Changelog.&Close\ Bug				:call CloseBug()<CR>
    menu Changelog.-sep-				<nul>

    amenu Changelog.Set\ &Distribution.&unstable	:call Distribution("unstable")<CR>
    amenu Changelog.Set\ Distribution.&frozen		:call Distribution("frozen")<CR>
    amenu Changelog.Set\ Distribution.&stable		:call Distribution("stable")<CR>
    menu Changelog.Set\ Distribution.-sep-		<nul>
    amenu Changelog.Set\ Distribution.frozen\ unstable	:call Distribution("frozen unstable")<CR>
    amenu Changelog.Set\ Distribution.stable\ unstable	:call Distribution("stable unstable")<CR>
    amenu Changelog.Set\ Distribution.stable\ frozen	:call Distribution("stable frozen")<CR>
    amenu Changelog.Set\ Distribution.stable\ frozen\ unstable	:call Distribution("stable frozen unstable")<CR>

    amenu Changelog.Set\ &Urgency.&low			:call Urgency("low")<CR>
    amenu Changelog.Set\ Urgency.&medium		:call Urgency("medium")<CR>
    amenu Changelog.Set\ Urgency.&high			:call Urgency("high")<CR>

    menu Changelog.-sep-				<nul>
    amenu Changelog.U&nfinalise				:call Unfinalise()<CR>
    amenu Changelog.&Finalise				:call Finalise()<CR>

    if <SID>Finalised()
	call <SID>FinaliseMenu()
    else
	call <SID>UnfinaliseMenu()
    endif
endfunction

augroup changelogMenu
au BufEnter * if &filetype == "debchangelog" | call <SID>MakeMenu() | endif
au BufLeave * if &filetype == "debchangelog" | silent! aunmenu Changelog | endif
augroup END

" }}}
" {{{1 folding

" look for an author name in the [zonestart zoneend] lines searching backward
function! s:getAuthor(zonestart, zoneend)
  let linepos = a:zoneend
  while linepos >= a:zonestart
    let line = getline(linepos)
    if line =~# '^ --'
      return substitute(line, '^ --\s*\([^<]\+\)\s*.*', '\1', '')
    endif
    let linepos -= 1
  endwhile
  return '[unknown]'
endfunction

" Look for a package source name searching backward from the givenline and
" returns it. Return the empty string if the package name can't be found
function! DebGetPkgSrcName(lineno)
  let lineidx = a:lineno
  let pkgname = ''
  while lineidx > 0
    let curline = getline(lineidx)
    if curline =~# '^\S'
      let pkgname = matchlist(curline, '^\(\S\+\).*$')[1]
      break
    endif
    let lineidx = lineidx - 1
  endwhile
  return pkgname
endfunction

function! DebChangelogFoldText()
  if v:folddashes ==# '-'  " changelog entry fold
    return foldtext() . ' -- ' . s:getAuthor(v:foldstart, v:foldend) . ' '
  endif
  return foldtext()
endfunction

function! DebGetChangelogFold(lnum)
  let line = getline(a:lnum)
  if line =~# '^\w\+'
    return '>1' " beginning of a changelog entry
  endif
  if line =~# '^\s\+\[.*\]'
    return '>2' " beginning of an author-specific chunk
  endif
  if line =~# '^ --'
    return '1'
  endif
  return '='
endfunction

if exists('g:debchangelog_fold_enable')
  silent! foldopen!   " unfold the entry the cursor is on (usually the first one)
endif

" }}}

" {{{1 omnicompletion for Closes: #

if !exists('g:debchangelog_listbugs_severities')
  let g:debchangelog_listbugs_severities = 'critical,grave,serious,important,normal,minor,wishlist'
endif

fun! DebCompleteBugs(findstart, base)
  if a:findstart
    let line = getline('.')

    " try to detect whether this is closes: or lp:
    let g:debchangelog_complete_mode = 'debbugs'
    let try_colidx = col('.') - 1
    let colidx = -1 " default to no-completion-possible

    while try_colidx > 0 && line[try_colidx - 1] =~# '\s\|\d\|#\|,\|:'
      let try_colidx = try_colidx - 1
      if line[try_colidx] ==# '#' && colidx == -1
        " found hash, where we complete from:
        let colidx = try_colidx
      elseif line[try_colidx] ==# ':'
        if try_colidx > 1 && strpart(line, try_colidx - 2, 3) =~? '\clp:'
          let g:debchangelog_complete_mode = 'lp'
        endif
        break
      endif
    endwhile
    return colidx
  else " return matches:
    let bug_lines = []
    if g:debchangelog_complete_mode ==? 'lp'
      if ! has('python')
        echoerr 'vim must be built with Python support to use LP bug completion'
        return
      endif
      let pkgsrc = DebGetPkgSrcName(line('.'))
      python << EOF
import vim
try:
    from launchpadlib.launchpad import Launchpad
    from lazr.restfulclient.errors import HTTPError
    # login anonymously
    lp = Launchpad.login_anonymously('debchangelog.vim', 'production')
    ubuntu = lp.distributions['ubuntu']
    try:
        sp = ubuntu.getSourcePackage(name=vim.eval('pkgsrc'))
        status = ('New', 'Incomplete', 'Confirmed', 'Triaged',
                  'In Progress', 'Fix Committed')
        tasklist = sp.searchTasks(status=status, order_by='id')
        liststr = '['
        for task in tasklist:
            bug = task.bug
            liststr += "'#%d - %s'," % (bug.id, bug.title.replace('\'', '\'\''))
        liststr += ']'
        vim.command('silent let bug_lines = %s' % liststr.encode('utf-8'))
    except HTTPError:
        pass
except ImportError:
    vim.command('echoerr \'python-launchpadlib >= 1.5.4 needs to be installed to use Launchpad bug completion\'')
EOF
    else
      if ! filereadable('/usr/sbin/apt-listbugs')
        echoerr 'apt-listbugs not found, you should install it to use Closes bug completion'
        return
      endif
      let pkgsrc = DebGetPkgSrcName(line('.'))
      let listbugs_output = system('/usr/sbin/apt-listbugs -s ' . g:debchangelog_listbugs_severities . ' list ' . pkgsrc . ' | grep "^ #" 2> /dev/null')
      let bug_lines = split(listbugs_output, '\n')
    endif
    let completions = []
    for line in bug_lines
      let parts = matchlist(line, '^\s*\(#\S\+\)\s*-\s*\(.*\)$')
      " filter only those which match a:base:
      if parts[1] !~ '^' . a:base
        continue
      endif
      let completion = {}
      let completion['word'] = parts[1]
      let completion['menu'] = parts[2]
      let completion['info'] = parts[0]
      let completions += [completion]
    endfor
    return completions
  endif
endfun

setlocal omnifunc=DebCompleteBugs

" }}}

" vim: set foldmethod=marker:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file (GUI menu and folding)
" Language:     Debian control files
" Maintainer:   Debian Vim Maintainers
" Former Maintainer:    Pierre Habouzit <madcoder@debian.org>
" Last Change:  2018-01-28
" URL:          https://salsa.debian.org/vim-team/vim-debian/blob/master/ftplugin/debcontrol.vim

" Do these settings once per buffer
if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin=1

" {{{1 Local settings (do on every load)
if exists('g:debcontrol_fold_enable')
  setlocal foldmethod=expr
  setlocal foldexpr=DebControlFold(v:lnum)
  setlocal foldtext=DebControlFoldText()
endif
setlocal textwidth=0

" Clean unloading
let b:undo_ftplugin = 'setlocal tw< foldmethod< foldexpr< foldtext<'

" }}}1

" {{{1 folding

function! s:getField(f, lnum)
  let line = getline(a:lnum)
  let fwdsteps = 0
  while line !~ '^'.a:f.':'
    let fwdsteps += 1
    let line = getline(a:lnum + fwdsteps)
    if line ==# ''
      return 'unknown'
    endif
  endwhile
  return substitute(line, '^'.a:f.': *', '', '')
endfunction

function! DebControlFoldText()
  if v:folddashes ==# '-'  " debcontrol entry fold
    let type = substitute(getline(v:foldstart), ':.*', '', '')
    if type ==# 'Source'
      let ftext = substitute(foldtext(), ' *Source: *', ' ', '')
      return ftext . ' -- ' . s:getField('Maintainer', v:foldstart) . ' '
    endif
    let arch  = s:getField('Architecture', v:foldstart)
    let ftext = substitute(foldtext(), ' *Package: *', ' [' . arch . '] ', '')
    return ftext . ': ' . s:getField('Description', v:foldstart) . ' '
  endif
  return foldtext()
endfunction

function! DebControlFold(l)

  " This is for not merging blank lines around folds to them
  if getline(a:l) =~# '^Source:'
    return '>1'
  endif

  if getline(a:l) =~# '^Package:'
    return '>1'
  endif

  return '='
endfunction

" }}}1
                                                                                                                                                                                                           " Vim filetype plugin file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             dict(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:             dictd(8) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim filetype plugin file
" Language:	Diff
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Nov 14

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl modeline< commentstring<"

" Don't use modelines in a diff, they apply to the diffed file
setlocal nomodeline

" If there are comments they start with #
let &l:commentstring = "# %s"

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Diff Files (*.diff)\t*.diff\nPatch Files (*.patch)\t*.h\nAll Files (*.*)\t*.*\n"
  let b:undo_ftplugin ..= " | unlet! b:browsefilter"
endif
                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:             dircolors(1) input file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	    DocBook
" Maintainer:	    Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2012-04-25

if exists('b:did_ftplugin')
  finish
endif

if !exists('b:docbk_type')
  if expand('%:e') == 'sgml'
    let b:docbk_type = 'sgml'
  else
    let b:docbk_type = 'xml'
  endif
endif

if b:docbk_type == 'sgml'
  runtime! ftplugin/sgml.vim ftplugin/sgml_*.vim ftplugin/sgml/*.vim
else
  runtime! ftplugin/xml.vim ftplugin/xml_*.vim ftplugin/xml/*.vim
endif

let b:undo_ftplugin = "unlet! b:docbk_type"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin
" Language:	Dockerfile
" Maintainer:   Honza Pokorny <http://honza.ca>
" Last Change:	2014 Aug 29

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl commentstring<"

setlocal commentstring=#\ %s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:    MS-DOS .bat files
" Maintainer:  Mike Williams <mrw@eandem.co.uk>
" Last Change: 7th May 2020

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

" BAT comment formatting
setlocal comments=b:rem,b:@rem,b:REM,b:@REM,:::
setlocal commentstring=::\ %s
setlocal formatoptions-=t formatoptions+=rol

" Lookup DOS keywords using Windows command help.
if executable('help.exe')
  if has('terminal')
    setlocal keywordprg=:term\ help.exe
  else
    setlocal keywordprg=help.exe
  endif
endif

" Define patterns for the browse file filter
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "DOS Batch Files (*.bat, *.cmd)\t*.bat;*.cmd\nAll Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal comments< formatoptions< keywordprg<"
    \ . "| unlet! b:browsefiler"

let &cpo = s:cpo_save
unlet s:cpo_save
             " Vim filetype plugin file
" Language:             Configuration File (ini file) for MS-DOS/MS Windows
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:; commentstring=;\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     [   dtd.vim \   
dtrace.vim  ]   dune.vim^   
eiffel.vim  _   
elinks.vim  `   elm.vim a   
erlang.vim  b   	eruby.vim   c   	eterm.vim   d   
falcon.vim  e   fetchmail.vim   f   flexwiki.vimg   fortran.vim h   fpcmake.vim i   framescript.vim j   freebasic.vim   k   	fstab.vim   l   fvwm.vimm   gdb.vim n   git.vim o   gitcommit.vim   p   gitconfig.vim   q   gitrebase.vim   r   gitsendemail.vims   go.vim  t   gpg.vim u   	gprof.vim   v   
groovy.vim  w   	group.vim   x   grub.vimy   haml.vimz   hamster.vim {   haskell.vim |   help.vim}   hgcommit.vim~   hog.vim    hostconf.vim   hostsaccess.vim    html.vim   htmldjango.vim     
indent.vim     
initex.vim     ishd.vim   j.vim      java.vim   javascript.vim     javascriptreact.vim    jproperties.vim    json.vim   	jsonc.vim      jsp.vim    	julia.vim       " Vim filetype plugin file
" Language:	dtd
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ \ ,e:-->

setlocal formatoptions-=t
if !exists("g:ft_dtd_autocomment") || (g:ft_dtd_autocomment == 1)
    setlocal formatoptions+=croql
endif

if exists("loaded_matchit")
    let b:match_words = '<!--:-->,<!:>'
endif

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="DTD Files (*.dtd)\t*.dtd\n" .
		\	"XML Files (*.xml)\t*.xml\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< comments< formatoptions<" .
		\     " | unlet! b:matchwords b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Language: D script as described in "Solaris Dynamic Tracing Guide",
"           http://docs.sun.com/app/docs/doc/817-6223
" Last Change: 2008/03/20
" Version: 1.2
" Maintainer: Nicolas Weber <nicolasweber@gmx.de>

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = "setl fo< com< cms< isk<"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/

" dtrace uses /* */ comments. Set this explicitly, just in case the user
" changed this (/*%s*/ is the default)
setlocal commentstring=/*%s*/

setlocal iskeyword+=@,$

" When the matchit plugin is loaded, this makes the % command skip parens and
" braces in comments.
let b:match_words = &matchpairs
let b:match_skip = 's:comment\|string\|character'

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Language:    Dune buildsystem
" Maintainer:  Markus Mottl        <markus.mottl@gmail.com>
"              Anton Kochkov       <anton.kochkov@gmail.com>
" URL:         https://github.com/ocaml/vim-ocaml
" Last Change:
"              2018 Nov 3 - Added commentstring (Markus Mottl)
"              2017 Sep 6 - Initial version (Etienne Millon)

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

set lisp

" Comment string
setl commentstring=;\ %s
setl comments=:;

setl iskeyword+=#,?,.,/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin
" Language:	Eiffel
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2010 Aug 29

if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=:--
setlocal commentstring=--\ %s

setlocal formatoptions-=t formatoptions+=croql

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Eiffel Source Files (*.e)\t*.e\n" .
		     \ "Eiffel Control Files (*.ecf, *.ace, *.xace)\t*.ecf;*.ace;*.xace\n" .
		     \ "All Files (*.*)\t*.*\n"
endif

if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0
  " Silly \%^ trick to match note at head of pair and in middle prevents
  " 'g%' wrapping from 'note' to 'end'
  let b:match_words = '\%^:' .
		  \	'\<\%(^note\|indexing\|class\|^obsolete\|inherit\|insert\|^create\|convert\|feature\|^invariant\)\>:' .
		  \   '^end\>,' .
		  \   '\<\%(do\|deferred\|external\|once\%(\s\+"\)\@!\|check\|debug\|if\|inspect\|from\|across\)\>:' .
		  \	'\%(\%(^\s\+\)\@<=\%(then\|until\|loop\)\|\%(then\|until\|loop\)\s\+[^ -]\|' .
		  \	'\<\%(ensure\%(\s\+then\)\=\|rescue\|_then\|elseif\|else\|when\|\s\@<=invariant\|_until\|_loop\|variant\|_as\|alias\)\>\):' .
		  \   '\s\@<=end\>'
  let b:match_skip = 's:\<eiffel\%(Comment\|String\|Operator\)\>'
  noremap  [% <Nop>
  noremap  ]% <Nop>
  vnoremap a% <Nop>
endif

let b:undo_ftplugin = "setl fo< com< cms<" .
  \ "| unlet! b:browsefilter b:match_ignorecase b:match_words b:match_skip"

if !exists("g:no_plugin_maps") && !exists("g:no_eiffel_maps")
  function! s:DoMotion(pattern, count, flags) abort
    normal! m'
    for i in range(a:count)
      call search(a:pattern, a:flags)
    endfor
  endfunction

  let sections = '^\%(note\|indexing\|' .
	     \	 '\%(\%(deferred\|expanded\|external\|frozen\)\s\+\)*class\|' .
	     \	 'obsolete\|inherit\|insert\|create\|convert\|feature\|' .
	     \	 'invariant\|end\)\>'

  nnoremap <silent> <buffer> ]] :<C-U>call <SID>DoMotion(sections, v:count1, 'W')<CR>
  xnoremap <silent> <buffer> ]] :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(sections, v:count1, 'W')<CR>
  nnoremap <silent> <buffer> [[ :<C-U>call <SID>DoMotion(sections, v:count1, 'Wb')<CR>
  xnoremap <silent> <buffer> [[ :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(sections, v:count1, 'Wb')<CR>

  function! s:DoFeatureMotion(count, flags)
    let view = winsaveview()
    call cursor(1, 1)
    let [features_start, _] = searchpos('^feature\>')
    call search('^\s\+\a') " find the first feature
    let spaces = indent(line('.'))
    let [features_end, _] = searchpos('^\%(invariant\|note\|end\)\>')
    call winrestview(view)
    call s:DoMotion('\%>' . features_start . 'l\%<' . features_end . 'l^\s*\%' . (spaces + 1) . 'v\zs\a', a:count, a:flags)
  endfunction

  nnoremap <silent> <buffer> ]m :<C-U>call <SID>DoFeatureMotion(v:count1, 'W')<CR>
  xnoremap <silent> <buffer> ]m :<C-U>exe "normal! gv"<Bar>call <SID>DoFeatureMotion(v:count1, 'W')<CR>
  nnoremap <silent> <buffer> [m :<C-U>call <SID>DoFeatureMotion(v:count1, 'Wb')<CR>
  xnoremap <silent> <buffer> [m :<C-U>exe "normal! gv"<Bar>call <SID>DoFeatureMotion(v:count1, 'Wb')<CR>

  let comment_block_start = '^\%(\s\+--.*\n\)\@<!\s\+--'
  let comment_block_end = '^\s\+--.*\n\%(\s\+--\)\@!'

  nnoremap <silent> <buffer> ]- :<C-U>call <SID>DoMotion(comment_block_start, 1, 'W')<CR>
  xnoremap <silent> <buffer> ]- :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(comment_block_start, 1, 'W')<CR>
  nnoremap <silent> <buffer> [- :<C-U>call <SID>DoMotion(comment_block_end, 1, 'Wb')<CR>
  xnoremap <silent> <buffer> [- :<C-U>exe "normal! gv"<Bar>call <SID>DoMotion(comment_block_end, 1, 'Wb')<CR>

  let b:undo_ftplugin = b:undo_ftplugin .
    \ "| silent! execute 'unmap <buffer> [[' | silent! execute 'unmap <buffer> ]]'" .
    \ "| silent! execute 'unmap <buffer> [m' | silent! execute 'unmap <buffer> ]m'" .
    \ "| silent! execute 'unmap <buffer> [-' | silent! execute 'unmap <buffer> ]-'"
endif

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8
        " Vim filetype plugin file
" Language:             elinks(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Elm filetype plugin file
" Language: Elm
" Maintainer: Andreas Scharf <as@99n.de>
" Latest Revision: 2020-05-29

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal comments=s1fl:{-,mb:\ ,ex:-},:--
setlocal commentstring=--\ %s

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim ftplugin file
" Language:     Erlang (http://www.erlang.org)
" Maintainer:   Csaba Hoch <csaba.hoch@gmail.com>
" Author:       Oscar Hellstrm <oscar@oscarh.net>
" Contributors: Ricardo Catalinas Jimnez <jimenezrick@gmail.com>
"               Eduardo Lopez (http://github.com/tapichu)
"               Arvid Bjurklint (http://github.com/slarwise)
" Last Update:  2021-Jan-08
" License:      Vim license
" URL:          https://github.com/vim-erlang/vim-erlang-runtime

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let &l:keywordprg = get(g:, 'erlang_keywordprg', 'erl -man')

if get(g:, 'erlang_folding', 0)
  setlocal foldmethod=expr
  setlocal foldexpr=GetErlangFold(v:lnum)
  setlocal foldtext=ErlangFoldText()
endif

setlocal comments=:%%%,:%%,:%
setlocal commentstring=%%s

setlocal formatoptions+=ro

setlocal suffixesadd=.erl,.hrl

let &l:include = '^\s*-\%(include\|include_lib\)\s*("\zs\f*\ze")'
let &l:define  = '^\s*-\%(define\|record\|type\|opaque\)'

let s:erlang_fun_begin = '^\a\w*(.*$'
let s:erlang_fun_end   = '^[^%]*\.\s*\(%.*\)\?$'

if !exists('*GetErlangFold')
  function GetErlangFold(lnum)
    let lnum = a:lnum
    let line = getline(lnum)

    if line =~ s:erlang_fun_end
      return '<1'
    endif

    if line =~ s:erlang_fun_begin && foldlevel(lnum - 1) == 1
      return '1'
    endif

    if line =~ s:erlang_fun_begin
      return '>1'
    endif

    return '='
  endfunction
endif

if !exists('*ErlangFoldText')
  function ErlangFoldText()
    let line    = getline(v:foldstart)
    let foldlen = v:foldend - v:foldstart + 1
    let lines   = ' ' . foldlen . ' lines: ' . substitute(line, "[\ \t]*", '', '')
    if foldlen < 10
      let lines = ' ' . lines
    endif
    let retval = '+' . v:folddashes . lines

    return retval
  endfunction
endif

let b:undo_ftplugin = "setlocal keywordprg< foldmethod< foldexpr< foldtext<"
      \ . " comments< commentstring< formatoptions< suffixesadd< include<"
      \ . " define<"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: sw=2 et
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim filetype plugin
" Language:		eRuby
" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
" URL:			https://github.com/vim-ruby/vim-ruby
" Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
" Last Change:		2020 Jun 28

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "All Files (*.*)\t*.*\n"
let s:match_words = ""

if !exists("g:eruby_default_subtype")
  let g:eruby_default_subtype = "html"
endif

if &filetype =~ '^eruby\.'
  let b:eruby_subtype = matchstr(&filetype,'^eruby\.\zs\w\+')
elseif !exists("b:eruby_subtype")
  let s:lines = getline(1)."\n".getline(2)."\n".getline(3)."\n".getline(4)."\n".getline(5)."\n".getline("$")
  let b:eruby_subtype = matchstr(s:lines,'eruby_subtype=\zs\w\+')
  if b:eruby_subtype == ''
    let b:eruby_subtype = matchstr(substitute(expand("%:t"),'\c\%(\.erb\|\.eruby\|\.erubis\|\.example\)\+$','',''),'\.\zs\w\+\%(\ze+\w\+\)\=$')
  endif
  if b:eruby_subtype == 'rhtml'
    let b:eruby_subtype = 'html'
  elseif b:eruby_subtype == 'rb'
    let b:eruby_subtype = 'ruby'
  elseif b:eruby_subtype == 'yml'
    let b:eruby_subtype = 'yaml'
  elseif b:eruby_subtype == 'js'
    let b:eruby_subtype = 'javascript'
  elseif b:eruby_subtype == 'txt'
    " Conventional; not a real file type
    let b:eruby_subtype = 'text'
  elseif b:eruby_subtype == ''
    let b:eruby_subtype = g:eruby_default_subtype
  endif
endif

if exists("b:eruby_subtype") && b:eruby_subtype != '' && b:eruby_subtype !=? 'eruby'
  exe "runtime! ftplugin/".b:eruby_subtype.".vim ftplugin/".b:eruby_subtype."_*.vim ftplugin/".b:eruby_subtype."/*.vim"
else
  runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
endif
unlet! b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin
  unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
  let s:browsefilter = b:browsefilter
  unlet b:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words
  unlet b:match_words
endif

let s:cfilemap = v:version >= 704 ? maparg('<Plug><cfile>', 'c', 0, 1) : {}
if !get(s:cfilemap, 'buffer') || !s:cfilemap.expr || s:cfilemap.rhs =~# 'ErubyAtCursor()'
  let s:cfilemap = {}
endif
if !has_key(s:cfilemap, 'rhs')
  let s:cfilemap.rhs = "substitute(&l:inex =~# '\\<v:fname\\>' && len(expand('<cfile>')) ? eval(substitute(&l:inex, '\\<v:fname\\>', '\\=string(expand(\"<cfile>\"))', 'g')) : '', '^$', \"\\022\\006\",'')"
endif
let s:ctagmap = v:version >= 704 ? maparg('<Plug><ctag>', 'c', 0, 1) : {}
if !get(s:ctagmap, 'buffer') || !s:ctagmap.expr || s:ctagmap.rhs =~# 'ErubyAtCursor()'
  let s:ctagmap = {}
endif
let s:include = &l:include
let s:path = &l:path
let s:suffixesadd = &l:suffixesadd

runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words . ',' . s:match_words
endif

if len(s:include)
  let &l:include = s:include
endif
let &l:path = s:path . (s:path =~# ',$\|^$' ? '' : ',') . &l:path
let &l:suffixesadd = s:suffixesadd . (s:suffixesadd =~# ',$\|^$' ? '' : ',') . &l:suffixesadd
exe 'cmap <buffer><script><expr> <Plug><cfile> ErubyAtCursor() ? ' . maparg('<Plug><cfile>', 'c') . ' : ' . s:cfilemap.rhs
exe 'cmap <buffer><script><expr> <Plug><ctag> ErubyAtCursor() ? ' . maparg('<Plug><ctag>', 'c') . ' : ' . get(s:ctagmap, 'rhs', '"\022\027"')
unlet s:cfilemap s:ctagmap s:include s:path s:suffixesadd

" Change the browse dialog on Win32 to show mainly eRuby-related files
if has("gui_win32")
  let b:browsefilter="eRuby Files (*.erb, *.rhtml)\t*.erb;*.rhtml\n" . s:browsefilter
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
  let b:match_words = s:match_words
endif

" TODO: comments=
setlocal commentstring=<%#%s%>

let b:undo_ftplugin = "setl cms< " .
      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

let &cpo = s:save_cpo
unlet s:save_cpo

function! ErubyAtCursor() abort
  let groups = map(['erubyBlock', 'erubyComment', 'erubyExpression', 'erubyOneLiner'], 'hlID(v:val)')
  return !empty(filter(synstack(line('.'), col('.')), 'index(groups, v:val) >= 0'))
endfunction

" vim: nowrap sw=2 sts=2 ts=8:
                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:             eterm(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=:# commentstring=#\ %s include=^\\s*include
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:     Falcon
" Author:       Steven Oliver <oliver.steven@gmail.com>
" Copyright:    Copyright (c) 2009-2013 Steven Oliver
" License:      You may redistribute this under the same terms as Vim itself
" Last Update:  2020 Oct 10
" --------------------------------------------------------------------------

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

setlocal softtabstop=4 shiftwidth=4
setlocal suffixesadd=.fal,.ftd

" Matchit support
if exists("loaded_matchit") && !exists("b:match_words")
  let b:match_ignorecase = 0

  let b:match_words =
	\ '\<\%(if\|case\|while\|until\|for\|do\|class\)\>=\@!' .
	\ ':' .
	\ '\<\%(else\|elsif\|when\)\>' .
	\ ':' .
	\ '\<end\>' .
	\ ',{:},\[:\],(:)'
endif

setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Windows allows you to filter the open file dialog
if has("gui_win32") && !exists("b:browsefilter")
  let b:browsefilter = "Falcon Source Files (*.fal *.ftd)\t*.fal;*.ftd\n" .
                     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setlocal tabstop< shiftwidth< expandtab< fileencoding<"
	\ . " suffixesadd< comments<"
	\ . "| unlet! b:browsefiler"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 sts=4 et tw=80 :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:             fetchmail(1) RC File
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:     FlexWiki, http://www.flexwiki.com/
" Maintainer:   George V. Reilly  <george@reilly.org>
" Home:         http://www.georgevreilly.com/vim/flexwiki/
" Other Home:   http://www.vim.org/scripts/script.php?script_id=1529
" Author:       George V. Reilly
" Filenames:    *.wiki
" Last Change: Wed Apr 26 11:00 PM 2006 P
" Version:      0.3

if exists("b:did_ftplugin")
  finish
endif

let b:did_ftplugin = 1  " Don't load another plugin for this buffer

" Reset the following options to undo this plugin.
let b:undo_ftplugin = "setl tw< wrap< lbr< et< ts< fenc< bomb< ff<"

" Allow lines of unlimited length. Do NOT want automatic linebreaks,
" as a newline starts a new paragraph in FlexWiki.
setlocal textwidth=0
" Wrap long lines, rather than using horizontal scrolling.
setlocal wrap
" Wrap at a character in 'breakat' rather than at last char on screen
setlocal linebreak
" Don't transform <TAB> characters into spaces, as they are significant
" at the beginning of the line for numbered and bulleted lists.
setlocal noexpandtab
" 4-char tabstops, per flexwiki.el
setlocal tabstop=4
" Save *.wiki files in UTF-8
setlocal fileencoding=utf-8
" Add the UTF-8 Byte Order Mark to the beginning of the file
setlocal bomb
" Save <EOL>s as \n, not \r\n
setlocal fileformat=unix

if exists("g:flexwiki_maps")
  " Move up and down by display lines, to account for screen wrapping
  " of very long lines
  nmap <buffer> <Up>   gk
  nmap <buffer> k      gk
  vmap <buffer> <Up>   gk
  vmap <buffer> k      gk

  nmap <buffer> <Down> gj
  nmap <buffer> j      gj
  vmap <buffer> <Down> gj
  vmap <buffer> j      gj

  " for earlier versions - for when 'wrap' is set
  imap <buffer> <S-Down>   <C-o>gj
  imap <buffer> <S-Up>     <C-o>gk
  if v:version >= 700
      imap <buffer> <Down>   <C-o>gj
      imap <buffer> <Up>     <C-o>gk
  endif
endif
                                                                                                                                                                            " Vim settings file
" Language:	Fortran 2008 (and older: Fortran 2003, 95, 90, 77, 66)
" Version:	(v53) 2021 April 06
" Maintainer:	Ajit J. Thakkar <ajit@unb.ca>; <http://www2.unb.ca/~ajit/>
" Usage:	For instructions, do :help fortran-plugin from Vim
" Credits:
"  Version 0.1 was created in September 2000 by Ajit Thakkar.
"  Since then, useful suggestions and contributions have been made, in order, by:
"  Stefano Zacchiroli, Hendrik Merx, Ben Fritz, David Barnett, Eisuke Kawashima,
"  Doug Kearns, and Fritz Reese.

" Only do these settings when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:cposet=&cpoptions
set cpoptions&vim

" Don't do other file type settings for this buffer
let b:did_ftplugin = 1

" Determine whether this is a fixed or free format source file
" if this hasn't been done yet using the priority:
" buffer-local value
" > global value
" > file extension as in Intel ifort, gcc (gfortran), NAG, Pathscale, and Cray compilers
if !exists("b:fortran_fixed_source")
  if exists("fortran_free_source")
    " User guarantees free source form
    let b:fortran_fixed_source = 0
  elseif exists("fortran_fixed_source")
    " User guarantees fixed source form
    let b:fortran_fixed_source = 1
  elseif expand("%:e") =~? '^f\%(90\|95\|03\|08\)$'
    " Free-form file extension defaults as in Intel ifort, gcc(gfortran), NAG, Pathscale, and Cray compilers
    let b:fortran_fixed_source = 0
  elseif expand("%:e") =~? '^\%(f\|f77\|for\)$'
    " Fixed-form file extension defaults
    let b:fortran_fixed_source = 1
  else
    " Modern fortran still allows both fixed and free source form
    " Assume fixed source form unless signs of free source form
    " are detected in the first five columns of the first s:lmax lines.
    " Detection becomes more accurate and time-consuming if more lines
    " are checked. Increase the limit below if you keep lots of comments at
    " the very top of each file and you have a fast computer.
    let s:lmax = 500
    if ( s:lmax > line("$") )
      let s:lmax = line("$")
    endif
    let b:fortran_fixed_source = 1
    let s:ln=1
    while s:ln <= s:lmax
      let s:test = strpart(getline(s:ln),0,5)
      if s:test !~ '^[Cc*]' && s:test !~ '^ *[!#]' && s:test =~ '[^ 0-9\t]' && s:test !~ '^[ 0-9]*\t'
	let b:fortran_fixed_source = 0
	break
      endif
      let s:ln = s:ln + 1
    endwhile
    unlet! s:lmax s:ln s:test
  endif
endif

" Set comments and textwidth according to source type
if (b:fortran_fixed_source == 1)
  setlocal comments=:!,:*,:C
  " Fixed format requires a textwidth of 72 for code,
  " but some vendor extensions allow longer lines
  if exists("fortran_extended_line_length")
    setlocal tw=132
  elseif exists("fortran_cardimage_line_length")
    setlocal tw=80
  else
    setlocal tw=72
  " If you need to add "&" on continued lines so that the code is
  " compatible with both free and fixed format, then you should do so
  " in column 73 and uncomment the next line
  " setlocal tw=73
  endif
else
  setlocal comments=:!
  " Free format allows a textwidth of 132
  setlocal tw=132
endif

" Set commentstring for foldmethod=marker
setlocal cms=!%s

" Tabs are not a good idea in Fortran so the default is to expand tabs
if !exists("fortran_have_tabs")
  setlocal expandtab
endif

" Set 'formatoptions' to break text lines
setlocal fo+=t

setlocal include=^\\c#\\=\\s*include\\s\\+
setlocal suffixesadd+=.f08,.f03,.f95,.f90,.for,.f,.F,.f77,.ftn,.fpp

" Define patterns for the matchit plugin
if !exists("b:match_words")
  let s:notend = '\%(\<end\s\+\)\@<!'
  let s:notselect = '\%(\<select\s\+\)\@<!'
  let s:notelse = '\%(\<end\s\+\|\<else\s\+\)\@<!'
  let s:notprocedure = '\%(\s\+procedure\>\)\@!'
  let b:match_ignorecase = 1
  let b:match_words =
    \ '(:),' .
    \ '\<select\s*case\>:' . s:notselect. '\<case\>:\<end\s*select\>,' .
    \ s:notelse . '\<if\s*(.\+)\s*then\>:' .
    \ '\<else\s*\%(if\s*(.\+)\s*then\)\=\>:\<end\s*if\>,'.
    \ 'do\s\+\(\d\+\):\%(^\s*\)\@<=\1\s,'.
    \ s:notend . '\<do\>:\<end\s*do\>,'.
    \ s:notelse . '\<where\>:\<elsewhere\>:\<end\s*where\>,'.
    \ s:notend . '\<type\s*[^(]:\<end\s*type\>,'.
    \ s:notend . '\<forall\>:\<end\s*forall\>,'.
    \ s:notend . '\<associate\>:\<end\s*associate\>,'.
    \ s:notend . '\<enum\>:\<end\s*enum\>,'.
    \ s:notend . '\<interface\>:\<end\s*interface\>,'.
    \ s:notend . '\<subroutine\>:\<end\s*subroutine\>,'.
    \ s:notend . '\<function\>:\<end\s*function\>,'.
    \ s:notend . '\<module\>' . s:notprocedure . ':\<end\s*module\>,'.
    \ s:notend . '\<program\>:\<end\s*program\>'
endif

" File filters for :browse e
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Fortran Files (*.f;*.for;*.f77;*.f90;*.f95;*.f03;*.f08;*.fpp;*.ftn)\t*.f;*.for;*.f77;*.f90;*.f95;*.f03;*.f08;*.fpp;*.ftn\n" .
    \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = "setl fo< com< tw< cms< et< inc< sua<"
	\ . "| unlet! b:match_ignorecase b:match_words b:browsefilter"

let &cpoptions=s:cposet
unlet s:cposet

" vim:sw=2
                                                     " Vim filetype plugin file
" Language:	Free Pascal Makefile Generator
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2021 Apr 23

if exists("b:did_ftplugin")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

runtime! ftplugin/make.vim

if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
  let b:browsefilter = "Free Pascal Makefile Definition Files (*.fpc)\t*.fpc\n" ..
		     \ "All Files (*.*)\t*.*\n"
endif

let b:undo_ftplugin = b:undo_ftplugin .. " | unlet! b:browsefilter"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: nowrap sw=2 sts=2 ts=8 noet:
                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim ftplugin file
" Language:             FrameScript
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-19

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo< inc< | unlet! b:matchwords"

setlocal comments=s1:/*,mb:*,ex:*/,:// commentstring=/*\ %s\ */
setlocal formatoptions-=t formatoptions+=croql
setlocal include=^\\s*<#Include

if exists("loaded_matchit")
  let s:not_end = '\c\%(\<End\)\@<!'
  let b:match_words =
        \ s:not_end . '\<If\>:\c\<ElseIf\>:\c\<Else\>:\c\<EndIf\>,' .
        \ s:not_end . '\<Loop\>:\c\<EndLoop\>' .
        \ s:not_end . '\<Sub\>:\c\<EndSub\>'
  unlet s:not_end
endif

let &cpo = s:cpo_save 
unlet s:cpo_save
                                                                                                                                                                                                                                                    " Vim filetype plugin file
" Language:	FreeBasic
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2015 Jan 10

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

runtime! ftplugin/basic.vim

" vim: ts=8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim ftplugin file
" Language: fstab file
" Maintainer: Radu Dineiu <radu.dineiu@gmail.com>
" URL: https://raw.github.com/rid9/vim-fstab/master/ftplugin/fstab.vim
" Last Change: 2021 Jan 02
" Version: 1.0
"
" Credits:
"   Subhaditya Nath <sn03.general@gmail.com>

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

setlocal commentstring=#%s
let b:undo_ftplugin = "setlocal commentstring<"

" vim: ts=8 ft=vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Created	: Tue 09 May 2006 02:07:31 PM CDT
" Modified	: Tue 09 May 2006 02:07:31 PM CDT
" Author	: Gautam Iyer <gi1242@users.sourceforge.net>
" Description	: ftplugin for fvwm config files

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s
setlocal formatoptions-=t formatoptions+=croql
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:	gdb
" Maintainer:	Michal Peeters <NOSPAMm.vim@noekeon.org>
" Last Changed: 26 Oct 2017

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

setlocal commentstring=#%s

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal cms<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin
" Language:	generic git output
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

if !exists('b:git_dir')
  if expand('%:p') =~# '[\/]\.git[\/]modules[\/]\|:[\/][\/]\|^\a\a\+:'
    " Stay out of the way
  elseif expand('%:p') =~# '[\/]\.git[\/]worktrees'
    let b:git_dir = matchstr(expand('%:p'),'.*\.git[\/]worktrees[\/][^\/]\+\>')
  elseif expand('%:p') =~# '\.git\>'
    let b:git_dir = matchstr(expand('%:p'),'.*\.git\>')
  elseif $GIT_DIR != ''
    let b:git_dir = $GIT_DIR
  endif
  if (has('win32') || has('win64')) && exists('b:git_dir')
    let b:git_dir = substitute(b:git_dir,'\\','/','g')
  endif
endif

if exists('*shellescape') && exists('b:git_dir') && b:git_dir != ''
  if b:git_dir =~# '/\.git$' " Not a bare repository
    let &l:path = escape(fnamemodify(b:git_dir,':h'),'\, ').','.&l:path
  endif
  let &l:path = escape(b:git_dir,'\, ').','.&l:path
  let &l:keywordprg = 'git --git-dir='.shellescape(b:git_dir).' show'
else
  setlocal keywordprg=git\ show
endif
if has('gui_running')
  let &l:keywordprg = substitute(&l:keywordprg,'^git\>','git --no-pager','')
endif

setlocal includeexpr=substitute(v:fname,'^[^/]\\+/','','')
let b:undo_ftplugin = "setl keywordprg< path< includeexpr<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin
" Language:	git commit file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif

runtime! ftplugin/git.vim
let b:did_ftplugin = 1

setlocal comments=:# commentstring=#\ %s
setlocal nomodeline tabstop=8 formatoptions+=tl textwidth=72
setlocal formatoptions-=c formatoptions-=r formatoptions-=o formatoptions-=q formatoptions+=n
setlocal formatlistpat+=\\\|^\\s*[-*+]\\s\\+

let b:undo_ftplugin = 'setl modeline< tabstop< formatoptions< tw< com< cms< formatlistpat<'

if exists("g:no_gitcommit_commands") || v:version < 700
  finish
endif

if !exists("b:git_dir")
  let b:git_dir = expand("%:p:h")
endif

command! -bang -bar -buffer -complete=custom,s:diffcomplete -nargs=* DiffGitCached :call s:gitdiffcached(<bang>0,b:git_dir,<f-args>)

let b:undo_ftplugin = b:undo_ftplugin . "|delc DiffGitCached"

function! s:diffcomplete(A,L,P)
  let args = ""
  if a:P <= match(a:L." -- "," -- ")+3
    let args = args . "-p\n--stat\n--shortstat\n--summary\n--patch-with-stat\n--no-renames\n-B\n-M\n-C\n"
  end
  if exists("b:git_dir") && a:A !~ '^-'
    let tree = fnamemodify(b:git_dir,':h')
    if strpart(getcwd(),0,strlen(tree)) == tree
      let args = args."\n".system("git diff --cached --name-only")
    endif
  endif
  return args
endfunction

function! s:gitdiffcached(bang,gitdir,...)
  let tree = fnamemodify(a:gitdir,':h')
  let name = tempname()
  let git = "git"
  if strpart(getcwd(),0,strlen(tree)) != tree
    let git .= " --git-dir=".(exists("*shellescape") ? shellescape(a:gitdir) : '"'.a:gitdir.'"')
  endif
  if a:0
    let extra = join(map(copy(a:000),exists("*shellescape") ? 'shellescape(v:val)' : "'\"'.v:val.'\"'"))
  else
    let extra = "-p --stat=".&columns
  endif
  call system(git." diff --cached --no-color --no-ext-diff ".extra." > ".(exists("*shellescape") ? shellescape(name) : name))
  exe "pedit ".(exists("*fnameescape") ? fnameescape(name) : name)
  wincmd P
  let b:git_dir = a:gitdir
  command! -bang -bar -buffer -complete=custom,s:diffcomplete -nargs=* DiffGitCached :call s:gitdiffcached(<bang>0,b:git_dir,<f-args>)
  nnoremap <buffer> <silent> q :q<CR>
  setlocal buftype=nowrite nobuflisted noswapfile nomodifiable filetype=git
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim filetype plugin
" Language:	git config file
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2009 Dec 24

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t formatoptions+=croql
setlocal comments=:#,:; commentstring=;\ %s

let b:undo_ftplugin = "setl fo< com< cms<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin
" Language:	git rebase --interactive
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if (exists("b:did_ftplugin"))
  finish
endif

runtime! ftplugin/git.vim
let b:did_ftplugin = 1

setlocal comments=:# commentstring=#\ %s formatoptions-=t
setlocal nomodeline
if !exists("b:undo_ftplugin")
  let b:undo_ftplugin = ""
endif
let b:undo_ftplugin = b:undo_ftplugin."|setl com< cms< fo< ml<"

function! s:choose(word) abort
  s/^\(\w\+\>\)\=\(\s*\)\ze\x\{4,40\}\>/\=(strlen(submatch(1)) == 1 ? a:word[0] : a:word) . substitute(submatch(2),'^$',' ','')/e
endfunction

function! s:cycle(count) abort
  let words = ['pick', 'edit', 'fixup', 'squash', 'reword', 'drop']
  let index = index(map(copy(words), 'v:val[0]'), getline('.')[0])
  let index = ((index < 0 ? 0 : index) + 10000 * len(words) + a:count) % len(words)
  call s:choose(words[index])
endfunction

command! -buffer -bar -range Pick   :<line1>,<line2>call s:choose('pick')
command! -buffer -bar -range Squash :<line1>,<line2>call s:choose('squash')
command! -buffer -bar -range Edit   :<line1>,<line2>call s:choose('edit')
command! -buffer -bar -range Reword :<line1>,<line2>call s:choose('reword')
command! -buffer -bar -range Fixup  :<line1>,<line2>call s:choose('fixup')
command! -buffer -bar -range Drop   :<line1>,<line2>call s:choose('drop')
command! -buffer -count=1 -bar -bang Cycle call s:cycle(<bang>0 ? -<count> : <count>)

if exists("g:no_plugin_maps") || exists("g:no_gitrebase_maps")
  finish
endif

nnoremap <buffer> <expr> K col('.') < 7 && expand('<Lt>cword>') =~ '\X' && getline('.') =~ '^\w\+\s\+\x\+\>' ? 'wK' : 'K'
nnoremap <buffer> <silent> <C-A> :<C-U><C-R>=v:count1<CR>Cycle<CR>
nnoremap <buffer> <silent> <C-X> :<C-U><C-R>=v:count1<CR>Cycle!<CR>

let b:undo_ftplugin = b:undo_ftplugin . "|exe 'nunmap <buffer> K'|exe 'nunmap <buffer> <C-A>'|exe 'nunmap <buffer> <C-X>'"
                                                                                                      " Vim filetype plugin
" Language:	git send-email message
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2009 Dec 24

runtime! ftplugin/mail.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	Go
" Maintainer:	David Barnett (https://github.com/google/vim-ft-go)
" Last Change:	2014 Aug 16

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t

setlocal comments=s1:/*,mb:*,ex:*/,://
setlocal commentstring=//\ %s

let b:undo_ftplugin = 'setl fo< com< cms<'

" vim: sw=2 sts=2 et
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:             gpg(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Language:     gprof
" Maintainer:   Dominique Pelle <dominique.pelle@gmail.com>
" Contributors: Doug Kearns <dougkearns@gmail.com>
" Last Change:  2021 Sep 19

" When cursor is on one line of the gprof call graph,
" calling this function jumps to this function in the call graph.
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin=1

func! <SID>GprofJumpToFunctionIndex()
  let l:line = getline('.')
  if l:line =~ '[\d\+\]$'
    " We're in a line in the call graph.
    norm! $y%
    call search('^' . escape(@", '[]'), 'sw')
    norm! zz
  elseif l:line =~ '^\(\s*[0-9\.]\+\)\{3}\s\+'
    " We're in line in the flat profile.
    norm! 55|eby$
    call search('^\[\d\+\].*\d\s\+' .  escape(@", '[]*.') . '\>', 'sW')
    norm! zz
  endif
endfunc

if !exists("no_plugin_maps") && !exists("no_gprof_maps")
  " Pressing <C-]> on a line in the gprof flat profile or in
  " the call graph, jumps to the corresponding function inside
  " the flat profile.
  map <buffer> <silent> <C-]> :call <SID>GprofJumpToFunctionIndex()<CR>
  let b:undo_ftplugin = "silent! unmap <buffer> <C-]>"
endif

" vim:sw=2 fdm=indent
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin file
" Language:	groovy
" Maintainer:	Justin M. Keyes <justinkz@gmail.com>
" Last Change:	2016 May 22

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

let b:undo_ftplugin = 'setlocal commentstring<'

setlocal commentstring=//%s

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:             group(5) user group file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments= commentstring= formatoptions-=tcroq formatoptions+=l

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:             grub(8) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin
" Language:	Haml
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2019 Dec 05

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
unlet! b:did_ftplugin
set matchpairs-=<:>

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin
  unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
  let s:browsefilter = b:browsefilter
  unlet b:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words
  unlet b:match_words
endif

runtime! ftplugin/ruby.vim ftplugin/ruby_*.vim ftplugin/ruby/*.vim
let b:did_ftplugin = 1

let &l:define .= empty(&l:define ? '' : '\|') . '^\s*\%(%\w*\)\=\%(\.[[:alnum:]_-]\+\)*#'

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
  let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
  let s:browsefilter = substitute(b:browsefilter,'\cAll Files (\*\.\*)\t\*\.\*\n','','') . s:browsefilter
endif
if exists("b:match_words")
  let s:match_words = b:match_words . ',' . s:match_words
endif

" Change the browse dialog on Win32 to show mainly Haml-related files
if has("gui_win32")
  let b:browsefilter="Haml Files (*.haml)\t*.haml\nSass Files (*.sass)\t*.sass\n" . s:browsefilter
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
  let b:match_words = s:match_words
endif

setlocal comments= commentstring=-#\ %s

let b:undo_ftplugin = "setl def< cms< com< "
      \ " | unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:set sw=2:
                                                                 " Vim filetype plugin
" Language:    Hamster Script
" Version:     2.0.6.0
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Last Change: 2021 Jan 19

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl fo< com< tw< commentstring<"
	\ . "| unlet! b:match_ignorecase b:match_words b:match_skip"

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal fo-=t fo+=croql

" Use the # sign for comments
setlocal comments=:#

" Format comments to be up to 78 characters long
if &tw == 0
  setlocal tw=78
endif

" Comments start with a double quote
setlocal commentstring=#%s

" Move around functions.
noremap <silent><buffer> [[ :call search('^\s*sub\>', "bW")<CR>
noremap <silent><buffer> ]] :call search('^\s*sub\>', "W")<CR>
noremap <silent><buffer> [] :call search('^\s*endsub\>', "bW")<CR>
noremap <silent><buffer> ][ :call search('^\s*endsub\>', "W")<CR>

" Move around comments
noremap <silent><buffer> ]# :call search('^\s*#\@!', "W")<CR>
noremap <silent><buffer> [# :call search('^\s*#\@!', "bW")<CR>

" Let the matchit plugin know what items can be matched.
if exists("loaded_matchit")
  let b:match_ignorecase = 0
  let b:match_words =
	\ '\<sub\>:\<return\>:\<endsub\>,' .
        \ '\<do\|while\|repeat\|for\>:\<break\>:\<continue\>:\<loop\|endwhile\|until\|endfor\>,' .
	\ '\<if\>:\<else\%[if]\>:\<endif\>' 

  " Ignore ":syntax region" commands, the 'end' argument clobbers if-endif
  " let b:match_skip = 'getline(".") =~ "^\\s*sy\\%[ntax]\\s\\+region" ||
  "	\ synIDattr(synID(line("."),col("."),1),"name") =~? "comment\\|string"'
endif

setlocal ignorecase

let &cpo = s:cpo_save
unlet s:cpo_save

" Disabled, 'cpo' is a global option.
" setlocal cpo+=M		" makes \%( match \)
                                                                                      " Vim filetype plugin file
" Language:             Haskell
" Maintainer:           Daniel Campoverde <alx@sillybytes.net>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2018-08-27

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1fl:{-,mb:-,ex:-},:-- commentstring=--\ %s
setlocal formatoptions-=t formatoptions+=croql
setlocal omnifunc=haskellcomplete#Complete

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:             Vim help file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2018-12-29

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl fo< tw< cole< cocu< keywordprg<"

setlocal formatoptions+=tcroql textwidth=78 keywordprg=:help
if has("conceal")
  setlocal cole=2 cocu=nc
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim filetype plugin file
" Language:	hg (Mercurial) commit file
" Maintainer:	Ken Takata <kentkt at csc dot jp>
" Last Change:	2016 Jan 6
" Filenames:	hg-editor-*.txt
" License:	VIM License
" URL:		https://github.com/k-takata/hg-vim

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

setlocal nomodeline

let b:undo_ftplugin = 'setl modeline<'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin
" Language:     hog (snort.conf)
" Maintainer: . Victor Roemer, <vroemer@badsec.org>.
" Last Change:  Mar 1, 2013

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:undo_ftplugin = "setl fo< com< cms< def< inc<"

let s:cpo_save = &cpo
set cpo&vim

setlocal formatoptions=croq
setlocal comments=:#
setlocal commentstring=\c#\ %s
setlocal define=\c^\s\{-}var
setlocal include=\c^\s\{-}include

" Move around configurations 
let s:hog_keyword_match = '\c^\s*\<\(preprocessor\\|config\\|output\\|include\\|ipvar\\|portvar\\|var\\|dynamicpreprocessor\\|' . 
                        \ 'dynamicengine\\|dynamicdetection\\|activate\\|alert\\|drop\\|block\\|dynamic\\|log\\|pass\\|reject\\|sdrop\\|sblock\)\>'

exec "nnoremap <buffer><silent> ]] :call search('" . s:hog_keyword_match . "', 'W' )<CR>"
exec "nnoremap <buffer><silent> [[ :call search('" . s:hog_keyword_match . "', 'bW' )<CR>"

if exists("loaded_matchit")
    let b:match_words =
                  \ '^\s*\<\%(preprocessor\|config\|output\|include\|ipvar\|portvar' . 
                  \ '\|var\|dynamicpreprocessor\|dynamicengine\|dynamicdetection' . 
                  \ '\|activate\|alert\|drop\|block\|dynamic\|log\|pass\|reject' . 
                  \ '\|sdrop\|sblock\>\):$,\::\,:;'
    let b:match_skip = 'r:\\.\{-}$\|^\s*#.\{-}$\|^\s*$'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2007-12-04

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:             hosts_access(5) control file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin file
" Language:	html
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

setlocal matchpairs+=<:>
setlocal commentstring=<!--%s-->
setlocal comments=s:<!--,m:\ \ \ \ ,e:-->

if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
    setlocal formatoptions-=t formatoptions+=croql
endif

if exists('&omnifunc')
  setlocal omnifunc=htmlcomplete#CompleteTags
  call htmlcomplete#DetectOmniFlavor()
endif

" HTML:  thanks to Johannes Zellner and Benji Fisher.
if exists("loaded_matchit")
    let b:match_ignorecase = 1
    let b:match_words = '<:>,' .
    \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
    \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
    \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
endif

" Change the :browse e filter to primarily show HTML-related files.
if has("gui_win32")
    let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
		\	"JavaScript Files (*.js)\t*.js\n" .
		\	"Cascading StyleSheets (*.css)\t*.css\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
    \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim filetype plugin file
" Language:	Django HTML template
" Maintainer:	Dave Hodder <dmh@dmh.org.uk>
" Last Change:	2007 Jan 25

" Only use this filetype plugin when no other was loaded.
if exists("b:did_ftplugin")
  finish
endif

" Use HTML and Django template ftplugins.
runtime! ftplugin/html.vim
runtime! ftplugin/django.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim filetype plugin file
" Language:		indent(1) configuration file
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Nikolai Weibull <now@bitwi.se>
" Latest Revision:	2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring&
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " filetype plugin for TeX and variants
" Language:     TeX (ft=initex)
" Maintainer:   Benji Fisher, Ph.D. <benji@member.AMS.org>
" Version:	1.0
" Last Change:	Wed 19 Apr 2006

" Only do this when not done yet for this buffer.
if exists("b:did_ftplugin")
  finish
endif

" Don't load another plugin for this buffer.
let b:did_ftplugin = 1

" Avoid problems if running in 'compatible' mode.
let s:save_cpo = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< define< include< sua<"

" Set 'comments' to format dashed lists in comments
setlocal com=sO:%\ -,mO:%\ \ ,eO:%%,:%

" Set 'commentstring' to recognize the % comment character:
" (Thanks to Ajit Thakkar.)
setlocal cms=%%s

" Allow "[d" to be used to find a macro definition:
let &l:define='\\\([egx]\|char\|mathchar\|count\|dimen\|muskip\|skip\|toks\)\='
	\ .	'def\|\\font\|\\\(future\)\=let'

" Tell Vim to recognize \input bar :
let &l:include = '\\input'
setlocal suffixesadd=.tex

let &cpo = s:save_cpo
unlet s:save_cpo

" vim:sts=2:sw=2:
                   " Vim filetype plugin file
" Language:	InstallShield (ft=ishd)
" Maintainer:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Sat, 24 May 2003 11:55:36 CEST

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

setlocal foldmethod=syntax

" Using line continuation here.
let s:cpo_save = &cpo
set cpo-=C

" matchit support
if exists("loaded_matchit")
    let b:match_ignorecase=0
    let b:match_words=
    \ '\%(^\s*\)\@<=\<function\>\s\+[^()]\+\s*(:\%(^\s*\)\@<=\<begin\>\s*$:\%(^\s*\)\@<=\<return\>:\%(^\s*\)\@<=\<end\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<repeat\>\s*$:\%(^\s*\)\@<=\<until\>\s\+.\{-}\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<switch\>\s*(.\{-}):\%(^\s*\)\@<=\<\%(case\|default\)\>:\%(^\s*\)\@<=\<endswitch\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<while\>\s*(.\{-}):\%(^\s*\)\@<=\<endwhile\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<for\>.\{-}\<\%(to\|downto\)\>:\%(^\s*\)\@<=\<endfor\>\s*;\s*$,' .
    \ '\%(^\s*\)\@<=\<if\>\s*(.\{-})\s*then:\%(^\s*\)\@<=\<else\s*if\>\s*([^)]*)\s*then:\%(^\s*\)\@<=\<else\>:\%(^\s*\)\@<=\<endif\>\s*;\s*$'
endif

if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "InstallShield Files (*.rul)\t*.rul\n" .
		       \ "All Files (*.*)\t*.*\n"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Vim filetype plugin
" Language:	J
" Maintainer:	David Brgin <dbuergin@gluet.ch>
" URL:		https://gitlab.com/glts/vim-j
" Last Change:	2015-10-27

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo&vim

setlocal iskeyword=48-57,A-Z,a-z,_
setlocal comments=:NB.
setlocal commentstring=NB.\ %s
setlocal formatoptions-=t
setlocal matchpairs=(:)
setlocal path-=/usr/include

" Includes. To make the shorthand form "require 'web/cgi'" work, double the
" last path component. Also strip off leading folder names like "~addons/".
setlocal include=\\v^\\s*(load\|require)\\s*'\\zs\\f+\\ze'
setlocal includeexpr=substitute(substitute(tr(v:fname,'\\','/'),'\\v^[^~][^/.]*(/[^/.]+)$','&\\1',''),'\\v^\\~[^/]+/','','')
setlocal suffixesadd=.ijs

let b:undo_ftplugin = 'setlocal suffixesadd< includeexpr< include< path< matchpairs< formatoptions< commentstring< comments< iskeyword<'

" Section movement with ]] ][ [[ []. The start/end patterns below are amended
" inside the function in order to avoid matching on the current cursor line.
let s:sectionstart = '\%(\s*Note\|.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(:\s*0\|def\s\+0\|define\)\)\>.*'
let s:sectionend = '\s*)\s*'

function! s:SearchSection(end, backwards, visualmode) abort
  if a:visualmode !=# ''
    normal! gv
  endif
  let l:flags = a:backwards ? 'bsW' : 'sW'
  if a:end
    call search('^' . s:sectionend . (a:backwards ? '\n\_.\{-}\%#' : '$'), l:flags)
  else
    call search('^' . s:sectionstart . (a:backwards ? '\n\_.\{-}\%#' : '$'), l:flags)
  endif
endfunction

noremap <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, '')<CR>
xnoremap <buffer> <silent> ]] :<C-U>call <SID>SearchSection(0, 0, visualmode())<CR>
sunmap <buffer> ]]
noremap <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, '')<CR>
xnoremap <buffer> <silent> ][ :<C-U>call <SID>SearchSection(1, 0, visualmode())<CR>
sunmap <buffer> ][
noremap <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, '')<CR>
xnoremap <buffer> <silent> [[ :<C-U>call <SID>SearchSection(0, 1, visualmode())<CR>
sunmap <buffer> [[
noremap <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, '')<CR>
xnoremap <buffer> <silent> [] :<C-U>call <SID>SearchSection(1, 1, visualmode())<CR>
sunmap <buffer> []

let b:undo_ftplugin .= ' | silent! execute "unmap <buffer> ]]"'
                   \ . ' | silent! execute "unmap <buffer> ]["'
                   \ . ' | silent! execute "unmap <buffer> [["'
                   \ . ' | silent! execute "unmap <buffer> []"'

" Browse dialog filter on Windows (see ":help browsefilter")
if has('gui_win32') && !exists('b:browsefilter')
  let b:browsefilter = "J Script Files (*.ijs)\t*.ijs\n"
                   \ . "All Files (*.*)\t*.*\n"
  let b:undo_ftplugin .= ' | unlet! b:browsefilter'
endif

" Enhanced "%" matching (see ":help matchit")
if exists('loaded_matchit') && !exists('b:match_words')
  let b:match_ignorecase = 0
  let b:match_words = '^\%(\s*Note\|.\{-}\<\%([0-4]\|13\|noun\|adverb\|conjunction\|verb\|monad\|dyad\)\s\+\%(\:\s*0\|def\s\+0\|define\)\)\>:^\s*\:\s*$:^\s*)\s*$'
                  \ . ',\<\%(for\%(_\a\k*\)\=\|if\|select\|try\|whil\%(e\|st\)\)\.:\<\%(case\|catch[dt]\=\|else\%(if\)\=\|fcase\)\.:\<end\.'
  let b:undo_ftplugin .= ' | unlet! b:match_ignorecase b:match_words'
endif

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim filetype plugin file
" Language:	Java
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Change:  2012 Mar 11
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif
let b:did_ftplugin = 1

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" For filename completion, prefer the .java extension over the .class
" extension.
set suffixes+=.class

" Enable gf on import statements.  Convert . in the package
" name to / and append .java to the name, then search the path.
setlocal includeexpr=substitute(v:fname,'\\.','/','g')
setlocal suffixesadd=.java
if exists("g:ftplugin_java_source_path")
    let &l:path=g:ftplugin_java_source_path . ',' . &l:path
endif

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set 'comments' to format dashed lists in comments. Behaves just like C.
setlocal comments& comments^=sO:*\ -,mO:*\ \ ,exO:*/

setlocal commentstring=//%s

" Change the :browse e filter to primarily show Java-related files.
if has("gui_win32")
    let  b:browsefilter="Java Files (*.java)\t*.java\n" .
		\	"Properties Files (*.prop*)\t*.prop*\n" .
		\	"Manifest Files (*.mf)\t*.mf\n" .
		\	"All Files (*.*)\t*.*\n"
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "setlocal suffixes< suffixesadd<" .
		\     " formatoptions< comments< commentstring< path< includeexpr<" .
		\     " | unlet! b:browsefilter"

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:     Javascript
" Maintainer:   Doug Kearns <dougkearns@gmail.com>
" Last Change:  2020 Jun 23
" Contributor:  Romain Lafourcade <romainlafourcade@gmail.com>

if exists("b:did_ftplugin")
    finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo-=C

" Set 'formatoptions' to break comment lines but not other lines,
" and insert the comment leader when hitting <CR> or using "o".
setlocal formatoptions-=t formatoptions+=croql

" Set completion with CTRL-X CTRL-O to autoloaded function.
if exists('&ofu')
    setlocal omnifunc=javascriptcomplete#CompleteJS
endif

" Set 'comments' to format dashed lists in comments.
setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

setlocal commentstring=//%s

" Change the :browse e filter to primarily show JavaScript-related files.
if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
    let b:browsefilter =
                \ "JavaScript Files (*.js)\t*.js\n"
                \ .. "JSX Files (*.jsx)\t*.jsx\n"
                \ .. "JavaScript Modules (*.es, *.es6, *.cjs, *.mjs, *.jsm)\t*.es;*.es6;*.cjs;*.mjs;*.jsm\n"
                \ .. "Vue Templates (*.vue)\t*.vue\n"
                \ .. "JSON Files (*.json)\t*.json\n"
                \ .. "All Files (*.*)\t*.*\n"
endif

" The following suffixes should be implied when resolving filenames
setlocal suffixesadd+=.js,.jsx,.es,.es6,.cjs,.mjs,.jsm,.vue,.json

" The following suffixes should have low priority
"   .snap    jest snapshot
setlocal suffixes+=.snap

" Remove irrelevant part of 'path'.
" User is expected to augment it with contextually-relevant paths
setlocal path-=/usr/include

" Matchit configuration
if exists("loaded_matchit")
    let b:match_ignorecase = 0
    let b:match_words =
                \ '\<do\>:\<while\>,'
                \ .. '<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,'
                \ .. '<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
endif

" Set 'define' to a comprehensive value
let &l:define =
            \ '\(^\s*(*async\s\+function\|(*function\)'
            \ .. '\|^\s*\(\*\|static\|async\|get\|set\|\i\+\.\)'
            \ .. '\|^\s*\(\ze\i\+\)\(([^)]*).*{$\|\s*[:=,]\)'
            \ .. '\|^\s*\(export\s\+\|export\s\+default\s\+\)*\(var\|let\|const\|function\|class\)'
            \ .. '\|\<as\>'

let b:undo_ftplugin =
            \ "setl fo< ofu< com< cms< sua< su< def< pa<"
            \ .. "| unlet! b:browsefilter b:match_ignorecase b:match_words"

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: textwidth=78 tabstop=8 shiftwidth=4 softtabstop=4 expandtab
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim filetype plugin file
" Language:	JavaScript React
" Maintainer:	Doug Kearns <dougkearns@gmail.com>
" Last Change:	2020 Aug 19

" Placeholder for backwards compatilibity: .jsx used to stand for JavaScript.
runtime! ftplugin/javascript.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin
" Language:	Java properties file
" Maintainer:	None
" Last Change:	2019 Dec 01

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

setlocal formatoptions-=t
setlocal comments=:#,:!
setlocal commentstring=#\ %s

let b:undo_ftplugin = "setl cms< com< fo<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim filetype plugin
" Language:		JSON
" Maintainer:		David Barnett <daviebdawg+vim@gmail.com>
" Last Change:		2014 Jul 16

if exists('b:did_ftplugin')
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = 'setlocal formatoptions< comments< commentstring<'

setlocal formatoptions-=t

" JSON has no comments.
setlocal comments=
setlocal commentstring=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim filetype plugin
" Language:         JSONC (JSON with Comments)
" Original Author:  Izhak Jakov <izhak724@gmail.com>
" Acknowledgement:  Based off of vim-jsonc maintained by Kevin Locke <kevin@kevinlocke.name>
"                   https://github.com/kevinoid/vim-jsonc
" License:          MIT
" Last Change:      2021 Nov 22

runtime! ftplugin/json.vim

if exists('b:did_ftplugin_jsonc')
  finish
else
  let b:did_ftplugin_jsonc = 1
endif

" Set comment (formatting) related options. {{{1
setlocal commentstring=//%s comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

" Let Vim know how to disable the plug-in.
let b:undo_ftplugin = 'setlocal commentstring< comments<'
                                                                                                                                                                                                                                                                                                                                                           " Vim filetype plugin file
" Language:	jsp
" Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
" Last Changed: 20 Jan 2009
" URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin

if exists("b:did_ftplugin") | finish | endif

" Make sure the continuation lines below do not cause problems in
" compatibility mode.
let s:save_cpo = &cpo
set cpo-=C

" Define some defaults in case the included ftplugins don't set them.
let s:undo_ftplugin = ""
let s:browsefilter = "Java Files (*.java)\t*.java\n" .
	    \	 "HTML Files (*.html, *.htm)\t*.html;*.htm\n" .
	    \	 "All Files (*.*)\t*.*\n"
let s:match_words = ""

runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
unlet b:did_ftplugin

" Override our defaults if these were set by an included ftplugin.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin
    unlet b:undo_ftplugin
endif
if exists("b:browsefilter")
    let s:browsefilter = b:browsefilter
    unlet b:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words
    unlet b:match_words
endif

runtime! ftplugin/java.vim ftplugin/java_*.vim ftplugin/java/*.vim
let b:did_ftplugin = 1

" Combine the new set of values with those previously included.
if exists("b:undo_ftplugin")
    let s:undo_ftplugin = b:undo_ftplugin . " | " . s:undo_ftplugin
endif
if exists ("b:browsefilter")
    let s:browsefilter = b:browsefilter . s:browsefilter
endif
if exists("b:match_words")
    let s:match_words = b:match_words . ',' . s:match_words
endif

" Load the combined list of match_words for matchit.vim
if exists("loaded_matchit")
    let b:match_words = s:match_words
endif

" Change the :browse e filter to primarily show JSP-related files.
if has("gui_win32")
    let  b:browsefilter="JSP Files (*.jsp)\t*.jsp\n" . s:browsefilter
endif

" Undo the stuff we changed.
let b:undo_ftplugin = "unlet! b:browsefilter b:match_words | " . s:undo_ftplugin

" Restore the saved compatibility options.
let &cpo = s:save_cpo
unlet s:save_cpo
                                     " Vim filetype plugin file
" Language:	Julia
" Maintainer:	Carlo Baldassi <carlobaldassi@gmail.com>
" Homepage:	https://github.com/JuliaEditorSupport/julia-vim
" Last Change:	2021 Aug 04
" adapted from upstream 2021 Aug 4

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo-=C

setlocal include=^\\s*\\%(reload\\\|include\\)\\>
setlocal suffixesadd=.jl
setlocal comments=:#
setlocal commentstring=#\ %s
setlocal cinoptions+=#1
setlocal define=^\\s*macro\\>
setlocal fo-=t fo+=croql

let b:julia_vim_loaded = 1

let b:undo_ftplugin = "setlocal include< suffixesadd< comments< commentstring<"
      \ . " define< fo< shiftwidth< expandtab< indentexpr< indentkeys< cinoptions< completefunc<"
      \ . " | unlet! b:julia_vim_loaded"

" MatchIt plugin support
if exists("loaded_matchit")
  let b:match_ignorecase = 0

  " note: begin_keywords must contain all blocks, in order
  " for nested-structures-skipping to work properly
  " note: 'mutable struct' and 'struct' are defined separately because
  " using \? puts the cursor on 'struct' instead of 'mutable' for some reason
  let b:julia_begin_keywords = '\%(\.\s*\|@\)\@<!\<\%(function\|macro\|begin\|mutable\s\+struct\|\%(mutable\s\+\)\@<!struct\|\%(abstract\|primitive\)\s\+type\|let\|do\|\%(bare\)\?module\|quote\|if\|for\|while\|try\)\>'
  " note: the following regex not only recognizes macros, but also local/global keywords.
  " the purpose is recognizing things like `@inline myfunction()`
  " or `global myfunction(...)` etc, for matchit and block movement functionality
  let s:macro_regex = '\%(@\%([#(]\@!\S\)\+\|\<\%(local\|global\)\)\s\+'
  let s:nomacro = '\%(' . s:macro_regex . '\)\@<!'
  let s:yesmacro = s:nomacro . '\%('. s:macro_regex . '\)\+'
  let b:julia_begin_keywordsm = '\%(' . s:yesmacro . b:julia_begin_keywords . '\)\|'
        \ . '\%(' . s:nomacro . b:julia_begin_keywords . '\)'
  let b:julia_end_keywords = '\<end\>'

  " note: this function relies heavily on the syntax file
  function! JuliaGetMatchWords()
    let [l,c] = [line('.'),col('.')]
    let attr = synIDattr(synID(l, c, 1),"name")
    let c1 = c
    while attr == 'juliaMacro' || expand('<cword>') =~# '\<\%(global\|local\)\>'
      normal! W
      if line('.') > l || col('.') == c1
        call cursor(l, c)
        return ''
      endif
      let attr = synIDattr(synID(l, col('.'), 1),"name")
      let c1 = col('.')
    endwhile
    call cursor(l, c)
    if attr == 'juliaConditional'
      return b:julia_begin_keywordsm . ':\<\%(elseif\|else\)\>:' . b:julia_end_keywords
    elseif attr =~# '\<\%(juliaRepeat\|juliaRepKeyword\)\>'
      return b:julia_begin_keywordsm . ':\<\%(break\|continue\)\>:' . b:julia_end_keywords
    elseif attr == 'juliaBlKeyword'
      return b:julia_begin_keywordsm . ':' . b:julia_end_keywords
    elseif attr == 'juliaException'
      return b:julia_begin_keywordsm . ':\<\%(catch\|finally\)\>:' . b:julia_end_keywords
    endif
    return '\<\>:\<\>'
  endfunction

  let b:match_words = 'JuliaGetMatchWords()'

  " we need to skip everything within comments, strings and
  " the 'begin' and 'end' keywords when they are used as a range rather than as
  " the delimiter of a block
  let b:match_skip = 'synIDattr(synID(line("."),col("."),0),"name") =~# '
        \ . '"\\<julia\\%(Comprehension\\%(For\\|If\\)\\|RangeKeyword\\|Comment\\%([LM]\\|Delim\\)\\|\\%([bs]\\|Shell\\|Printf\\|Doc\\)\\?String\\|StringPrefixed\\|DocStringM\\(Raw\\)\\?\\|RegEx\\|SymbolS\\?\\|Dotted\\)\\>"'

  let b:undo_ftplugin = b:undo_ftplugin
        \ . " | unlet! b:match_words b:match_skip b:match_ignorecase"
        \ . " | unlet! b:julia_begin_keywords b:julia_end_keywords"
        \ . " | delfunction JuliaGetMatchWords"

endif

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                        kconfig.vim    kwt.vim    ld.vim     less.vim   lftp.vim   	libao.vim      
limits.vim     
liquid.vim     lisp.vim   logcheck.vim   loginaccess.vim    logindefs.vim      logtalk.dict   logtalk.vim    lprolog.vim    lua.vim    m3build.vim    m3quake.vim    m4.vim     mail.vim   mailaliases.vim    mailcap.vim    make.vim   man.vim    manconf.vim    markdown.vim   masm.vim   
matlab.vim     	meson.vim      mf.vim     mma.vim    modconf.vim    modula2.vim    modula3.vim    mp.vim     mplayerconf.vim    mrxvtrc.vim    msmessages.vim     
muttrc.vim     
nanorc.vim     neomuttrc.vim      	netrc.vim      	nginx.vim      	nroff.vim      nsis.vim   objc.vim   	ocaml.vim      	occam.vim      
octave.vim     pamconf.vim    
pascal.vim     
passwd.vim     	pbtxt.vim       " Vim filetype plugin file
" Vim syntax file
" Maintainer:           Christian Brabandt <cb@256bit.org>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2015-05-29
" License:              Vim (see :h license)
" Repository:		https://github.com/chrisbra/vim-kconfig

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

" For matchit.vim
if exists("loaded_matchit")
  let b:match_words = '^\<menu\>:\<endmenu\>,^\<if\>:\<endif\>,^\<choice\>:\<endchoice\>'
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                 " Vim filetype plugin file
" Language:	Kimwitu++
" Maintainer:	Michael Piefel <entwurf@piefel.de>
" Last Change:	10 March 2012

" Behaves almost like C++
runtime! ftplugin/cpp.vim ftplugin/cpp_*.vim ftplugin/cpp/*.vim

let s:cpo_save = &cpo
set cpo&vim

" Limit the browser to related files
if has("gui_win32") && !exists("b:browsefilter")
    let b:browsefilter = "Kimwitu/Kimwitu++ Files (*.k)\t*.k\n" .
		\ "Lex/Flex Files (*.l)\t*.l\n" .
		\ "Yacc/Bison Files (*.y)\t*.y\n" .
		\ "All Files (*.*)\t*.*\n"
endif

" Set the errorformat for the Kimwitu++ compiler
set efm+=kc%.%#:\ error\ at\ %f:%l:\ %m

if exists("b:undo_ftplugin")
    let b:undo_ftplugin = b:undo_ftplugin . " | setlocal efm<"
	\ . "| unlet! b:browsefiler"
else
    let b:undo_ftplugin = "setlocal efm<"
	\ . "| unlet! b:browsefiler"
endif

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                             " Vim filetype plugin file
" Language:             ld(1) script
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< inc< fo<"

setlocal comments=s1:/*,mb:*,ex:*/ commentstring=/*%s*/ include=^\\s*INCLUDE
setlocal formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin
" Language:	less
" Maintainer:	Alessandro Vioni <jenoma@gmail.com>
" URL: https://github.com/genoma/vim-less
" Last Change:	2014 November 24

" Only do this when not done yet for this buffer
if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let b:undo_ftplugin = "setl cms< def< inc< inex< ofu< sua<"

setlocal formatoptions-=t formatoptions+=croql

setlocal comments=:// commentstring=//\ %s

setlocal omnifunc=csscomplete#CompleteCSS
setlocal suffixesadd=.less
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim filetype plugin file
" Language:             lftp(1) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim filetype plugin file
" Language:             libao.conf(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl com< cms< fo<"

setlocal comments=:# commentstring=#\ %s formatoptions-=t formatoptions+=croql

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        