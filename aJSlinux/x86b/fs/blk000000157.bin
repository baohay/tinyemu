line, col)
      if g:ruby_indent_assignment_style == 'hanging'
        " hanging indent
        let ind = col - 1
      else
        " align with variable
        let ind = indent(info.plnum)
      endif
    else
      let ind = indent(s:GetMSL(info.plnum))
    endif
    return ind + info.sw + info.sw
  endif
  return -1
endfunction

function! s:AfterBlockOpening(pline_info) abort
  let info = a:pline_info

  " If the previous line ended with a block opening, add a level of indent.
  if s:Match(info.plnum, s:block_regex)
    if g:ruby_indent_block_style == 'do'
      " don't align to the msl, align to the "do"
      let ind = indent(info.plnum) + info.sw
    else
      let plnum_msl = s:GetMSL(info.plnum)

      if getline(plnum_msl) =~ '=\s*\(#.*\)\=$'
        " in the case of assignment to the msl, align to the starting line,
        " not to the msl
        let ind = indent(info.plnum) + info.sw
      else
        let ind = indent(plnum_msl) + info.sw
      endif
    endif

    return ind
  endif

  return -1
endfunction

function! s:AfterLeadingOperator(pline_info) abort
  " If the previous line started with a leading operator, use its MSL's level
  " of indent
  if s:Match(a:pline_info.plnum, s:leading_operator_regex)
    return indent(s:GetMSL(a:pline_info.plnum))
  endif
  return -1
endfunction

function! s:AfterHangingSplat(pline_info) abort
  let info = a:pline_info

  " If the previous line ended with the "*" of a splat, add a level of indent
  if info.pline =~ s:splat_regex
    return indent(info.plnum) + info.sw
  endif
  return -1
endfunction

function! s:AfterUnbalancedBracket(pline_info) abort
  let info = a:pline_info

  " If the previous line contained unclosed opening brackets and we are still
  " in them, find the rightmost one and add indent depending on the bracket
  " type.
  "
  " If it contained hanging closing brackets, find the rightmost one, find its
  " match and indent according to that.
  if info.pline =~ '[[({]' || info.pline =~ '[])}]\s*\%(#.*\)\=$'
    let [opening, closing] = s:ExtraBrackets(info.plnum)

    if opening.pos != -1
      if !g:ruby_indent_hanging_elements
        return indent(info.plnum) + info.sw
      elseif opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
        if col('.') + 1 == col('$')
          return indent(info.plnum) + info.sw
        else
          return virtcol('.')
        endif
      else
        let nonspace = matchend(info.pline, '\S', opening.pos + 1) - 1
        return nonspace > 0 ? nonspace : indent(info.plnum) + info.sw
      endif
    elseif closing.pos != -1
      call cursor(info.plnum, closing.pos + 1)
      normal! %

      if s:Match(line('.'), s:ruby_indent_keywords)
        return indent('.') + info.sw
      else
        return indent(s:GetMSL(line('.')))
      endif
    else
      call cursor(info.clnum, info.col)
    end
  endif

  return -1
endfunction

function! s:AfterEndKeyword(pline_info) abort
  let info = a:pline_info
  " If the previous line ended with an "end", match that "end"s beginning's
  " indent.
  let col = s:Match(info.plnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
  if col > 0
    call cursor(info.plnum, col)
    if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW',
          \ s:end_skip_expr) > 0
      let n = line('.')
      let ind = indent('.')
      let msl = s:GetMSL(n)
      if msl != n
        let ind = indent(msl)
      end
      return ind
    endif
  end
  return -1
endfunction

function! s:AfterIndentKeyword(pline_info) abort
  let info = a:pline_info
  let col = s:Match(info.plnum, s:ruby_indent_keywords)

  if col > 0
    call cursor(info.plnum, col)
    let ind = virtcol('.') - 1 + info.sw
    " TODO: make this better (we need to count them) (or, if a searchpair
    " fails, we know that something is lacking an end and thus we indent a
    " level
    if s:Match(info.plnum, s:end_end_regex)
      let ind = indent('.')
    elseif s:IsAssignment(info.pline, col)
      if g:ruby_indent_assignment_style == 'hanging'
        " hanging indent
        let ind = col + info.sw - 1
      else
        " align with variable
        let ind = indent(info.plnum) + info.sw
      endif
    endif
    return ind
  endif

  return -1
endfunction

function! s:PreviousNotMSL(msl_info) abort
  let info = a:msl_info

  " If the previous line wasn't a MSL
  if info.plnum != info.plnum_msl
    " If previous line ends bracket and begins non-bracket continuation decrease indent by 1.
    if s:Match(info.plnum, s:bracket_switch_continuation_regex)
      " TODO (2016-10-07) Wrong/unused? How could it be "1"?
      return indent(info.plnum) - 1
      " If previous line is a continuation return its indent.
    elseif s:Match(info.plnum, s:non_bracket_continuation_regex)
      return indent(info.plnum)
    endif
  endif

  return -1
endfunction

function! s:IndentingKeywordInMSL(msl_info) abort
  let info = a:msl_info
  " If the MSL line had an indenting keyword in it, add a level of indent.
  " TODO: this does not take into account contrived things such as
  " module Foo; class Bar; end
  let col = s:Match(info.plnum_msl, s:ruby_indent_keywords)
  if col > 0
    let ind = indent(info.plnum_msl) + info.sw
    if s:Match(info.plnum_msl, s:end_end_regex)
      let ind = ind - info.sw
    elseif s:IsAssignment(getline(info.plnum_msl), col)
      if g:ruby_indent_assignment_style == 'hanging'
        " hanging indent
        let ind = col + info.sw - 1
      else
        " align with variable
        let ind = indent(info.plnum_msl) + info.sw
      endif
    endif
    return ind
  endif
  return -1
endfunction

function! s:ContinuedHangingOperator(msl_info) abort
  let info = a:msl_info

  " If the previous line ended with [*+/.,-=], but wasn't a block ending or a
  " closing bracket, indent one extra level.
  if s:Match(info.plnum_msl, s:non_bracket_continuation_regex) && !s:Match(info.plnum_msl, '^\s*\([\])}]\|end\)')
    if info.plnum_msl == info.plnum
      let ind = indent(info.plnum_msl) + info.sw
    else
      let ind = indent(info.plnum_msl)
    endif
    return ind
  endif

  return -1
endfunction

" 4. Auxiliary Functions {{{1
" ======================

function! s:IsInRubyGroup(groups, lnum, col) abort
  let ids = map(copy(a:groups), 'hlID("ruby".v:val)')
  return index(ids, synID(a:lnum, a:col, 1)) >= 0
endfunction

" Check if the character at lnum:col is inside a string, comment, or is ascii.
function! s:IsInStringOrComment(lnum, col) abort
  return s:IsInRubyGroup(s:syng_strcom, a:lnum, a:col)
endfunction

" Check if the character at lnum:col is inside a string.
function! s:IsInString(lnum, col) abort
  return s:IsInRubyGroup(s:syng_string, a:lnum, a:col)
endfunction

" Check if the character at lnum:col is inside a string or documentation.
function! s:IsInStringOrDocumentation(lnum, col) abort
  return s:IsInRubyGroup(s:syng_stringdoc, a:lnum, a:col)
endfunction

" Check if the character at lnum:col is inside a string delimiter
function! s:IsInStringDelimiter(lnum, col) abort
  return s:IsInRubyGroup(
        \ ['HeredocDelimiter', 'PercentStringDelimiter', 'StringDelimiter'],
        \ a:lnum, a:col
        \ )
endfunction

function! s:IsAssignment(str, pos) abort
  return strpart(a:str, 0, a:pos - 1) =~ '=\s*$'
endfunction

" Find line above 'lnum' that isn't empty, in a comment, or in a string.
function! s:PrevNonBlankNonString(lnum) abort
  let in_block = 0
  let lnum = prevnonblank(a:lnum)
  while lnum > 0
    " Go in and out of blocks comments as necessary.
    " If the line isn't empty (with opt. comment) or in a string, end search.
    let line = getline(lnum)
    if line =~ '^=begin'
      if in_block
        let in_block = 0
      else
        break
      endif
    elseif !in_block && line =~ '^=end'
      let in_block = 1
    elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1)
          \ && s:IsInStringOrComment(lnum, strlen(line)))
      break
    endif
    let lnum = prevnonblank(lnum - 1)
  endwhile
  return lnum
endfunction

" Find line above 'lnum' that started the continuation 'lnum' may be part of.
function! s:GetMSL(lnum) abort
  " Start on the line we're at and use its indent.
  let msl = a:lnum
  let lnum = s:PrevNonBlankNonString(a:lnum - 1)
  while lnum > 0
    " If we have a continuation line, or we're in a string, use line as MSL.
    " Otherwise, terminate search as we have found our MSL already.
    let line = getline(lnum)

    if !s:Match(msl, s:backslash_continuation_regex) &&
          \ s:Match(lnum, s:backslash_continuation_regex)
      " If the current line doesn't end in a backslash, but the previous one
      " does, look for that line's msl
      "
      " Example:
      "   foo = "bar" \
      "     "baz"
      "
      let msl = lnum
    elseif s:Match(msl, s:leading_operator_regex)
      " If the current line starts with a leading operator, keep its indent
      " and keep looking for an MSL.
      let msl = lnum
    elseif s:Match(lnum, s:splat_regex)
      " If the above line looks like the "*" of a splat, use the current one's
      " indentation.
      "
      " Example:
      "   Hash[*
      "     method_call do
      "       something
      "
      return msl
    elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
          \ s:Match(msl, s:non_bracket_continuation_regex)
      " If the current line is a non-bracket continuation and so is the
      " previous one, keep its indent and continue looking for an MSL.
      "
      " Example:
      "   method_call one,
      "     two,
      "     three
      "
      let msl = lnum
    elseif s:Match(lnum, s:dot_continuation_regex) &&
          \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
      " If the current line is a bracket continuation or a block-starter, but
      " the previous is a dot, keep going to see if the previous line is the
      " start of another continuation.
      "
      " Example:
      "   parent.
      "     method_call {
      "     three
      "
      let msl = lnum
    elseif s:Match(lnum, s:non_bracket_continuation_regex) &&
          \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
      " If the current line is a bracket continuation or a block-starter, but
      " the previous is a non-bracket one, respect the previous' indentation,
      " and stop here.
      "
      " Example:
      "   method_call one,
      "     two {
      "     three
      "
      return lnum
    elseif s:Match(lnum, s:bracket_continuation_regex) &&
          \ (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
      " If both lines are bracket continuations (the current may also be a
      " block-starter), use the current one's and stop here
      "
      " Example:
      "   method_call(
      "     other_method_call(
      "       foo
      return msl
    elseif s:Match(lnum, s:block_regex) &&
          \ !s:Match(msl, s:continuation_regex) &&
          \ !s:Match(msl, s:block_continuation_regex)
      " If the previous line is a block-starter and the current one is
      " mostly ordinary, use the current one as the MSL.
      "
      " Example:
      "   method_call do
      "     something
      "     something_else
      return msl
    else
      let col = match(line, s:continuation_regex) + 1
      if (col > 0 && !s:IsInStringOrComment(lnum, col))
            \ || s:IsInString(lnum, strlen(line))
        let msl = lnum
      else
        break
      endif
    endif

    let lnum = s:PrevNonBlankNonString(lnum - 1)
  endwhile
  return msl
endfunction

" Check if line 'lnum' has more opening brackets than closing ones.
function! s:ExtraBrackets(lnum) abort
  let opening = {'parentheses': [], 'braces': [], 'brackets': []}
  let closing = {'parentheses': [], 'braces': [], 'brackets': []}

  let line = getline(a:lnum)
  let pos  = match(line, '[][(){}]', 0)

  " Save any encountered opening brackets, and remove them once a matching
  " closing one has been found. If a closing bracket shows up that doesn't
  " close anything, save it for later.
  while pos != -1
    if !s:IsInStringOrComment(a:lnum, pos + 1)
      if line[pos] == '('
        call add(opening.parentheses, {'type': '(', 'pos': pos})
      elseif line[pos] == ')'
        if empty(opening.parentheses)
          call add(closing.parentheses, {'type': ')', 'pos': pos})
        else
          let opening.parentheses = opening.parentheses[0:-2]
        endif
      elseif line[pos] == '{'
        call add(opening.braces, {'type': '{', 'pos': pos})
      elseif line[pos] == '}'
        if empty(opening.braces)
          call add(closing.braces, {'type': '}', 'pos': pos})
        else
          let opening.braces = opening.braces[0:-2]
        endif
      elseif line[pos] == '['
        call add(opening.brackets, {'type': '[', 'pos': pos})
      elseif line[pos] == ']'
        if empty(opening.brackets)
          call add(closing.brackets, {'type': ']', 'pos': pos})
        else
          let opening.brackets = opening.brackets[0:-2]
        endif
      endif
    endif

    let pos = match(line, '[][(){}]', pos + 1)
  endwhile

  " Find the rightmost brackets, since they're the ones that are important in
  " both opening and closing cases
  let rightmost_opening = {'type': '(', 'pos': -1}
  let rightmost_closing = {'type': ')', 'pos': -1}

  for opening in opening.parentheses + opening.braces + opening.brackets
    if opening.pos > rightmost_opening.pos
      let rightmost_opening = opening
    endif
  endfor

  for closing in closing.parentheses + closing.braces + closing.brackets
    if closing.pos > rightmost_closing.pos
      let rightmost_closing = closing
    endif
  endfor

  return [rightmost_opening, rightmost_closing]
endfunction

function! s:Match(lnum, regex) abort
  let line   = getline(a:lnum)
  let offset = match(line, '\C'.a:regex)
  let col    = offset + 1

  while offset > -1 && s:IsInStringOrComment(a:lnum, col)
    let offset = match(line, '\C'.a:regex, offset + 1)
    let col = offset + 1
  endwhile

  if offset > -1
    return col
  else
    return 0
  endif
endfunction

" Locates the containing class/module's definition line, ignoring nested classes
" along the way.
"
function! s:FindContainingClass() abort
  let saved_position = getpos('.')

  while searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW',
        \ s:end_skip_expr) > 0
    if expand('<cword>') =~# '\<class\|module\>'
      let found_lnum = line('.')
      call setpos('.', saved_position)
      return found_lnum
    endif
  endwhile

  call setpos('.', saved_position)
  return 0
endfunction

" }}}1

let &cpo = s:cpo_save
unlet s:cpo_save

" vim:set sw=2 sts=2 ts=8 et:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim indent file
" Language:         Rust
" Author:           Chris Morgan <me@chrismorgan.info>
" Last Change:      2017 Jun 13
" For bugs, patches and license go to https://github.com/rust-lang/rust.vim

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
	finish
endif
let b:did_indent = 1

setlocal cindent
setlocal cinoptions=L0,(0,Ws,J1,j1
setlocal cinkeys=0{,0},!^F,o,O,0[,0]
" Don't think cinwords will actually do anything at all... never mind
setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern

" Some preliminary settings
setlocal nolisp		" Make sure lisp indenting doesn't supersede us
setlocal autoindent	" indentexpr isn't much help otherwise
" Also do indentkeys, otherwise # gets shoved to column 0 :-/
setlocal indentkeys=0{,0},!^F,o,O,0[,0]

setlocal indentexpr=GetRustIndent(v:lnum)

" Only define the function once.
if exists("*GetRustIndent")
	finish
endif

let s:save_cpo = &cpo
set cpo&vim

" Come here when loading the script the first time.

function! s:get_line_trimmed(lnum)
	" Get the line and remove a trailing comment.
	" Use syntax highlighting attributes when possible.
	" NOTE: this is not accurate; /* */ or a line continuation could trick it
	let line = getline(a:lnum)
	let line_len = strlen(line)
	if has('syntax_items')
		" If the last character in the line is a comment, do a binary search for
		" the start of the comment.  synID() is slow, a linear search would take
		" too long on a long line.
		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
			let min = 1
			let max = line_len
			while min < max
				let col = (min + max) / 2
				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
					let max = col
				else
					let min = col + 1
				endif
			endwhile
			let line = strpart(line, 0, min - 1)
		endif
		return substitute(line, "\s*$", "", "")
	else
		" Sorry, this is not complete, nor fully correct (e.g. string "//").
		" Such is life.
		return substitute(line, "\s*//.*$", "", "")
	endif
endfunction

function! s:is_string_comment(lnum, col)
	if has('syntax_items')
		for id in synstack(a:lnum, a:col)
			let synname = synIDattr(id, "name")
			if synname == "rustString" || synname =~ "^rustComment"
				return 1
			endif
		endfor
	else
		" without syntax, let's not even try
		return 0
	endif
endfunction

function GetRustIndent(lnum)

	" Starting assumption: cindent (called at the end) will do it right
	" normally. We just want to fix up a few cases.

	let line = getline(a:lnum)

	if has('syntax_items')
		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
		if synname == "rustString"
			" If the start of the line is in a string, don't change the indent
			return -1
		elseif synname =~ '\(Comment\|Todo\)'
					\ && line !~ '^\s*/\*'  " not /* opening line
			if synname =~ "CommentML" " multi-line
				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
					" This is (hopefully) the line after a /*, and it has no
					" leader, so the correct indentation is that of the
					" previous line.
					return GetRustIndent(a:lnum - 1)
				endif
			endif
			" If it's in a comment, let cindent take care of it now. This is
			" for cases like "/*" where the next line should start " * ", not
			" "* " as the code below would otherwise cause for module scope
			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
			return cindent(a:lnum)
		endif
	endif

	" cindent gets second and subsequent match patterns/struct members wrong,
	" as it treats the comma as indicating an unfinished statement::
	"
	" match a {
	"     b => c,
	"         d => e,
	"         f => g,
	" };

	" Search backwards for the previous non-empty line.
	let prevlinenum = prevnonblank(a:lnum - 1)
	let prevline = s:get_line_trimmed(prevlinenum)
	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
		let prevlinenum = prevnonblank(prevlinenum - 1)
		let prevline = s:get_line_trimmed(prevlinenum)
	endwhile

	" Handle where clauses nicely: subsequent values should line up nicely.
	if prevline[len(prevline) - 1] == ","
				\ && prevline =~# '^\s*where\s'
		return indent(prevlinenum) + 6
	endif

	if prevline[len(prevline) - 1] == ","
				\ && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]'
				\ && prevline !~ '^\s*fn\s'
				\ && prevline !~ '([^()]\+,$'
				\ && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
		" Oh ho! The previous line ended in a comma! I bet cindent will try to
		" take this too far... For now, let's normally use the previous line's
		" indent.

		" One case where this doesn't work out is where *this* line contains
		" square or curly brackets; then we normally *do* want to be indenting
		" further.
		"
		" Another case where we don't want to is one like a function
		" definition with arguments spread over multiple lines:
		"
		" fn foo(baz: Baz,
		"        baz: Baz) // <-- cindent gets this right by itself
		"
		" Another case is similar to the previous, except calling a function
		" instead of defining it, or any conditional expression that leaves
		" an open paren:
		"
		" foo(baz,
		"     baz);
		"
		" if baz && (foo ||
		"            bar) {
		"
		" Another case is when the current line is a new match arm.
		"
		" There are probably other cases where we don't want to do this as
		" well. Add them as needed.
		return indent(prevlinenum)
	endif

	if !has("patch-7.4.355")
		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
		"
		" static FOO : &'static [bool] = [
		" true,
		"	 false,
		"	 false,
		"	 true,
		"	 ];
		"
		"	 uh oh, next statement is indented further!

		" Note that this does *not* apply the line continuation pattern properly;
		" that's too hard to do correctly for my liking at present, so I'll just
		" start with these two main cases (square brackets and not returning to
		" column zero)

		call cursor(a:lnum, 1)
		if searchpair('{\|(', '', '}\|)', 'nbW',
					\ 's:is_string_comment(line("."), col("."))') == 0
			if searchpair('\[', '', '\]', 'nbW',
						\ 's:is_string_comment(line("."), col("."))') == 0
				" Global scope, should be zero
				return 0
			else
				" At the module scope, inside square brackets only
				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
				if line =~ "^\\s*]"
					" It's the closing line, dedent it
					return 0
				else
					return shiftwidth()
				endif
			endif
		endif
	endif

	" Fall back on cindent, which does it mostly right
	return cindent(a:lnum)
endfunction

let &cpo = s:save_cpo
unlet s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              " Vim indent file
" Language:     SAS
" Maintainer:   Zhen-Huan Hu <wildkeny@gmail.com>
" Version:      3.0.3
" Last Change:  Jun 26, 2018

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetSASIndent()
setlocal indentkeys+=;,=~data,=~proc,=~macro

if exists("*GetSASIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

" Regex that captures the start of a data/proc section
let s:section_str = '\v%(^|;)\s*%(data|proc)>'
" Regex that captures the end of a run-processing section
let s:section_run = '\v%(^|;)\s*run\s*;'
" Regex that captures the end of a data/proc section
let s:section_end = '\v%(^|;)\s*%(quit|enddata)\s*;'

" Regex that captures the start of a control block (anything inside a section)
let s:block_str = '\v<%(do>%([^;]+<%(to|over|while)>[^;]+)=|%(compute|define\s+%(column|footer|header|style|table|tagset|crosstabs|statgraph)|edit|layout|method|select)>[^;]+|begingraph)\s*;'
" Regex that captures the end of a control block (anything inside a section)
let s:block_end = '\v<%(end|endcomp|endlayout|endgraph)\s*;'

" Regex that captures the start of a macro
let s:macro_str = '\v%(^|;)\s*\%macro>'
" Regex that captures the end of a macro
let s:macro_end = '\v%(^|;)\s*\%mend\s*;'

" Regex that defines the end of the program
let s:program_end = '\v%(^|;)\s*endsas\s*;'

" List of procs supporting run-processing
let s:run_processing_procs = [
      \ 'catalog', 'chart', 'datasets', 'document', 'ds2', 'plot', 'sql',
      \ 'gareabar', 'gbarline', 'gchart', 'gkpi', 'gmap', 'gplot', 'gradar', 'greplay', 'gslide', 'gtile',
      \ 'anova', 'arima', 'catmod', 'factex', 'glm', 'model', 'optex', 'plan', 'reg',
      \ 'iml',
      \ ]

" Find the line number of previous keyword defined by the regex
function! s:PrevMatch(lnum, regex)
  let prev_lnum = prevnonblank(a:lnum - 1)
  while prev_lnum > 0
    let prev_line = getline(prev_lnum)
    if prev_line =~? a:regex
      break
    else
      let prev_lnum = prevnonblank(prev_lnum - 1)
    endif
  endwhile
  return prev_lnum
endfunction

" Main function
function! GetSASIndent()
  let prev_lnum = prevnonblank(v:lnum - 1)
  if prev_lnum ==# 0
    " Leave the indentation of the first line unchanged
    return indent(1)
  else
    let prev_line = getline(prev_lnum)
    " Previous non-blank line contains the start of a macro/section/block
    " while not the end of a macro/section/block (at the same line)
    if (prev_line =~? s:section_str && prev_line !~? s:section_run && prev_line !~? s:section_end) ||
          \ (prev_line =~? s:block_str && prev_line !~? s:block_end) ||
          \ (prev_line =~? s:macro_str && prev_line !~? s:macro_end)
      let ind = indent(prev_lnum) + shiftwidth()
    elseif prev_line =~? s:section_run && prev_line !~? s:section_end
      let prev_section_str_lnum = s:PrevMatch(v:lnum, s:section_str)
      let prev_section_end_lnum = max([
            \ s:PrevMatch(v:lnum, s:section_end),
            \ s:PrevMatch(v:lnum, s:macro_end  ),
            \ s:PrevMatch(v:lnum, s:program_end)])
      " Check if the section supports run-processing
      if prev_section_end_lnum < prev_section_str_lnum &&
            \ getline(prev_section_str_lnum) =~? '\v%(^|;)\s*proc\s+%(' .
            \ join(s:run_processing_procs, '|') . ')>'
        let ind = indent(prev_lnum) + shiftwidth()
      else
        let ind = indent(prev_lnum)
      endif
    else
      let ind = indent(prev_lnum)
    endif
  endif
  " Re-adjustments based on the inputs of the current line
  let curr_line = getline(v:lnum)
  if curr_line =~? s:program_end
    " End of the program
    " Same indentation as the first non-blank line
    return indent(nextnonblank(1))
  elseif curr_line =~? s:macro_end
    " Current line is the end of a macro
    " Match the indentation of the start of the macro
    return indent(s:PrevMatch(v:lnum, s:macro_str))
  elseif curr_line =~? s:block_end && curr_line !~? s:block_str
    " Re-adjust if current line is the end of a block
    " while not the beginning of a block (at the same line)
    " Returning the indent of previous block start directly
    " would not work due to nesting
    let ind = ind - shiftwidth()
  elseif curr_line =~? s:section_str || curr_line =~? s:section_run || curr_line =~? s:section_end
    " Re-adjust if current line is the start/end of a section
    " since the end of a section could be inexplicit
    let prev_section_str_lnum = s:PrevMatch(v:lnum, s:section_str)
    " Check if the previous section supports run-processing
    if getline(prev_section_str_lnum) =~? '\v%(^|;)\s*proc\s+%(' .
          \ join(s:run_processing_procs, '|') . ')>'
      let prev_section_end_lnum = max([
            \ s:PrevMatch(v:lnum, s:section_end),
            \ s:PrevMatch(v:lnum, s:macro_end  ),
            \ s:PrevMatch(v:lnum, s:program_end)])
    else
      let prev_section_end_lnum = max([
            \ s:PrevMatch(v:lnum, s:section_end),
            \ s:PrevMatch(v:lnum, s:section_run),
            \ s:PrevMatch(v:lnum, s:macro_end  ),
            \ s:PrevMatch(v:lnum, s:program_end)])
    endif
    if prev_section_end_lnum < prev_section_str_lnum
      let ind = ind - shiftwidth()
    endif
  endif
  return ind
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Vim indent file
" Language:	Sass
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2017 Jun 13

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal autoindent sw=2 et
setlocal indentexpr=GetSassIndent()
setlocal indentkeys=o,O,*<Return>,<:>,!^F

" Only define the function once.
if exists("*GetSassIndent")
  finish
endif

let s:property = '^\s*:\|^\s*[[:alnum:]#{}-]\+\%(:\|\s*=\)'
let s:extend = '^\s*\%(@extend\|@include\|+\)'

function! GetSassIndent()
  let lnum = prevnonblank(v:lnum-1)
  let line = substitute(getline(lnum),'\s\+$','','')
  let cline = substitute(substitute(getline(v:lnum),'\s\+$','',''),'^\s\+','','')
  let lastcol = strlen(line)
  let line = substitute(line,'^\s\+','','')
  let indent = indent(lnum)
  let cindent = indent(v:lnum)
  if line !~ s:property && line !~ s:extend && cline =~ s:property
    return indent + shiftwidth()
  else
    return -1
  endif
endfunction

" vim:set sw=2:
                                                                          " Vim indent file
" Language:             Scala (http://scala-lang.org/)
" Original Author:      Stefan Matthias Aust
" Modifications By:     Derek Wyatt
" URL:                  https://github.com/derekwyatt/vim-scala
" Last Change:          2016 Aug 26

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetScalaIndent()
setlocal indentkeys=0{,0},0),!^F,<>>,o,O,e,=case,<CR>

if exists("*GetScalaIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

let s:annotationMatcher = '@[A-Za-z._]\+\s\+'
let s:modifierMatcher = s:annotationMatcher . '\|\%(private\|protected\)\%(\[[^\]]*\]\)\?\s\+\|abstract\s\+\|override\s\+\|final\s\+'
let s:defMatcher = '\%(' . s:modifierMatcher . '\)*\<def\>'
let s:valMatcher = '\%(' . s:modifierMatcher . '\|lazy\s\+\)*\<va[lr]\>'
let s:funcNameMatcher = '\w\+'
let s:typeSpecMatcher = '\%(\s*\[\_[^\]]*\]\)'
let s:defArgMatcher = '\%((\_.\{-})\)'
let s:returnTypeMatcher = '\%(:\s*\w\+' . s:typeSpecMatcher . '\?\)'
let g:fullDefMatcher = '^\s*' . s:defMatcher . '\s\+' . s:funcNameMatcher . '\s*' . s:typeSpecMatcher . '\?\s*' . s:defArgMatcher . '\?\s*' . s:returnTypeMatcher . '\?\s*[={]'

function! scala#ConditionalConfirm(msg)
  if 0
    call confirm(a:msg)
  endif
endfunction

function! scala#GetLine(lnum)
  let line = substitute(getline(a:lnum), '//.*$', '', '')
  let line = substitute(line, '"\(.\|\\"\)\{-}"', '""', 'g')
  return line
endfunction

function! scala#CountBrackets(line, openBracket, closedBracket)
  let line = substitute(a:line, '"\(.\|\\"\)\{-}"', '', 'g')
  let open = substitute(line, '[^' . a:openBracket . ']', '', 'g')
  let close = substitute(line, '[^' . a:closedBracket . ']', '', 'g')
  return strlen(open) - strlen(close)
endfunction

function! scala#CountParens(line)
  return scala#CountBrackets(a:line, '(', ')')
endfunction

function! scala#CountCurlies(line)
  return scala#CountBrackets(a:line, '{', '}')
endfunction

function! scala#LineEndsInIncomplete(line)
  if a:line =~ '[.,]\s*$'
    return 1
  else
    return 0
  endif
endfunction

function! scala#LineIsAClosingXML(line)
  if a:line =~ '^\s*</\w'
    return 1
  else
    return 0
  endif
endfunction

function! scala#LineCompletesXML(lnum, line)
  let savedpos = getpos('.')
  call setpos('.', [savedpos[0], a:lnum, 0, savedpos[3]])
  let tag = substitute(a:line, '^.*</\([^>]*\)>.*$', '\1', '')
  let [lineNum, colnum] = searchpairpos('<' . tag . '>', '', '</' . tag . '>', 'Wbn')
  call setpos('.', savedpos)
  let pline = scala#GetLine(prevnonblank(lineNum - 1))
  if pline =~ '=\s*$'
    return 1
  else
    return 0
  endif
endfunction

function! scala#IsParentCase()
  let savedpos = getpos('.')
  call setpos('.', [savedpos[0], savedpos[1], 0, savedpos[3]])
  let [l, c] = searchpos('^\s*\%(' . s:defMatcher . '\|\%(\<case\>\)\)', 'bnW')
  let retvalue = -1
  if l != 0 && search('\%' . l . 'l\s*\<case\>', 'bnW')
    let retvalue = l
  endif
  call setpos('.', savedpos)
  return retvalue
endfunction

function! scala#CurlyMatcher()
  let matchline = scala#GetLineThatMatchesBracket('{', '}')
  if scala#CountParens(scala#GetLine(matchline)) < 0
    let savedpos = getpos('.')
    call setpos('.', [savedpos[0], matchline, 9999, savedpos[3]])
    call searchpos('{', 'Wbc')
    call searchpos(')', 'Wb')
    let [lnum, colnum] = searchpairpos('(', '', ')', 'Wbn')
    call setpos('.', savedpos)
    let line = scala#GetLine(lnum)
    if line =~ '^\s*' . s:defMatcher
      return lnum
    else
      return matchline
    endif
  else
    return matchline
  endif
endfunction

function! scala#GetLineAndColumnThatMatchesCurly()
  return scala#GetLineAndColumnThatMatchesBracket('{', '}')
endfunction

function! scala#GetLineAndColumnThatMatchesParen()
  return scala#GetLineAndColumnThatMatchesBracket('(', ')')
endfunction

function! scala#GetLineAndColumnThatMatchesBracket(openBracket, closedBracket)
  let savedpos = getpos('.')
  let curline = scala#GetLine(line('.'))
  if curline =~ a:closedBracket . '.*' . a:openBracket . '.*' . a:closedBracket
    call setpos('.', [savedpos[0], savedpos[1], 0, savedpos[3]])
    call searchpos(a:closedBracket . '\ze[^' . a:closedBracket . a:openBracket . ']*' . a:openBracket, 'W')
  else
    call setpos('.', [savedpos[0], savedpos[1], 9999, savedpos[3]])
    call searchpos(a:closedBracket, 'Wbc')
  endif
  let [lnum, colnum] = searchpairpos(a:openBracket, '', a:closedBracket, 'Wbn')
  call setpos('.', savedpos)
  return [lnum, colnum]
endfunction

function! scala#GetLineThatMatchesCurly()
  return scala#GetLineThatMatchesBracket('{', '}')
endfunction

function! scala#GetLineThatMatchesParen()
  return scala#GetLineThatMatchesBracket('(', ')')
endfunction

function! scala#GetLineThatMatchesBracket(openBracket, closedBracket)
  let [lnum, colnum] = scala#GetLineAndColumnThatMatchesBracket(a:openBracket, a:closedBracket)
  return lnum
endfunction

function! scala#NumberOfBraceGroups(line)
  let line = substitute(a:line, '[^()]', '', 'g')
  if strlen(line) == 0
    return 0
  endif
  let line = substitute(line, '^)*', '', 'g')
  if strlen(line) == 0
    return 0
  endif
  let line = substitute(line, '^(', '', 'g')
  if strlen(line) == 0
    return 0
  endif
  let c = 1
  let counter = 0
  let groupCount = 0
  while counter < strlen(line)
    let char = strpart(line, counter, 1)
    if char == '('
      let c = c + 1
    elseif char == ')'
      let c = c - 1
    endif
    if c == 0
      let groupCount = groupCount + 1
    endif
    let counter = counter + 1
  endwhile
  return groupCount
endfunction

function! scala#MatchesIncompleteDefValr(line)
  if a:line =~ '^\s*\%(' . s:defMatcher . '\|' . s:valMatcher . '\).*[=({]\s*$'
    return 1
  else
    return 0
  endif
endfunction

function! scala#LineIsCompleteIf(line)
  if scala#CountBrackets(a:line, '{', '}') == 0 &&
   \ scala#CountBrackets(a:line, '(', ')') == 0 &&
   \ a:line =~ '^\s*\<if\>\s*([^)]*)\s*\S.*$'
    return 1
  else
    return 0
  endif
endfunction

function! scala#LineCompletesIfElse(lnum, line)
  if a:line =~ '^\s*\%(\<if\>\|\%(}\s*\)\?\<else\>\)'
    return 0
  endif
  let result = search('^\%(\s*\<if\>\s*(.*).*\n\|\s*\<if\>\s*(.*)\s*\n.*\n\)\%(\s*\<else\>\s*\<if\>\s*(.*)\s*\n.*\n\)*\%(\s*\<else\>\s*\n\|\s*\<else\>[^{]*\n\)\?\%' . a:lnum . 'l', 'Wbn')
  if result != 0 && scala#GetLine(prevnonblank(a:lnum - 1)) !~ '{\s*$'
    return result
  endif
  return 0
endfunction

function! scala#GetPrevCodeLine(lnum)
  " This needs to skip comment lines
  return prevnonblank(a:lnum - 1)
endfunction

function! scala#InvertBracketType(openBracket, closedBracket)
  if a:openBracket == '('
    return [ '{', '}' ]
  else
    return [ '(', ')' ]
  endif
endfunction

function! scala#Testhelper(lnum, line, openBracket, closedBracket, iteration)
  let bracketCount = scala#CountBrackets(a:line, a:openBracket, a:closedBracket)
  " There are more '}' braces than '{' on this line so it may be completing the function definition
  if bracketCount < 0
    let [matchedLNum, matchedColNum] = scala#GetLineAndColumnThatMatchesBracket(a:openBracket, a:closedBracket)
    if matchedLNum == a:lnum
      return -1
    endif
    let matchedLine = scala#GetLine(matchedLNum)
    if ! scala#MatchesIncompleteDefValr(matchedLine)
      let bracketLine = substitute(substitute(matchedLine, '\%' . matchedColNum . 'c.*$', '', ''), '[^{}()]', '', 'g')
      if bracketLine =~ '}$'
        return scala#Testhelper(matchedLNum, matchedLine, '{', '}', a:iteration + 1)
      elseif bracketLine =~ ')$'
        return scala#Testhelper(matchedLNum, matchedLine, '(', ')', a:iteration + 1)
      else
        let prevCodeLNum = scala#GetPrevCodeLine(matchedLNum)
        if scala#MatchesIncompleteDefValr(scala#GetLine(prevCodeLNum))
          return prevCodeLNum
        else
          return -1
        endif
      endif
    else
      " return indent value instead
      return matchedLNum
    endif
  " There's an equal number of '{' and '}' on this line so it may be a single line function definition
  elseif bracketCount == 0
    if a:iteration == 0
      let otherBracketType = scala#InvertBracketType(a:openBracket, a:closedBracket)
      return scala#Testhelper(a:lnum, a:line, otherBracketType[0], otherBracketType[1], a:iteration + 1)
    else
      let prevCodeLNum = scala#GetPrevCodeLine(a:lnum)
      let prevCodeLine = scala#GetLine(prevCodeLNum)
      if scala#MatchesIncompleteDefValr(prevCodeLine) && prevCodeLine !~ '{\s*$'
        return prevCodeLNum
      else
        let possibleIfElse = scala#LineCompletesIfElse(a:lnum, a:line)
        if possibleIfElse != 0
          let defValrLine = prevnonblank(possibleIfElse - 1)
          let possibleDefValr = scala#GetLine(defValrLine)
          if scala#MatchesIncompleteDefValr(possibleDefValr) && possibleDefValr =~ '^.*=\s*$'
            return possibleDefValr
          else
            return -1
          endif
        else
          return -1
        endif
      endif
    endif
  else
    return -1
  endif
endfunction

function! scala#Test(lnum, line, openBracket, closedBracket)
  return scala#Testhelper(a:lnum, a:line, a:openBracket, a:closedBracket, 0)
endfunction

function! scala#LineCompletesDefValr(lnum, line)
  let bracketCount = scala#CountBrackets(a:line, '{', '}')
  if bracketCount < 0
    let matchedBracket = scala#GetLineThatMatchesBracket('{', '}')
    if ! scala#MatchesIncompleteDefValr(scala#GetLine(matchedBracket))
      let possibleDefValr = scala#GetLine(prevnonblank(matchedBracket - 1))
      if matchedBracket != -1 && scala#MatchesIncompleteDefValr(possibleDefValr)
        return 1
      else
        return 0
      endif
    else
      return 0
    endif
  elseif bracketCount == 0
    let bracketCount = scala#CountBrackets(a:line, '(', ')')
    if bracketCount < 0
      let matchedBracket = scala#GetLineThatMatchesBracket('(', ')')
      if ! scala#MatchesIncompleteDefValr(scala#GetLine(matchedBracket))
        let possibleDefValr = scala#GetLine(prevnonblank(matchedBracket - 1))
        if matchedBracket != -1 && scala#MatchesIncompleteDefValr(possibleDefValr)
          return 1
        else
          return 0
        endif
      else
        return 0
      endif
    elseif bracketCount == 0
      let possibleDefValr = scala#GetLine(prevnonblank(a:lnum - 1))
      if scala#MatchesIncompleteDefValr(possibleDefValr) && possibleDefValr =~ '^.*=\s*$'
        return 1
      else
        let possibleIfElse = scala#LineCompletesIfElse(a:lnum, a:line)
        if possibleIfElse != 0
          let possibleDefValr = scala#GetLine(prevnonblank(possibleIfElse - 1))
          if scala#MatchesIncompleteDefValr(possibleDefValr) && possibleDefValr =~ '^.*=\s*$'
            return 2
          else
            return 0
          endif
        else
          return 0
        endif
      endif
    else
      return 0
    endif
  endif
endfunction

function! scala#SpecificLineCompletesBrackets(lnum, openBracket, closedBracket)
  let savedpos = getpos('.')
  call setpos('.', [savedpos[0], a:lnum, 9999, savedpos[3]])
  let retv = scala#LineCompletesBrackets(a:openBracket, a:closedBracket)
  call setpos('.', savedpos)

  return retv
endfunction

function! scala#LineCompletesBrackets(openBracket, closedBracket)
  let savedpos = getpos('.')
  let offline = 0
  while offline == 0
    let [lnum, colnum] = searchpos(a:closedBracket, 'Wb')
    let [lnumA, colnumA] = searchpairpos(a:openBracket, '', a:closedBracket, 'Wbn')
    if lnum != lnumA
      let [lnumB, colnumB] = searchpairpos(a:openBracket, '', a:closedBracket, 'Wbnr')
      let offline = 1
    endif
  endwhile
  call setpos('.', savedpos)
  if lnumA == lnumB && colnumA == colnumB
    return lnumA
  else
    return -1
  endif
endfunction

function! GetScalaIndent()
  " Find a non-blank line above the current line.
  let prevlnum = prevnonblank(v:lnum - 1)

  " Hit the start of the file, use zero indent.
  if prevlnum == 0
    return 0
  endif

  let ind = indent(prevlnum)
  let originalIndentValue = ind
  let prevline = scala#GetLine(prevlnum)
  let curlnum = v:lnum
  let curline = scala#GetLine(curlnum)
  if get(g:, 'scala_scaladoc_indent', 0)
    let star_indent = 2
  else
    let star_indent = 1
  end

  if prevline =~ '^\s*/\*\*'
    if prevline =~ '\*/\s*$'
      retur*  +  ,  -  .  /  0  1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  n ind
    else
      return ind + star_indent
    endif
  endif

  if curline =~ '^\s*\*'
    return cindent(curlnum)
  endif

  " If this line starts with a { then make it indent the same as the previous line
  if curline =~ '^\s*{'
    call scala#ConditionalConfirm("1")
    " Unless, of course, the previous one is a { as well
    if prevline !~ '^\s*{'
      call scala#ConditionalConfirm("2")
      return indent(prevlnum)
    endif
  endif

  " '.' continuations
  if curline =~ '^\s*\.'
    if prevline =~ '^\s*\.'
      return ind
    else
      return ind + shiftwidth()
    endif
  endif

  " Indent html literals
  if prevline !~ '/>\s*$' && prevline =~ '^\s*<[a-zA-Z][^>]*>\s*$'
    call scala#ConditionalConfirm("3")
    return ind + shiftwidth()
  endif

  " assumes curly braces around try-block
  if curline =~ '^\s*}\s*\<catch\>'
    return ind - shiftwidth()
  elseif curline =~ '^\s*\<catch\>'
    return ind
  endif

  " Add a shiftwidth()' after lines that start a block
  " If 'if', 'for' or 'while' end with ), this is a one-line block
  " If 'val', 'var', 'def' end with =, this is a one-line block
  if (prevline =~ '^\s*\<\%(\%(}\?\s*else\s\+\)\?if\|for\|while\)\>.*[)=]\s*$' && scala#NumberOfBraceGroups(prevline) <= 1)
        \ || prevline =~ '^\s*' . s:defMatcher . '.*=\s*$'
        \ || prevline =~ '^\s*' . s:valMatcher . '.*[=]\s*$'
        \ || prevline =~ '^\s*\%(}\s*\)\?\<else\>\s*$'
        \ || prevline =~ '=\s*$'
    call scala#ConditionalConfirm("4")
    let ind = ind + shiftwidth()
  elseif prevline =~ '^\s*\<\%(}\?\s*else\s\+\)\?if\>' && curline =~ '^\s*}\?\s*\<else\>'
    return ind
  endif

  let lineCompletedBrackets = 0
  let bracketCount = scala#CountBrackets(prevline, '{', '}')
  if bracketCount > 0 || prevline =~ '.*{\s*$'
    call scala#ConditionalConfirm("5b")
    let ind = ind + shiftwidth()
  elseif bracketCount < 0
    call scala#ConditionalConfirm("6b")
    " if the closing brace actually completes the braces entirely, then we
    " have to indent to line that started the whole thing
    let completeLine = scala#LineCompletesBrackets('{', '}')
    if completeLine != -1
      call scala#ConditionalConfirm("8b")
      let prevCompleteLine = scala#GetLine(prevnonblank(completeLine - 1))
      " However, what actually started this part looks like it was a function
      " definition, so we need to indent to that line instead.  This is
      " actually pretty weak at the moment.
      if prevCompleteLine =~ '=\s*$'
        call scala#ConditionalConfirm("9b")
        let ind = indent(prevnonblank(completeLine - 1))
      else
        call scala#ConditionalConfirm("10b")
        let ind = indent(completeLine)
      endif
    else
      let lineCompletedBrackets = 1
    endif
  endif

  if ind == originalIndentValue
    let bracketCount = scala#CountBrackets(prevline, '(', ')')
    if bracketCount > 0 || prevline =~ '.*(\s*$'
      call scala#ConditionalConfirm("5a")
      let ind = ind + shiftwidth()
    elseif bracketCount < 0
      call scala#ConditionalConfirm("6a")
      " if the closing brace actually completes the braces entirely, then we
      " have to indent to line that started the whole thing
      let completeLine = scala#LineCompletesBrackets('(', ')')
      if completeLine != -1 && prevline !~ '^.*{\s*$'
        call scala#ConditionalConfirm("8a")
        let prevCompleteLine = scala#GetLine(prevnonblank(completeLine - 1))
        " However, what actually started this part looks like it was a function
        " definition, so we need to indent to that line instead.  This is
        " actually pretty weak at the moment.
        if prevCompleteLine =~ '=\s*$'
          call scala#ConditionalConfirm("9a")
          let ind = indent(prevnonblank(completeLine - 1))
        else
          call scala#ConditionalConfirm("10a")
          let ind = indent(completeLine)
        endif
      else
        " This is the only part that's different from from the '{', '}' one below
        " Yup... some refactoring is necessary at some point.
        let ind = ind + (bracketCount * shiftwidth())
        let lineCompletedBrackets = 1
      endif
    endif
  endif

  if curline =~ '^\s*}\?\s*\<else\>\%(\s\+\<if\>\s*(.*)\)\?\s*{\?\s*$' &&
   \ ! scala#LineIsCompleteIf(prevline) &&
   \ prevline !~ '^.*}\s*$'
    let ind = ind - shiftwidth()
  endif

  " Subtract a shiftwidth()' on '}' or html
  let curCurlyCount = scala#CountCurlies(curline)
  if curCurlyCount < 0
    call scala#ConditionalConfirm("14a")
    let matchline = scala#CurlyMatcher()
    return indent(matchline)
  elseif curline =~ '^\s*</[a-zA-Z][^>]*>'
    call scala#ConditionalConfirm("14c")
    return ind - shiftwidth()
  endif

  let prevParenCount = scala#CountParens(prevline)
  if prevline =~ '^\s*\<for\>.*$' && prevParenCount > 0
    call scala#ConditionalConfirm("15")
    let ind = indent(prevlnum) + 5
  endif

  let prevCurlyCount = scala#CountCurlies(prevline)
  if prevCurlyCount == 0 && prevline =~ '^.*\%(=>\|â‡’\)\s*$' && prevline !~ '^\s*this\s*:.*\%(=>\|â‡’\)\s*$' && curline !~ '^\s*\<case\>'
    call scala#ConditionalConfirm("16")
    let ind = ind + shiftwidth()
  endif

  if ind == originalIndentValue && curline =~ '^\s*\<case\>'
    call scala#ConditionalConfirm("17")
    let parentCase = scala#IsParentCase()
    if parentCase != -1
      call scala#ConditionalConfirm("17a")
      return indent(parentCase)
    endif
  endif

  if prevline =~ '^\s*\*/'
   \ || prevline =~ '*/\s*$'
    call scala#ConditionalConfirm("18")
    let ind = ind - star_indent
  endif

  if scala#LineEndsInIncomplete(prevline)
    call scala#ConditionalConfirm("19")
    return ind
  endif

  if scala#LineIsAClosingXML(prevline)
    if scala#LineCompletesXML(prevlnum, prevline)
      call scala#ConditionalConfirm("20a")
      return ind - shiftwidth()
    else
      call scala#ConditionalConfirm("20b")
      return ind
    endif
  endif

  if ind == originalIndentValue
    "let indentMultiplier = scala#LineCompletesDefValr(prevlnum, prevline)
    "if indentMultiplier != 0
    "  call scala#ConditionalConfirm("19a")
    "  let ind = ind - (indentMultiplier * shiftwidth())
    let defValrLine = scala#Test(prevlnum, prevline, '{', '}')
    if defValrLine != -1
      call scala#ConditionalConfirm("21a")
      let ind = indent(defValrLine)
    elseif lineCompletedBrackets == 0
      call scala#ConditionalConfirm("21b")
      if scala#GetLine(prevnonblank(prevlnum - 1)) =~ '^.*\<else\>\s*\%(//.*\)\?$'
        call scala#ConditionalConfirm("21c")
        let ind = ind - shiftwidth()
      elseif scala#LineCompletesIfElse(prevlnum, prevline)
        call scala#ConditionalConfirm("21d")
        let ind = ind - shiftwidth()
      elseif scala#CountParens(curline) < 0 && curline =~ '^\s*)' && scala#GetLine(scala#GetLineThatMatchesBracket('(', ')')) =~ '.*(\s*$'
        " Handles situations that look like this:
        "
        "   val a = func(
        "     10
        "   )
        "
        " or
        "
        "   val a = func(
        "     10
        "   ).somethingHere()
        call scala#ConditionalConfirm("21e")
        let ind = ind - shiftwidth()
      endif
    endif
  endif

  call scala#ConditionalConfirm("returning " . ind)

  return ind
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:set sw=2 sts=2 ts=8 et:
" vim600:fdm=marker fdl=1 fdc=0:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        " Vim indent file
" Language: Scheme
" Last Change: 2018 Jan 31
" Maintainer: Evan Hanson <evhan@foldling.org>
" Previous Maintainer: Sergey Khorev <sergey.khorev@gmail.com>
" URL: https://foldling.org/vim/indent/scheme.vim

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Use the Lisp indenting
runtime! indent/lisp.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim indent file
" Language:	SCSS
" Maintainer:	Tim Pope <vimNOSPAM@tpope.org>
" Last Change:	2010 Jul 26

if exists("b:did_indent")
  finish
endif

runtime! indent/css.vim

" vim:set sw=2:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim indent file
" Language:	SDL
" Maintainer:	Michael Piefel <entwurf@piefel.de>
" Last Change:	2021 Oct 03

" Shamelessly stolen from the Vim-Script indent file

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetSDLIndent()
setlocal indentkeys+==~end,=~state,*<Return>

let b:undo_indent = "setl inde< indk<"

" Only define the function once.
if exists("*GetSDLIndent")
"  finish
endif

let s:cpo_save = &cpo
set cpo&vim

function! GetSDLIndent()
  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  let ind = indent(lnum)
  let virtuality = '^\s*\(\(virtual\|redefined\|finalized\)\s\+\)\=\s*'

  " Add a single space to comments which use asterisks
  if getline(lnum) =~ '^\s*\*'
    let ind = ind - 1
  endif
  if getline(v:lnum) =~ '^\s*\*'
    let ind = ind + 1
  endif

  " Add a 'shiftwidth' after states, different blocks, decision (and alternatives), inputs
  if (getline(lnum) =~? '^\s*\(start\|state\|system\|package\|connection\|channel\|alternative\|macro\|operator\|newtype\|select\|substructure\|decision\|generator\|refinement\|service\|method\|exceptionhandler\|asntype\|syntype\|value\|(.*):\|\(priority\s\+\)\=input\|provided\)'
    \ || getline(lnum) =~? virtuality . '\(process\|procedure\|block\|object\)')
    \ && getline(lnum) !~? 'end[[:alpha:]]\+;$'
    let ind = ind + shiftwidth()
  endif

  " Subtract a 'shiftwidth' after states
  if getline(lnum) =~? '^\s*\(stop\|return\>\|nextstate\)'
    let ind = ind - shiftwidth()
  endif

  " Subtract a 'shiftwidth' on on end (uncompleted line)
  if getline(v:lnum) =~? '^\s*end\>'
    let ind = ind - shiftwidth()
  endif

  " Put each alternatives where the corresponding decision was
  if getline(v:lnum) =~? '^\s*\((.*)\|else\):'
    normal k
    let ind = indent(searchpair('^\s*decision', '', '^\s*enddecision', 'bW',
      \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "sdlString"'))
  endif

  " Put each state where the preceding state was
  if getline(v:lnum) =~? '^\s*state\>'
    let ind = indent(search('^\s*start', 'bW'))
  endif

  " Systems and packages are always in column 0
  if getline(v:lnum) =~? '^\s*\(\(end\)\=system\|\(end\)\=package\)'
    return 0
  endif

  " Put each end* where the corresponding begin was
  if getline(v:lnum) =~? '^\s*end[[:alpha:]]'
    normal k
    let partner=matchstr(getline(v:lnum), '\(' . virtuality . 'end\)\@<=[[:alpha:]]\+')
    let ind = indent(searchpair(virtuality . partner, '', '^\s*end' . partner, 'bW',
      \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "sdlString"'))
  endif

  return ind
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save

" vim:sw=2
                                                                                                                                                                                                                                                   " Vim indent file
" Language:            Shell Script
" Maintainer:          Christian Brabandt <cb@256bit.org>
" Original Author:     Nikolai Weibull <now@bitwi.se>
" Previous Maintainer: Peter Aronoff <telemachus@arpinum.org>
" Latest Revision:     2019-10-24
" License:             Vim (see :h license)
" Repository:          https://github.com/chrisbra/vim-sh-indent
" Changelog:
"          20190726  - Correctly skip if keywords in syntax comments
"                      (issue #17)
"          20190603  - Do not indent in zsh filetypes with an `if` in comments
"          20190428  - De-indent fi correctly when typing with
"                      https://github.com/chrisbra/vim-sh-indent/issues/15
"          20190325  - Indent fi; correctly
"                      https://github.com/chrisbra/vim-sh-indent/issues/14
"          20190319  - Indent arrays (only zsh and bash)
"                      https://github.com/chrisbra/vim-sh-indent/issues/13
"          20190316  - Make use of searchpairpos for nested if sections
"                      fixes https://github.com/chrisbra/vim-sh-indent/issues/11
"          20190201  - Better check for closing if sections
"          20180724  - make check for zsh syntax more rigid (needs word-boundaries)
"          20180326  - better support for line continuation
"          20180325  - better detection of function definitions
"          20180127  - better support for zsh complex commands
"          20170808: - better indent of line continuation
"          20170502: - get rid of buffer-shiftwidth function
"          20160912: - preserve indentation of here-doc blocks
"          20160627: - detect heredocs correctly
"          20160213: - detect function definition correctly
"          20160202: - use shiftwidth() function
"          20151215: - set b:undo_indent variable
"          20150728: - add foreach detection for zsh

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetShIndent()
setlocal indentkeys+=0=then,0=do,0=else,0=elif,0=fi,0=esac,0=done,0=end,),0=;;,0=;&
setlocal indentkeys+=0=fin,0=fil,0=fip,0=fir,0=fix
setlocal indentkeys-=:,0#
setlocal nosmartindent

let b:undo_indent = 'setlocal indentexpr< indentkeys< smartindent<'

if exists("*GetShIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

let s:sh_indent_defaults = {
      \ 'default': function('shiftwidth'),
      \ 'continuation-line': function('shiftwidth'),
      \ 'case-labels': function('shiftwidth'),
      \ 'case-statements': function('shiftwidth'),
      \ 'case-breaks': 0 }

function! s:indent_value(option)
  let Value = exists('b:sh_indent_options')
            \ && has_key(b:sh_indent_options, a:option) ?
            \ b:sh_indent_options[a:option] :
            \ s:sh_indent_defaults[a:option]
  if type(Value) == type(function('type'))
    return Value()
  endif
  return Value
endfunction

function! GetShIndent()
  let curline = getline(v:lnum)
  let lnum = prevnonblank(v:lnum - 1)
  if lnum == 0
    return 0
  endif
  let line = getline(lnum)

  let pnum = prevnonblank(lnum - 1)
  let pline = getline(pnum)
  let ind = indent(lnum)

  " Check contents of previous lines
  " should not apply to e.g. commented lines
  if line =~ '^\s*\%(if\|then\|do\|else\|elif\|case\|while\|until\|for\|select\|foreach\)\>' ||
        \  (&ft is# 'zsh' && line =~ '^\s*\<\%(if\|then\|do\|else\|elif\|case\|while\|until\|for\|select\|foreach\)\>')
    if !s:is_end_expression(line)
      let ind += s:indent_value('default')
    endif
  elseif s:is_case_label(line, pnum)
    if !s:is_case_ended(line)
      let ind += s:indent_value('case-statements')
    endif
  " function definition
  elseif s:is_function_definition(line)
    if line !~ '}\s*\%(#.*\)\=$'
      let ind += s:indent_value('default')
    endif
  " array (only works for zsh or bash)
  elseif s:is_array(line) && line !~ ')\s*$' && (&ft is# 'zsh' || s:is_bash())
      let ind += s:indent_value('continuation-line')
  " end of array
  elseif curline =~ '^\s*)$'
      let ind -= s:indent_value('continuation-line')
  elseif s:is_continuation_line(line)
    if pnum == 0 || !s:is_continuation_line(pline)
      let ind += s:indent_value('continuation-line')
    endif
  elseif s:end_block(line) && !s:start_block(line)
    let ind -= s:indent_value('default')
  elseif pnum != 0 &&
        \ s:is_continuation_line(pline) &&
        \ !s:end_block(curline) &&
        \ !s:is_end_expression(curline)
    " only add indent, if line and pline is in the same block
    let i = v:lnum
    let ind2 = indent(s:find_continued_lnum(pnum))
    while !s:is_empty(getline(i)) && i > pnum
      let i -= 1
    endw
    if i == pnum
      let ind += ind2
    else
      let ind = ind2
    endif
  endif

  let pine = line
  " Check content of current line
  let line = curline
  " Current line is a endif line, so get indent from start of "if condition" line
  " TODO: should we do the same for other "end" lines?
  if curline =~ '^\s*\%(fi\);\?\s*\%(#.*\)\=$'
    let ind = indent(v:lnum)
    let previous_line = searchpair('\<if\>', '', '\<fi\>\zs', 'bnW', 'synIDattr(synID(line("."),col("."), 1),"name") =~? "comment\\|quote"')
    if previous_line > 0
      let ind = indent(previous_line)
    endif
  elseif line =~ '^\s*\%(then\|do\|else\|elif\|done\|end\)\>' || s:end_block(line)
    let ind -= s:indent_value('default')
  elseif line =~ '^\s*esac\>' && s:is_case_empty(getline(v:lnum - 1))
    let ind -= s:indent_value('default')
  elseif line =~ '^\s*esac\>'
    let ind -= (s:is_case_label(pine, lnum) && s:is_case_ended(pine) ?
             \ 0 : s:indent_value('case-statements')) +
             \ s:indent_value('case-labels')
    if s:is_case_break(pine)
      let ind += s:indent_value('case-breaks')
    endif
  elseif s:is_case_label(line, lnum)
    if s:is_case(pine)
      let ind = indent(lnum) + s:indent_value('case-labels')
    else
      let ind -= (s:is_case_label(pine, lnum) && s:is_case_ended(pine) ?
                  \ 0 : s:indent_value('case-statements')) -
                  \ s:indent_value('case-breaks')
    endif
  elseif s:is_case_break(line)
    let ind -= s:indent_value('case-breaks')
  elseif s:is_here_doc(line)
    let ind = 0
  " statements, executed within a here document. Keep the current indent
  elseif match(map(synstack(v:lnum, 1), 'synIDattr(v:val, "name")'), '\c\mheredoc') > -1
    return indent(v:lnum)
  elseif s:is_comment(line) && s:is_empty(getline(v:lnum-1))
    return indent(v:lnum)
  endif

  return ind > 0 ? ind : 0
endfunction

function! s:is_continuation_line(line)
  " Comment, cannot be a line continuation
  if a:line =~ '^\s*#'
    return 0
  else
    " start-of-line
    " \\ or && or || or |
    " followed optionally by { or #
    return a:line =~ '\%(\%(^\|[^\\]\)\\\|&&\|||\||\)' .
                 \ '\s*\({\s*\)\=\(#.*\)\=$'
  endif
endfunction

function! s:find_continued_lnum(lnum)
  let i = a:lnum
  while i > 1 && s:is_continuation_line(getline(i - 1))
    let i -= 1
  endwhile
  return i
endfunction

function! s:is_function_definition(line)
  return a:line =~ '^\s*\<\k\+\>\s*()\s*{' ||
       \ a:line =~ '^\s*{' ||
       \ a:line =~ '^\s*function\s*\k\+\s*\%(()\)\?\s*{'
endfunction

function! s:is_array(line)
  return a:line =~ '^\s*\<\k\+\>=('
endfunction

function! s:is_case_label(line, pnum)
  if a:line !~ '^\s*(\=.*)'
    return 0
  endif

  if a:pnum > 0
    let pine = getline(a:pnum)
    if !(s:is_case(pine) || s:is_case_ended(pine))
      return 0
    endif
  endif

  let suffix = substitute(a:line, '^\s*(\=', "", "")
  let nesting = 0
  let i = 0
  let n = strlen(suffix)
  while i < n
    let c = suffix[i]
    let i += 1
    if c == '\\'
      let i += 1
    elseif c == '('
      let nesting += 1
    elseif c == ')'
      if nesting == 0
        return 1
      endif
      let nesting -= 1
    endif
  endwhile
  return 0
endfunction

function! s:is_case(line)
  return a:line =~ '^\s*case\>'
endfunction

function! s:is_case_break(line)
  return a:line =~ '^\s*;[;&]'
endfunction

function! s:is_here_doc(line)
    if a:line =~ '^\w\+$'
      let here_pat = '<<-\?'. s:escape(a:line). '\$'
      return search(here_pat, 'bnW') > 0
    endif
    return 0
endfunction

function! s:is_case_ended(line)
  return s:is_case_break(a:line) || a:line =~ ';[;&]\s*\%(#.*\)\=$'
endfunction

function! s:is_case_empty(line)
  if a:line =~ '^\s*$' || a:line =~ '^\s*#'
    return s:is_case_empty(getline(v:lnum - 1))
  else
    return a:line =~ '^\s*case\>'
  endif
endfunction

function! s:escape(pattern)
    return '\V'. escape(a:pattern, '\\')
endfunction

function! s:is_empty(line)
  return a:line =~ '^\s*$'
endfunction

function! s:end_block(line)
  return a:line =~ '^\s*}'
endfunction

function! s:start_block(line)
  return a:line =~ '{\s*\(#.*\)\?$'
endfunction

function! s:find_start_block(lnum)
  let i = a:lnum
  while i > 1 && !s:start_block(getline(i))
    let i -= 1
  endwhile
  return i
endfunction

function! s:is_comment(line)
  return a:line =~ '^\s*#'
endfunction

function! s:is_end_expression(line)
  return a:line =~ '\<\%(fi\|esac\|done\|end\)\>\s*\%(#.*\)\=$'
endfunction

function! s:is_bash()
  return get(g:, 'is_bash', 0) || get(b:, 'is_bash', 0)
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         " Vim indent file
" Language:     SML
" Maintainer:	Saikat Guha <sg266@cornell.edu>
" 				Hubert Chao <hc85@cornell.edu>
" Original OCaml Version:
" 				Jean-Francois Yuen  <jfyuen@ifrance.com>
"               Mike Leary          <leary@nwlink.com>
"               Markus Mottl        <markus@oefai.at>
" OCaml URL:    http://www.oefai.at/~markus/vim/indent/ocaml.vim
" Last Change:  2003 Jan 04	- Adapted to SML
" 				2002 Nov 06 - Some fixes (JY)
"               2002 Oct 28 - Fixed bug with indentation of ']' (MM)
"               2002 Oct 22 - Major rewrite (JY)

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal expandtab
setlocal indentexpr=GetSMLIndent()
setlocal indentkeys+=0=and,0=else,0=end,0=handle,0=if,0=in,0=let,0=then,0=val,0=fun,0=\|,0=*),0)
setlocal nolisp
setlocal nosmartindent
setlocal textwidth=80
setlocal shiftwidth=2

" Comment formatting
if (has("comments"))
  set comments=sr:(*,mb:*,ex:*)
  set fo=cqort
endif

" Only define the function once.
"if exists("*GetSMLIndent")
"finish
"endif

" Define some patterns:
let s:beflet = '^\s*\(initializer\|method\|try\)\|\(\<\(begin\|do\|else\|in\|then\|try\)\|->\|;\)\s*$'
let s:letpat = '^\s*\(let\|type\|module\|class\|open\|exception\|val\|include\|external\)\>'
let s:letlim = '\(\<\(sig\|struct\)\|;;\)\s*$'
let s:lim = '^\s*\(exception\|external\|include\|let\|module\|open\|type\|val\)\>'
let s:module = '\<\%(let\|sig\|struct\)\>'
let s:obj = '^\s*\(constraint\|inherit\|initializer\|method\|val\)\>\|\<\(object\|object\s*(.*)\)\s*$'
let s:type = '^\s*\%(let\|type\)\>.*='
let s:val = '^\s*\(val\|external\)\>.*:'

" Skipping pattern, for comments
function! s:SkipPattern(lnum, pat)
  let def = prevnonblank(a:lnum - 1)
  while def > 0 && getline(def) =~ a:pat
    let def = prevnonblank(def - 1)
  endwhile
  return def
endfunction

" Indent for ';;' to match multiple 'let'
function! s:GetInd(lnum, pat, lim)
  let llet = search(a:pat, 'bW')
  let old = indent(a:lnum)
  while llet > 0
    let old = indent(llet)
    let nb = s:SkipPattern(llet, '^\s*(\*.*\*)\s*$')
    if getline(nb) =~ a:lim
      return old
    endif
    let llet = search(a:pat, 'bW')
  endwhile
  return old
endfunction

" Indent pairs
function! s:FindPair(pstart, pmid, pend)
  call search(a:pend, 'bW')
"  return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"'))
  let lno = searchpair(a:pstart, a:pmid, a:pend, 'bW', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
  if lno == -1
	return indent(lno)
  else
	return col(".") - 1
  endif
endfunction

function! s:FindLet(pstart, pmid, pend)
  call search(a:pend, 'bW')
"  return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"'))
  let lno = searchpair(a:pstart, a:pmid, a:pend, 'bW', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
  let moduleLine = getline(lno)
  if lno == -1 || moduleLine =~ '^\s*\(fun\|structure\|signature\)\>'
	return indent(lno)
  else
	return col(".") - 1
  endif
endfunction

" Indent 'let'
"function! s:FindLet(pstart, pmid, pend)
"  call search(a:pend, 'bW')
"  return indent(searchpair(a:pstart, a:pmid, a:pend, 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment" || getline(".") =~ "^\\s*let\\>.*=.*\\<in\\s*$" || getline(prevnonblank(".") - 1) =~ "^\\s*let\\>.*=\\s*$\\|" . s:beflet'))
"endfunction

function! GetSMLIndent()
  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  let ind = indent(lnum)
  let lline = getline(lnum)

	" Return double 'shiftwidth' after lines matching:
	if lline =~ '^\s*|.*=>\s*$'
		return ind + 2 *shiftwidth()
	elseif lline =~ '^\s*val\>.*=\s*$'
		return ind + shiftwidth()
	endif

  let line = getline(v:lnum)

	" Indent lines starting with 'end' to matching module
	if line =~ '^\s*end\>'
		return s:FindLet(s:module, '', '\<end\>')

	" Match 'else' with 'if'
	elseif line =~ '^\s*else\>'
	  	if lline !~ '^\s*\(if\|else\|then\)\>'
				return s:FindPair('\<if\>', '', '\<then\>')
	  	else
		  return ind
		endif

	" Match 'then' with 'if'
	elseif line =~ '^\s*then\>'
  	if lline !~ '^\s*\(if\|else\|then\)\>'
		  return s:FindPair('\<if\>', '', '\<then\>')
	else
	  return ind
	endif

	" Indent if current line begins with ']'
	elseif line =~ '^\s*\]'
		return s:FindPair('\[','','\]')

  " Indent current line starting with 'in' to last matching 'let'
	elseif line =~ '^\s*in\>'
		let ind = s:FindLet('\<let\>','','\<in\>')

	" Indent from last matching module if line matches:
	elseif line =~ '^\s*\(fun\|val\|open\|structure\|and\|datatype\|type\|exception\)\>'
		cursor(lnum,1)
  		let lastModule = indent(searchpair(s:module, '', '\<end\>', 'bWn', 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"'))
		if lastModule == -1
			return 0
		else
			return lastModule + shiftwidth()
		endif

	" Indent lines starting with '|' from matching 'case', 'handle'
	elseif line =~ '^\s*|'
		" cursor(lnum,1)
		let lastSwitch = search('\<\(case\|handle\|fun\|datatype\)\>','bW')
		let switchLine = getline(lastSwitch)
		let switchLineIndent = indent(lastSwitch)
		if lline =~ '^\s*|'
		  return ind
		endif
		if switchLine =~ '\<case\>'
			return col(".") + 2
		elseif switchLine =~ '\<handle\>'
			return switchLineIndent + shiftwidth()
		elseif switchLine =~ '\<datatype\>'
			call search('=')
			return col(".") - 1
		else
			return switchLineIndent + 2
		endif


  " Indent if last line ends with 'sig', 'struct', 'let', 'then', 'else',
  " 'in'
  elseif lline =~ '\<\(sig\|struct\|let\|in\|then\|else\)\s*$'
		let ind = ind + shiftwidth()

  " Indent if last line ends with 'of', align from 'case'
  elseif lline =~ '\<\(of\)\s*$'
		call search('\<case\>',"bW")
		let ind = col(".")+4

	" Indent if current line starts with 'of'
  elseif line =~ '^\s*of\>'
		call search('\<case\>',"bW")
		let ind = col(".")+1


	" Indent if last line starts with 'fun', 'case', 'fn'
	elseif lline =~ '^\s*\(fun\|fn\|case\)\>'
		let ind = ind + shiftwidth()

	endif

	" Don't indent 'let' if last line started with 'fun', 'fn'
	if line =~ '^\s*let\>'
		if lline =~ '^\s*\(fun\|fn\)'
			let ind = ind - shiftwidth()
		endif
  endif

  return ind

endfunction

" vim:sw=2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim indent file loader
" Language:    SQL
" Maintainer:  David Fishburn <fishburn at ianywhere dot com>
" Last Change: Thu Sep 15 2005 10:27:51 AM
" Version:     1.0
" Download:    http://vim.sourceforge.net/script.php?script_id=495

" Description: Checks for a:
"                  buffer local variable,
"                  global variable,
"              If the above exist, it will source the type specified.
"              If none exist, it will source the default sqlanywhere.vim file.


" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif

" Default to the standard Vim distribution file
let filename = 'sqlanywhere'

" Check for overrides.  Buffer variables have the highest priority.
if exists("b:sql_type_override")
    " Check the runtimepath to see if the file exists
    if globpath(&runtimepath, 'indent/'.b:sql_type_override.'.vim') != ''
        let filename = b:sql_type_override
    endif
elseif exists("g:sql_type_default")
    if globpath(&runtimepath, 'indent/'.g:sql_type_default.'.vim') != ''
        let filename = g:sql_type_default
    endif
endif

" Source the appropriate file
exec 'runtime indent/'.filename.'.vim'


" vim:sw=4:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim indent file
" Language:    SQL
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Last Change: 2021 Oct 11
" Version:     4.0
" Download:    http://vim.sourceforge.net/script.php?script_id=495

" Notes:
"    Indenting keywords are based on Oracle and Sybase Adaptive Server
"    Anywhere (ASA).  Test indenting was done with ASA stored procedures and
"    functions and Oracle packages which contain stored procedures and
"    functions.
"    This has not been tested against Microsoft SQL Server or
"    Sybase Adaptive Server Enterprise (ASE) which use the Transact-SQL
"    syntax.  That syntax does not have end tags for IF's, which makes
"    indenting more difficult.
"
" Known Issues:
"    The Oracle MERGE statement does not have an end tag associated with
"    it, this can leave the indent hanging to the right one too many.
"
" History:
"    4.0 (Oct 2021)
"        Added b:undo_indent
"
"    3.0 (Dec 2012)
"        Added cpo check
"
"    2.0
"        Added the FOR keyword to SQLBlockStart to handle (Alec Tica):
"            for i in 1..100 loop
"              |<-- I expect to have indentation here
"            end loop;
"

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent     = 1
let b:current_indent = "sqlanywhere"

setlocal indentkeys-=0{
setlocal indentkeys-=0}
setlocal indentkeys-=:
setlocal indentkeys-=0#
setlocal indentkeys-=e

" This indicates formatting should take place when one of these
" expressions is used.  These expressions would normally be something
" you would type at the BEGINNING of a line
" SQL is generally case insensitive, so this files assumes that
" These keywords are something that would trigger an indent LEFT, not
" an indent right, since the SQLBlockStart is used for those keywords
setlocal indentkeys+==~end,=~else,=~elseif,=~elsif,0=~when,0=)

" GetSQLIndent is executed whenever one of the expressions
" in the indentkeys is typed
setlocal indentexpr=GetSQLIndent()

let b:undo_indent = "setl indentexpr< indentkeys<"

" Only define the functions once.
if exists("*GetSQLIndent")
    finish
endif

let s:keepcpo= &cpo
set cpo&vim

" List of all the statements that start a new block.
" These are typically words that start a line.
" IS is excluded, since it is difficult to determine when the
" ending block is (especially for procedures/functions).
let s:SQLBlockStart = '^\s*\%('.
                \ 'if\|else\|elseif\|elsif\|'.
                \ 'while\|loop\|do\|for\|'.
                \ 'begin\|'.
                \ 'case\|when\|merge\|exception'.
                \ '\)\>'
let s:SQLBlockEnd = '^\s*\(end\)\>'

" The indent level is also based on unmatched parentheses
" If a line has an extra "(" increase the indent
" If a line has an extra ")" decrease the indent
function! s:CountUnbalancedParen( line, paren_to_check )
    let l = a:line
    let lp = substitute(l, '[^(]', '', 'g')
    let l = a:line
    let rp = substitute(l, '[^)]', '', 'g')

    if a:paren_to_check =~ ')'
        " echom 'CountUnbalancedParen ) returning: ' .
        " \ (strlen(rp) - strlen(lp))
        return (strlen(rp) - strlen(lp))
    elseif a:paren_to_check =~ '('
        " echom 'CountUnbalancedParen ( returning: ' .
        " \ (strlen(lp) - strlen(rp))
        return (strlen(lp) - strlen(rp))
    else
        " echom 'CountUnbalancedParen unknown paren to check: ' .
        " \ a:paren_to_check
        return 0
    endif
endfunction

" Unindent commands based on previous indent level
function! s:CheckToIgnoreRightParen( prev_lnum, num_levels )
    let lnum = a:prev_lnum
    let line = getline(lnum)
    let ends = 0
    let num_right_paren = a:num_levels
    let ignore_paren = 0
    let vircol = 1

    while num_right_paren > 0
        silent! exec 'norm! '.lnum."G\<bar>".vircol."\<bar>"
        let right_paren = search( ')', 'W' )
        if right_paren != lnum
            " This should not happen since there should be at least
            " num_right_paren matches for this line
            break
        endif
        let vircol      = virtcol(".")

        " if getline(".") =~ '^)'
        let matching_paren = searchpair('(', '', ')', 'bW',
                    \ 's:IsColComment(line("."), col("."))')

        if matching_paren < 1
            " No match found
            " echom 'CTIRP - no match found, ignoring'
            break
        endif

        if matching_paren == lnum
            " This was not an unmatched parentheses, start the search again
            " again after this column
            " echom 'CTIRP - same line match, ignoring'
            continue
        endif

        " echom 'CTIRP - match: ' . line(".") . '  ' . getline(".")

        if getline(matching_paren) =~? '\(if\|while\)\>'
            " echom 'CTIRP - if/while ignored: ' . line(".") . '  ' . getline(".")
            let ignore_paren = ignore_paren + 1
        endif

        " One match found, decrease and check for further matches
        let num_right_paren = num_right_paren - 1

    endwhile

    " Fallback - just move back one
    " return a:prev_indent - shiftwidth()
    return ignore_paren
endfunction

" Based on the keyword provided, loop through previous non empty
" non comment lines to find the statement that initiated the keyword.
" Return its indent level
"    CASE ..
"    WHEN ...
" Should return indent level of CASE
"    EXCEPTION ..
"    WHEN ...
"         something;
"    WHEN ...
" Should return indent level of exception.
function! s:GetStmtStarterIndent( keyword, curr_lnum )
    let lnum  = a:curr_lnum

    " Default - reduce indent by 1
    let ind = indent(a:curr_lnum) - shiftwidth()

    if a:keyword =~? 'end'
        exec 'normal! ^'
        let stmts = '^\s*\%('.
                    \ '\<begin\>\|' .
                    \ '\%(\%(\<end\s\+\)\@<!\<loop\>\)\|' .
                    \ '\%(\%(\<end\s\+\)\@<!\<case\>\)\|' .
                    \ '\%(\%(\<end\s\+\)\@<!\<for\>\)\|' .
                    \ '\%(\%(\<end\s\+\)\@<!\<if\>\)'.
                    \ '\)'
        let matching_lnum = searchpair(stmts, '', '\<end\>\zs', 'bW',
                    \ 's:IsColComment(line("."), col(".")) == 1')
        exec 'normal! $'
        if matching_lnum > 0 && matching_lnum < a:curr_lnum
            let ind = indent(matching_lnum)
        endif
    elseif a:keyword =~? 'when'
        exec 'normal! ^'
        let matching_lnum = searchpair(
                    \ '\%(\<end\s\+\)\@<!\<case\>\|\<exception\>\|\<merge\>',
                    \ '',
                    \ '\%(\%(\<when\s\+others\>\)\|\%(\<end\s\+case\>\)\)',
                    \ 'bW',
                    \ 's:IsColComment(line("."), col(".")) == 1')
        exec 'normal! $'
        if matching_lnum > 0 && matching_lnum < a:curr_lnum
            let ind = indent(matching_lnum)
        else
            let ind = indent(a:curr_lnum)
        endif
    endif

    return ind
endfunction


" Check if the line is a comment
function! s:IsLineComment(lnum)
    let rc = synIDattr(
                \ synID(a:lnum,
                \     match(getline(a:lnum), '\S')+1, 0)
                \ , "name")
                \ =~? "comment"

    return rc
endfunction


" Check if the column is a comment
function! s:IsColComment(lnum, cnum)
    let rc = synIDattr(synID(a:lnum, a:cnum, 0), "name")
                \           =~? "comment"

    return rc
endfunction


" Instead of returning a column position, return
" an appropriate value as a factor of shiftwidth.
function! s:ModuloIndent(ind)
    let ind = a:ind

    if ind > 0
        let modulo = ind % shiftwidth()

        if modulo > 0
            let ind = ind - modulo
        endif
    endif

    return ind
endfunction


" Find correct indent of a new line based upon the previous line
function! GetSQLIndent()
    let lnum = v:lnum
    let ind = indent(lnum)

    " If the current line is a comment, leave the indent as is
    " Comment out this additional check since it affects the
    " indenting of =, and will not reindent comments as it should
    " if s:IsLineComment(lnum) == 1
    "     return ind
    " endif

    " Get previous non-blank line
    let prevlnum = prevnonblank(lnum - 1)
    if prevlnum <= 0
        return ind
    endif

    if s:IsLineComment(prevlnum) == 1
        if getline(v:lnum) =~ '^\s*\*'
            let ind = s:ModuloIndent(indent(prevlnum))
            return ind + 1
        endif
        " If the previous line is a comment, then return -1
        " to tell Vim to use the formatoptions setting to determine
        " the indent to use
        " But only if the next line is blank.  This would be true if
        " the user is typing, but it would not be true if the user
        " is reindenting the file
        if getline(v:lnum) =~ '^\s*$'
            return -1
        endif
    endif

    " echom 'PREVIOUS INDENT: ' . indent(prevlnum) . '  LINE: ' . getline(prevlnum)

    " This is the line you just hit return on, it is not the current line
    " which is new and empty
    " Based on this line, we can determine how much to indent the new
    " line

    " Get default indent (from prev. line)
    let ind      = indent(prevlnum)
    let prevline = getline(prevlnum)

    " Now check what's on the previous line to determine if the indent
    " should be changed, for example IF, BEGIN, should increase the indent
    " where END IF, END, should decrease the indent.
    if prevline =~? s:SQLBlockStart
        " Move indent in
        let ind = ind + shiftwidth()
        " echom 'prevl - SQLBlockStart - indent ' . ind . '  line: ' . prevline
    elseif prevline =~ '[()]'
        if prevline =~ '('
            let num_unmatched_left = s:CountUnbalancedParen( prevline, '(' )
        else
            let num_unmatched_left = 0
        endif
        if prevline =~ ')'
            let num_unmatched_right  = s:CountUnbalancedParen( prevline, ')' )
        else
            let num_unmatched_right  = 0
            " let num_unmatched_right  = s:CountUnbalancedParen( prevline, ')' )
        endif
        if num_unmatched_left > 0
            " There is a open left parenthesis
            " increase indent
            let ind = ind + ( shiftwidth() * num_unmatched_left )
        elseif num_unmatched_right > 0
            " if it is an unbalanced parenthesis only unindent if
            " it was part of a command (ie create table(..)  )
            " instead of part of an if (ie if (....) then) which should
            " maintain the indent level
            let ignore = s:CheckToIgnoreRightParen( prevlnum, num_unmatched_right )
            " echom 'prevl - ) unbalanced - CTIRP - ignore: ' . ignore

            if prevline =~ '^\s*)'
                let ignore = ignore + 1
                " echom 'prevl - begins ) unbalanced ignore: ' . ignore
            endif

            if (num_unmatched_right - ignore) > 0
                let ind = ind - ( shiftwidth() * (num_unmatched_right - ignore) )
            endif

        endif
    endif


    " echom 'CURRENT INDENT: ' . ind . '  LINE: '  . getline(v:lnum)

    " This is a new blank line since we just typed a carriage return
    " Check current line; search for simplistic matching start-of-block
    let line = getline(v:lnum)

    if line =~? '^\s*els'
        " Any line when you type else will automatically back up one
        " ident level  (ie else, elseif, elsif)
        let ind = ind - shiftwidth()
        " echom 'curr - else - indent ' . ind
    elseif line =~? '^\s*end\>'
        let ind = s:GetStmtStarterIndent('end', v:lnum)
        " General case for end
        " let ind = ind - shiftwidth()
        " echom 'curr - end - indent ' . ind
    elseif line =~? '^\s*when\>'
        let ind = s:GetStmtStarterIndent('when', v:lnum)
        " If the WHEN clause is used with a MERGE or EXCEPTION
        " clause, do not change the indent level, since these
        " statements do not have a corresponding END statement.
        " if stmt_starter =~? 'case'
        "    let ind = ind - shiftwidth()
        " endif
        " elseif line =~ '^\s*)\s*;\?\s*$'
        " elseif line =~ '^\s*)'
    elseif line =~ '^\s*)'
        let num_unmatched_right  = s:CountUnbalancedParen( line, ')' )
        let ignore = s:CheckToIgnoreRightParen( v:lnum,W                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               num_unmatched_right )
        " If the line ends in a ), then reduce the indent
        " This catches items like:
        " CREATE TABLE T1(
        "    c1 int,
        "    c2 int
        "    );
        " But we do not want to unindent a line like:
        " IF ( c1 = 1
        " AND  c2 = 3 ) THEN
        " let num_unmatched_right  = s:CountUnbalancedParen( line, ')' )
        " if num_unmatched_right > 0
        " elseif strpart( line, strlen(line)-1, 1 ) =~ ')'
        " let ind = ind - shiftwidth()
        if line =~ '^\s*)'
            " let ignore = ignore + 1
            " echom 'curr - begins ) unbalanced ignore: ' . ignore
        endif

        if (num_unmatched_right - ignore) > 0
            let ind = ind - ( shiftwidth() * (num_unmatched_right - ignore) )
        endif
        " endif
    endif

    " echom 'final - indent ' . ind
    return s:ModuloIndent(ind)
endfunction

"  Restore:
let &cpo= s:keepcpo
unlet s:keepcpo
" vim: ts=4 fdm=marker sw=4
                                           “   sshconfig.vim   ”   systemd.vim •   systemverilog.vim   —   tcsh.vim˜   teraterm.vim™   tex.vim š   tf.vim  ›   	tilde.vim   œ   treetop.vim    typescript.vim  ž   vb.vim  Ÿ   verilog.vim     vhdl.vim¡   vim.vim ¢   	vroom.vim   £   wast.vim¤   xf86conf.vim¥   	xhtml.vim   ¦   
xinetd.vim  §   xml.vim ¨   xsd.vim ©   xslt.vimª   yacc.vim«   yaml.vim¬   	zimbu.vim   ­  ,zsh.vim                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             " Vim indent file
" Language: ssh config file
" Maintainer: JasonKim <git@jasonk.me>
" Last Change: 2020 May 16

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetSshconfigIndent(v:lnum)
setlocal indentkeys=o,O,*<Return>,0=~host\ ,0=~match\ ,0#,!^F

let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"

if exists("*GetSshconfigIndent")
  finish
endif

function GetSshconfigIndent(lnum)
  let sw = shiftwidth()
  let prev_lnum = prevnonblank(a:lnum - 1)
  let curr_lnum = a:lnum
  let prev_line = getline(prev_lnum)
  let curr_line = getline(curr_lnum)
  if curr_line =~? '^\s*\(host\|match\)\s'
    return 0
  elseif prev_line =~? '^\s*\(host\|match\)\s'
    return sw
  else
    return indent(prev_lnum)
  endif
endfunction
                                                                                                                                                                                                                                    " Vim indent file
" Language:  systemd.unit(5)

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Looks a lot like dosini files.
runtime! indent/dosini.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim indent file
" Language:    SystemVerilog
" Maintainer:  kocha <kocha.lsifrontend@gmail.com>
" Last Change: 05-Feb-2017 by Bilal Wasim

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=SystemVerilogIndent()
setlocal indentkeys=!^F,o,O,0),0},=begin,=end,=join,=endcase,=join_any,=join_none
setlocal indentkeys+==endmodule,=endfunction,=endtask,=endspecify
setlocal indentkeys+==endclass,=endpackage,=endsequence,=endclocking
setlocal indentkeys+==endinterface,=endgroup,=endprogram,=endproperty,=endchecker
setlocal indentkeys+==`else,=`endif

" Only define the function once.
if exists("*SystemVerilogIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

function SystemVerilogIndent()

  if exists('b:systemverilog_indent_width')
    let offset = b:systemverilog_indent_width
  else
    let offset = shiftwidth()
  endif
  if exists('b:systemverilog_indent_modules')
    let indent_modules = offset
  else
    let indent_modules = 0
  endif

  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  let lnum2 = prevnonblank(lnum - 1)
  let curr_line  = getline(v:lnum)
  let last_line  = getline(lnum)
  let last_line2 = getline(lnum2)
  let ind  = indent(lnum)
  let ind2 = indent(lnum - 1)
  let offset_comment1 = 1
  " Define the condition of an open statement
  "   Exclude the match of //, /* or */
  let sv_openstat = '\(\<or\>\|\([*/]\)\@<![*(,{><+-/%^&|!=?:]\([*/]\)\@!\)'
  " Define the condition when the statement ends with a one-line comment
  let sv_comment = '\(//.*\|/\*.*\*/\s*\)'
  if exists('b:verilog_indent_verbose')
    let vverb_str = 'INDENT VERBOSE:'
    let vverb = 1
  else
    let vverb = 0
  endif

  " Indent according to last line
  " End of multiple-line comment
  if last_line =~ '\*/\s*$' && last_line !~ '/\*.\{-}\*/'
    let ind = ind - offset_comment1
    if vverb
      echo vverb_str "De-indent after a multiple-line comment."
    endif

  " Indent after if/else/for/case/always/initial/specify/fork blocks
  elseif last_line =~ '`\@<!\<\(if\|else\)\>' ||
    \ last_line =~ '^\s*\<\(for\|case\%[[zx]]\|do\|foreach\|forever\|randcase\)\>' ||
    \ last_line =~ '^\s*\<\(always\|always_comb\|always_ff\|always_latch\)\>' ||
    \ last_line =~ '^\s*\<\(initial\|specify\|fork\|final\)\>'
    if last_line !~ '\(;\|\<end\>\)\s*' . sv_comment . '*$' ||
      \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . sv_comment . '*$'
      let ind = ind + offset
      if vverb | echo vverb_str "Indent after a block statement." | endif
    endif
  " Indent after function/task/class/package/sequence/clocking/
  " interface/covergroup/property/checkerprogram blocks
  elseif last_line =~ '^\s*\<\(function\|task\|class\|package\)\>' ||
    \ last_line =~ '^\s*\<\(sequence\|clocking\|interface\)\>' ||
    \ last_line =~ '^\s*\(\w\+\s*:\)\=\s*\<covergroup\>' ||
    \ last_line =~ '^\s*\<\(property\|checker\|program\)\>'
    if last_line !~ '\<end\>\s*' . sv_comment . '*$' ||
      \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . sv_comment . '*$'
      let ind = ind + offset
      if vverb
	echo vverb_str "Indent after function/task/class block statement."
      endif
    endif

  " Indent after module/function/task/specify/fork blocks
  elseif last_line =~ '^\s*\(\<extern\>\s*\)\=\<module\>'
    let ind = ind + indent_modules
    if vverb && indent_modules
      echo vverb_str "Indent after module statement."
    endif
    if last_line =~ '[(,]\s*' . sv_comment . '*$' &&
      \ last_line !~ '\(//\|/\*\).*[(,]\s*' . sv_comment . '*$'
      let ind = ind + offset
      if vverb
	echo vverb_str "Indent after a multiple-line module statement."
      endif
    endif

  " Indent after a 'begin' statement
  elseif last_line =~ '\(\<begin\>\)\(\s*:\s*\w\+\)*' . sv_comment . '*$' &&
    \ last_line !~ '\(//\|/\*\).*\(\<begin\>\)' &&
    \ ( last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$' ||
    \ last_line2 =~ '^\s*[^=!]\+\s*:\s*' . sv_comment . '*$' )
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after begin statement." | endif

  " Indent after a '{' or a '('
  elseif last_line =~ '[{(]' . sv_comment . '*$' &&
    \ last_line !~ '\(//\|/\*\).*[{(]' &&
    \ ( last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$' ||
    \ last_line2 =~ '^\s*[^=!]\+\s*:\s*' . sv_comment . '*$' )
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after begin statement." | endif

  " De-indent for the end of one-line block
  elseif ( last_line !~ '\<begin\>' ||
    \ last_line =~ '\(//\|/\*\).*\<begin\>' ) &&
    \ last_line2 =~ '\<\(`\@<!if\|`\@<!else\|for\|always\|initial\|do\|foreach\|forever\|final\)\>.*' .
      \ sv_comment . '*$' &&
    \ last_line2 !~ '\(//\|/\*\).*\<\(`\@<!if\|`\@<!else\|for\|always\|initial\|do\|foreach\|forever\|final\)\>' &&
    \ last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$' &&
    \ ( last_line2 !~ '\<begin\>' ||
    \ last_line2 =~ '\(//\|/\*\).*\<begin\>' )
    let ind = ind - offset
    if vverb
      echo vverb_str "De-indent after the end of one-line statement."
    endif

    " Multiple-line statement (including case statement)
    " Open statement
    "   Ident the first open line
    elseif  last_line =~ sv_openstat . '\s*' . sv_comment . '*$' &&
      \ last_line !~ '\(//\|/\*\).*' . sv_openstat . '\s*$' &&
      \ last_line2 !~ sv_openstat . '\s*' . sv_comment . '*$'
      let ind = ind + offset
      if vverb | echo vverb_str "Indent after an open statement." | endif

    " Close statement
    "   De-indent for an optional close parenthesis and a semicolon, and only
    "   if there exists precedent non-whitespace char
    elseif last_line =~ ')*\s*;\s*' . sv_comment . '*$' &&
      \ last_line !~ '^\s*)*\s*;\s*' . sv_comment . '*$' &&
      \ last_line !~ '\(//\|/\*\).*\S)*\s*;\s*' . sv_comment . '*$' &&
      \ ( last_line2 =~ sv_openstat . '\s*' . sv_comment . '*$' &&
      \ last_line2 !~ ';\s*//.*$') &&
      \ last_line2 !~ '^\s*' . sv_comment . '$'
      let ind = ind - offset
      if vverb | echo vverb_str "De-indent after a close statement." | endif

  " `ifdef and `else
  elseif last_line =~ '^\s*`\<\(ifdef\|else\)\>'
    let ind = ind + offset
    if vverb
      echo vverb_str "Indent after a `ifdef or `else statement."
    endif

  endif

  " Re-indent current line

  " De-indent on the end of the block
  " join/end/endcase/endfunction/endtask/endspecify
  if curr_line =~ '^\s*\<\(join\|join_any\|join_none\|\|end\|endcase\|while\)\>' ||
      \ curr_line =~ '^\s*\<\(endfunction\|endtask\|endspecify\|endclass\)\>' ||
      \ curr_line =~ '^\s*\<\(endpackage\|endsequence\|endclocking\|endinterface\)\>' ||
      \ curr_line =~ '^\s*\<\(endgroup\|endproperty\|endchecker\|endprogram\)\>' ||
      \ curr_line =~ '^\s*}'
    let ind = ind - offset
    if vverb | echo vverb_str "De-indent the end of a block." | endif
  elseif curr_line =~ '^\s*\<endmodule\>'
    let ind = ind - indent_modules
    if vverb && indent_modules
      echo vverb_str "De-indent the end of a module."
    endif

  " De-indent on a stand-alone 'begin'
  elseif curr_line =~ '^\s*\<begin\>'
    if last_line !~ '^\s*\<\(function\|task\|specify\|module\|class\|package\)\>' ||
      \ last_line !~ '^\s*\<\(sequence\|clocking\|interface\|covergroup\)\>' ||
      \ last_line !~ '^\s*\<\(property\|checker\|program\)\>' &&
      \ last_line !~ '^\s*\()*\s*;\|)\+\)\s*' . sv_comment . '*$' &&
      \ ( last_line =~
      \ '\<\(`\@<!if\|`\@<!else\|for\|case\%[[zx]]\|always\|initial\|do\|foreach\|forever\|randcase\|final\)\>' ||
      \ last_line =~ ')\s*' . sv_comment . '*$' ||
      \ last_line =~ sv_openstat . '\s*' . sv_comment . '*$' )
      let ind = ind - offset
      if vverb
	echo vverb_str "De-indent a stand alone begin statement."
      endif
    endif

  " De-indent after the end of multiple-line statement
  elseif curr_line =~ '^\s*)' &&
    \ ( last_line =~ sv_openstat . '\s*' . sv_comment . '*$' ||
    \ last_line !~ sv_openstat . '\s*' . sv_comment . '*$' &&
    \ last_line2 =~ sv_openstat . '\s*' . sv_comment . '*$' )
    let ind = ind - offset
    if vverb
      echo vverb_str "De-indent the end of a multiple statement."
    endif

  " De-indent `else and `endif
  elseif curr_line =~ '^\s*`\<\(else\|endif\)\>'
    let ind = ind - offset
    if vverb | echo vverb_str "De-indent `else and `endif statement." | endif

  endif

  " Return the indentation
  return ind
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save

" vim:sw=2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim indent file
" Language:		Tcl
" Maintainer:		Chris Heithoff <chrisheithoff@gmail.com>
" Previous Maintainer:	Nikolai Weibull <now@bitwi.se>
" Last Change:		24 Sep 2021

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetTclIndent()
setlocal indentkeys=0{,0},!^F,o,O,0]
setlocal nosmartindent

let b:undo_indent = "setl inde< indk< si<"

if exists("*GetTclIndent")
  finish
endif

function s:prevnonblanknoncomment(lnum)
  let lnum = prevnonblank(a:lnum)
  while lnum > 0
    let line = getline(lnum)
    if line !~ '^\s*\(#\|$\)'
      break
    endif
    let lnum = prevnonblank(lnum - 1)
  endwhile
  return lnum
endfunction

function s:ends_with_backslash(lnum)
  let line = getline(a:lnum)
  if line =~ '\\\s*$'
    return 1
  else
    return 0
  endif
endfunction 

function s:count_braces(lnum, count_open)
  let n_open = 0
  let n_close = 0
  let line = getline(a:lnum)
  let pattern = '[{}]'
  let i = match(line, pattern)
  while i != -1
    if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'tcl\%(Comment\|String\)'
      if line[i] == '{'
        let n_open += 1
      elseif line[i] == '}'
        if n_open > 0
          let n_open -= 1
        else
          let n_close += 1
        endif
      endif
    endif
    let i = match(line, pattern, i + 1)
  endwhile
  return a:count_open ? n_open : n_close
endfunction

function GetTclIndent()
  let line = getline(v:lnum)

  " Get the line number of the previous non-blank or non-comment line.
  let pnum = s:prevnonblanknoncomment(v:lnum - 1)
  if pnum == 0
    return 0
  endif

  " ..and the previous line before the previous line.
  let pnum2 = s:prevnonblanknoncomment(pnum-1)

  " Default indentation is to preserve the previous indentation.
  let ind = indent(pnum)
 
  " ...but if previous line introduces an open brace, then increase current line's indentation
  if s:count_braces(pnum, 1) > 0
    let ind += shiftwidth()
  else
    " Look for backslash line continuation on the previous two lines.
    let slash1 = s:ends_with_backslash(pnum)
    let slash2 = s:ends_with_backslash(pnum2)
    if slash1 && !slash2
      " If the previous line begins a line continuation.
      let ind += shiftwidth()
    elseif !slash1 && slash2
      " If two lines ago was the end of a line continuation group of lines.
      let ind -= shiftwidth()
    endif
  endif

  " If the current line begins with a closed brace, then decrease the indentation by one.
  if line =~ '^\s*}'
    let ind -= shiftwidth()
  endif
  
  return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  " Vim indent file
" Language:		C-shell (tcsh)
" Maintainer:		Doug Kearns <dougkearns@gmail.com>
" Previous Maintainer:	Gautam Iyer <gi1242+vim@NoSpam.com> where NoSpam=gmail (Original Author)
" Last Change:		2021 Oct 15

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif

let b:did_indent = 1

setlocal indentexpr=TcshGetIndent()
setlocal indentkeys+=e,0=end
setlocal indentkeys-=0{,0},0),:,0#

let b:undo_indent = "setl inde< indk<"

" Only define the function once.
if exists("*TcshGetIndent")
    finish
endif

function TcshGetIndent()
    " Find a non-blank line above the current line.
    let lnum = prevnonblank(v:lnum - 1)

    " Hit the start of the file, use zero indent.
    if lnum == 0
	return 0
    endif

    " Add indent if previous line begins with while or foreach
    " OR line ends with case <str>:, default:, else, then or \
    let ind = indent(lnum)
    let line = getline(lnum)
    if line =~ '\v^\s*%(while|foreach)>|^\s*%(case\s.*:|default:|else)\s*$|%(<then|\\)$'
	let ind = ind + shiftwidth()
    endif

    if line =~ '\v^\s*breaksw>'
	let ind = ind - shiftwidth()
    endif

    " Subtract indent if current line has on end, endif, endsw, case commands
    let line = getline(v:lnum)
    if line =~ '\v^\s*%(else|end|endif|endsw)\s*$'
	let ind = ind - shiftwidth()
    endif

    return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim indent file
" Language:	Tera Term Language (TTL)
"		Based on Tera Term Version 4.100
" Maintainer:	Ken Takata
" URL:		https://github.com/k-takata/vim-teraterm
" Last Change:	2021-10-18
" Filenames:	*.ttl
" License:	VIM License

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal nosmartindent
setlocal noautoindent
setlocal indentexpr=GetTeraTermIndent(v:lnum)
setlocal indentkeys=!^F,o,O,e
setlocal indentkeys+==elseif,=endif,=loop,=next,=enduntil,=endwhile

let b:undo_indent = "setl ai< inde< indk< si<"

if exists("*GetTeraTermIndent")
  finish
endif

function! GetTeraTermIndent(lnum)
  let l:prevlnum = prevnonblank(a:lnum-1)
  if l:prevlnum == 0
    " top of file
    return 0
  endif

  " grab the previous and current line, stripping comments.
  let l:prevl = substitute(getline(l:prevlnum), ';.*$', '', '')
  let l:thisl = substitute(getline(a:lnum), ';.*$', '', '')
  let l:previ = indent(l:prevlnum)

  let l:ind = l:previ

  if l:prevl =~ '^\s*if\>.*\<then\>'
    " previous line opened a block
    let l:ind += shiftwidth()
  endif
  if l:prevl =~ '^\s*\%(elseif\|else\|do\|until\|while\|for\)\>'
    " previous line opened a block
    let l:ind += shiftwidth()
  endif
  if l:thisl =~ '^\s*\%(elseif\|else\|endif\|enduntil\|endwhile\|loop\|next\)\>'
    " this line closed a block
    let l:ind -= shiftwidth()
  endif

  return l:ind
endfunction

" vim: ts=8 sw=2 sts=2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           " Vim indent file
" Language:     LaTeX
" Maintainer:   Yichao Zhou <broken.zhou AT gmail.com>
" Created:      Sat, 16 Feb 2002 16:50:19 +0100
" Version: 1.0.0
"   Please email me if you found something I can do.  Comments, bug report and
"   feature request are welcome.

" Last Update:  {{{
"               25th Sep 2002, by LH :
"               (*) better support for the option
"               (*) use some regex instead of several '||'.
"               Oct 9th, 2003, by JT:
"               (*) don't change indentation of lines starting with '%'
"               2005/06/15, Moshe Kaminsky <kaminsky AT math.huji.ac.il>
"               (*) New variables:
"                   g:tex_items, g:tex_itemize_env, g:tex_noindent_env
"               2011/3/6, by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Don't change indentation of lines starting with '%'
"                   I don't see any code with '%' and it doesn't work properly
"                   so I add some code.
"               (*) New features: Add smartindent-like indent for "{}" and  "[]".
"               (*) New variables: g:tex_indent_brace
"               2011/9/25, by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Bug fix: smartindent-like indent for "[]"
"               (*) New features: Align with "&".
"               (*) New variable: g:tex_indent_and.
"               2011/10/23 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Bug fix: improve the smartindent-like indent for "{}" and
"               "[]".
"               2012/02/27 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Bug fix: support default folding marker.
"               (*) Indent with "&" is not very handy.  Make it not enable by
"               default.
"               2012/03/06 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Modify "&" behavior and make it default again.  Now "&"
"               won't align when there are more then one "&" in the previous
"               line.
"               (*) Add indent "\left(" and "\right)"
"               (*) Trust user when in "verbatim" and "lstlisting"
"               2012/03/11 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Modify "&" so that only indent when current line start with
"                   "&".
"               2012/03/12 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Modify indentkeys.
"               2012/03/18 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Add &cpo
"               2013/05/02 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Fix problem about GetTeXIndent checker. Thank Albert Netymk
"                   for reporting this.
"               2014/06/23 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Remove the feature g:tex_indent_and because it is buggy.
"               (*) If there is not any obvious indentation hints, we do not
"                   alert our user's current indentation.
"               (*) g:tex_indent_brace now only works if the open brace is the
"                   last character of that line.
"               2014/08/03 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Indent current line if last line has larger indentation
"               2016/11/08 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Fix problems for \[ and \].  Thanks Bruno for reporting.
"               2017/04/30 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Fix a bug between g:tex_noindent_env and g:tex_indent_items
"                   Now g:tex_noindent_env='document\|verbatim\|itemize' (Emacs
"                   style) is supported.  Thanks Miles Wheeler for reporting.
"               2018/02/07 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Make indentation more smart in the normal mode
"               2020/04/26 by Yichao Zhou <broken.zhou AT gmail.com>
"               (*) Fix a bug related to \[ & \].  Thanks Manuel Boni for
"               reporting.
"
" }}}

" Document: {{{
"
" For proper latex experience, please put
"         let g:tex_flavor = "latex"
" into your vimrc.
"
" * g:tex_indent_brace
"
"   If this variable is unset or non-zero, it will use smartindent-like style
"   for "{}" and "[]".  Now this only works if the open brace is the last
"   character of that line.
"
"         % Example 1
"         \usetikzlibrary{
"           external
"         }
"
"         % Example 2
"         \tikzexternalize[
"           prefix=tikz]
"
" * g:tex_indent_items
"
"   If this variable is set, item-environments are indented like Emacs does
"   it, i.e., continuation lines are indented with a shiftwidth.
"
"              set                      unset
"   ------------------------------------------------------
"       \begin{itemize}            \begin{itemize}
"         \item blablabla            \item blablabla
"           bla bla bla              bla bla bla
"         \item blablabla            \item blablabla
"           bla bla bla              bla bla bla
"       \end{itemize}              \end{itemize}
"
"
" * g:tex_items
"
"   A list of tokens to be considered as commands for the beginning of an item
"   command. The tokens should be separated with '\|'. The initial '\' should
"   be escaped. The default is '\\bibitem\|\\item'.
"
" * g:tex_itemize_env
"
"   A list of environment names, separated with '\|', where the items (item
"   commands matching g:tex_items) may appear. The default is
"   'itemize\|description\|enumerate\|thebibliography'.
"
" * g:tex_noindent_env
"
"   A list of environment names. separated with '\|', where no indentation is
"   required. The default is 'document\|verbatim'.
" }}}

" Only define the function once
if exists("b:did_indent")
    finish
endif

let s:cpo_save = &cpo
set cpo&vim

" Define global variable {{{

let b:did_indent = 1

if !exists("g:tex_indent_items")
    let g:tex_indent_items = 1
endif
if !exists("g:tex_indent_brace")
    let g:tex_indent_brace = 1
endif
if !exists("g:tex_max_scan_line")
    let g:tex_max_scan_line = 60
endif
if g:tex_indent_items
    if !exists("g:tex_itemize_env")
        let g:tex_itemize_env = 'itemize\|description\|enumerate\|thebibliography'
    endif
    if !exists('g:tex_items')
        let g:tex_items = '\\bibitem\|\\item'
    endif
else
    let g:tex_items = ''
endif

if !exists("g:tex_noindent_env")
    let g:tex_noindent_env = 'document\|verbatim\|lstlisting'
endif "}}}

" VIM Setting " {{{
setlocal autoindent
setlocal nosmartindent
setlocal indentexpr=GetTeXIndent()
setlocal indentkeys&
exec 'setlocal indentkeys+=[,(,{,),},],\&' . substitute(g:tex_items, '^\|\(\\|\)', ',=', 'g')
let g:tex_items = '^\s*' . substitute(g:tex_items, '^\(\^\\s\*\)*', '', '')
" }}}

function! GetTeXIndent() " {{{
    " Find a non-blank line above the current line.
    let lnum = prevnonblank(v:lnum - 1)
    let cnum = v:lnum

    " Comment line is not what we need.
    while lnum != 0 && getline(lnum) =~ '^\s*%'
        let lnum = prevnonblank(lnum - 1)
    endwhile

    " At the start of the file use zero indent.
    if lnum == 0
        return 0
    endif

    let line = substitute(getline(lnum), '\s*%.*', '','g')     " last line
    let cline = substitute(getline(v:lnum), '\s*%.*', '', 'g') " current line

    let ccol = 1
    while cline[ccol] =~ '\s'
        let ccol += 1
    endwhile

    "  We are in verbatim, so do what our user what.
    if synIDattr(synID(v:lnum, ccol, 1), "name") == "texZone"
        if empty(cline)
            return indent(lnum)
        else
            return indent(v:lnum)
        endif
    endif

    if lnum == 0
        return 0
    endif

    let ind = indent(lnum)
    let stay = 1

    " New code for comment: retain the indent of current line
    if cline =~ '^\s*%'
        return indent(v:lnum)
    endif

    " Add a 'shiftwidth' after beginning of environments.
    " Don't add it for \begin{document} and \begin{verbatim}
    " if line =~ '^\s*\\begin{\(.*\)}'  && line !~ 'verbatim'
    " LH modification : \begin does not always start a line
    " ZYC modification : \end after \begin won't cause wrong indent anymore
    if line =~ '\\begin{.*}' 
        if line !~ g:tex_noindent_env
            let ind = ind + shiftwidth()
            let stay = 0
        endif

        if g:tex_indent_items
            " Add another sw for item-environments
            if line =~ g:tex_itemize_env
                let ind = ind + shiftwidth()
                let stay = 0
            endif
        endif
    endif

    if cline =~ '\\end{.*}'
        let retn = s:GetEndIndentation(v:lnum)
        if retn != -1
            return retn
        endif
    end
    " Subtract a 'shiftwidth' when an environment ends
    if cline =~ '\\end{.*}'
                \ && cline !~ g:tex_noindent_env
                \ && cline !~ '\\begin{.*}.*\\end{.*}'
        if g:tex_indent_items
            " Remove another sw for item-environments
            if cline =~ g:tex_itemize_env
                let ind = ind - shiftwidth()
                let stay = 0
            endif
        endif

        let ind = ind - shiftwidth()
        let stay = 0
    endif

    if g:tex_indent_brace
        if line =~ '[[{]$'
            let ind += shiftwidth()
            let stay = 0
        endif

        if cline =~ '^\s*\\\?[\]}]' && s:CheckPairedIsLastCharacter(v:lnum, ccol)
            let ind -= shiftwidth()
            let stay = 0
        endif

        if line !~ '^\s*\\\?[\]}]'
            for i in range(1, strlen(line)-1)
                let char = line[i]
                if char == ']' || char == '}'
                    if s:CheckPairedIsLastCharacter(lnum, i)
                        let ind -= shiftwidth()
                        let stay = 0
                    endif
                endif
            endfor
        endif
    endif

    " Special treatment for 'item'
    " ----------------------------

    if g:tex_indent_items
        " '\item' or '\bibitem' itself:
        if cline =~ g:tex_items
            let ind = ind - shiftwidth()
            let stay = 0
        endif
        " lines following to '\item' are indented once again:
        if line =~ g:tex_items
            let ind = ind + shiftwidth()
            let stay = 0
        endif
    endif

    if stay && mode() == 'i'
        " If there is no obvious indentation hint, and indentation is triggered
        " in insert mode, we trust our user.
        if empty(cline)
            return ind
        else
            return max([indent(v:lnum), s:GetLastBeginIndentation(v:lnum)])
        endif
    else
        return ind
    endif
endfunction "}}}

function! s:GetLastBeginIndentation(lnum) " {{{
    let matchend = 1
    for lnum in range(a:lnum-1, max([a:lnum - g:tex_max_scan_line, 1]), -1)
        let line = getline(lnum)
        if line =~ '\\end{.*}'
            let matchend += 1
        endif
        if line =~ '\\begin{.*}'
            let matchend -= 1
        endif
        if matchend == 0
            if line =~ g:tex_noindent_env
                return indent(lnum)
            endif
            if line =~ g:tex_itemize_env
                return indent(lnum) + 2 * shiftwidth()
            endif
            return indent(lnum) + shiftwidth()
        endif
    endfor
    return -1
endfunction

function! s:GetEndIndentation(lnum) " {{{
    if getline(a:lnum) =~ '\\begin{.*}.*\\end{.*}'
        return -1
    endif

    let min_indent = 100
    let matchend = 1
    for lnum in range(a:lnum-1, max([a:lnum-g:tex_max_scan_line, 1]), -1)
        let line = getline(lnum)
        if line =~ '\\end{.*}'
            let matchend += 1
        endif
        if line =~ '\\begin{.*}'
            let matchend -= 1
        endif
        if matchend == 0
            return indent(lnum)
        endif
        if !empty(line)
            let min_indent = min([min_indent, indent(lnum)])
        endif
    endfor
    return min_indent - shiftwidth()
endfunction

" Most of the code is from matchparen.vim
function! s:CheckPairedIsLastCharacter(lnum, col) "{{{
    let c_lnum = a:lnum
    let c_col = a:col+1

    let line = getline(c_lnum)
    if line[c_col-1] == '\'
        let c_col = c_col + 1
    endif
    let c = line[c_col-1]

    let plist = split(&matchpairs, '.\zs[:,]')
   x  y                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           let i = index(plist, c)
    if i < 0
        return 0
    endif

    " Figure out the arguments for searchpairpos().
    if i % 2 == 0
        let s_flags = 'nW'
        let c2 = plist[i + 1]
    else
        let s_flags = 'nbW'
        let c2 = c
        let c = plist[i - 1]
    endif
    if c == '['
        let c = '\['
        let c2 = '\]'
    endif

    " Find the match.  When it was just before the cursor move it there for a
    " moment.
    let save_cursor = winsaveview()
    call cursor(c_lnum, c_col)

    " When not in a string or comment ignore matches inside them.
    " We match "escape" for special items, such as lispEscapeSpecial.
    let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
                \ '=~?  "string\\|character\\|singlequote\\|escape\\|comment"'
    execute 'if' s_skip '| let s_skip = 0 | endif'

    let stopline = max([0, c_lnum - g:tex_max_scan_line])

    " Limit the search time to 300 msec to avoid a hang on very long lines.
    " This fails when a timeout is not supported.
    try
        let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 100)
    catch /E118/
    endtry

    call winrestview(save_cursor)

    if m_lnum > 0
        let line = getline(m_lnum)
        return strlen(line) == m_col
    endif

    return 0
endfunction "}}}

let &cpo = s:cpo_save
unlet s:cpo_save

" vim: set sw=4 textwidth=80:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim indent file
" Language:     tf (TinyFugue)
" Maintainer:   Christian J. Robinson <heptite@gmail.com>
" URL:          http://www.vim.org/scripts/script.php?script_id=174
" Last Change:  2017 Feb 25 

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetTFIndent()
setlocal indentkeys-=0{,0} indentkeys-=0# indentkeys-=:
setlocal indentkeys+==/endif,=/then,=/else,=/done,0;

" Only define the function once:
if exists("*GetTFIndent")
  finish
endif

function GetTFIndent()
	" Find a non-blank line above the current line:
	let lnum = prevnonblank(v:lnum - 1)

	" No indent for the start of the file:
	if lnum == 0
		return 0
	endif

	let ind = indent(lnum)
	let line = getline(lnum)

	" No indentation if the previous line didn't end with "\":
	" (Could be annoying, but it lets you know if you made a mistake.)
	if line !~ '\\$'
		return 0
	endif

	if line =~ '\(/def.*\\\|/for.*\(%;\s*\)\@\<!\\\)$'
		let ind = ind + shiftwidth()
	elseif line =~ '\(/if\|/else\|/then\)'
		if line !~ '/endif'
			let ind = ind + shiftwidth()
		endif
	elseif line =~ '/while'
		if line !~ '/done'
			let ind = ind + shiftwidth()
		endif
	endif

	let line = getline(v:lnum)

	if line =~ '\(/else\|/endif\|/then\)'
		if line !~ '/if'
			let ind = ind - shiftwidth()
		endif
	elseif line =~ '/done'
		if line !~ '/while'
			let ind = ind - shiftwidth()
		endif
	endif

	" Comments at the beginning of a line:
	if line =~ '^\s*;'
		let ind = 0
	endif


	return ind

endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "Description: Indent scheme for the tilde weblanguage
"Author: Tobias RundstrÃ¶m <tobi@tobi.nu>
"URL: http://tilde.tildesoftware.net
"Last Change: May  8 09:15:09 CEST 2002

if exists ("b:did_indent")
	finish
endif

let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=GetTildeIndent(v:lnum)
setlocal indentkeys=o,O,)

if exists("*GetTildeIndent")
	finish
endif

function GetTildeIndent(lnum)
	let plnum = prevnonblank(v:lnum-1)

	if plnum == 0
		return 0
	endif

	if getline(v:lnum) =~ '^\s*\~\(endif\|else\|elseif\|end\)\>'
		return indent(v:lnum) - shiftwidth()
	endif

	if getline(plnum) =~ '^\s*\~\(if\|foreach\|foreach_row\|xml_loop\|file_loop\|file_write\|file_append\|imap_loopsections\|imap_index\|imap_list\|ldap_search\|post_loopall\|post_loop\|file_loop\|sql_loop_num\|sql_dbmsselect\|search\|sql_loop\|post\|for\|function_define\|silent\|while\|setvalbig\|mail_create\|systempipe\|mail_send\|dual\|elseif\|else\)\>'
		return indent(plnum) + shiftwidth()
	else
		return -1
	endif
endfunction
           " Vim indent file
" Language:             Treetop
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2011-03-14

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetTreetopIndent()
setlocal indentkeys=0{,0},!^F,o,O,=end
setlocal nosmartindent

if exists("*GetTreetopIndent")
  finish
endif

function GetTreetopIndent()
  let pnum = prevnonblank(v:lnum - 1)
  if pnum == 0
    return 0
  endif

  let ind = indent(pnum)
  let line = getline(pnum)

  if line =~ '^\s*\%(grammar\|module\|rule\)\>'
    let ind += shiftwidth()
  endif

  let line = getline(v:lnum)
  if line =~ '^\s*end\>'
    let ind -= shiftwidth()
  end

  return ind
endfunction
                                                                                                                                                                                                                                                                                                                            " Vim indent file
" Language: TypeScript
" Maintainer: See https://github.com/HerringtonDarkholme/yats.vim
" Last Change: 2019 Oct 18
" Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org

" 0. Initialization {{{1
" =================

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal nosmartindent

" Now, set up our indentation expression and keys that trigger it.
setlocal indentexpr=GetTypescriptIndent()
setlocal formatexpr=Fixedgq(v:lnum,v:count)
setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e

" Only define the function once.
if exists("*GetTypescriptIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

" 1. Variables {{{1
" ============

let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'

" Regex of syntax group names that are or delimit string or are comments.
let s:syng_strcom = 'string\|regex\|comment\c'

" Regex of syntax group names that are strings.
let s:syng_string = 'regex\c'

" Regex of syntax group names that are strings or documentation.
let s:syng_multiline = 'comment\c'

" Regex of syntax group names that are line comment.
let s:syng_linecom = 'linecomment\c'

" Expression used to check whether we should skip a match with searchpair().
let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"

let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'

" Regex that defines continuation lines, not including (, {, or [.
let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=].*,\)' . s:line_term

" Regex that defines continuation lines.
" TODO: this needs to deal with if ...: and so on
let s:msl_regex = s:continuation_regex

let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term

" Regex that defines blocks.
let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term

let s:var_stmt = '^\s*var'

let s:comma_first = '^\s*,'
let s:comma_last = ',\s*$'

let s:ternary = '^\s\+[?|:]'
let s:ternary_q = '^\s\+?'

" 2. Auxiliary Functions {{{1
" ======================

" Check if the character at lnum:col is inside a string, comment, or is ascii.
function s:IsInStringOrComment(lnum, col)
  return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
endfunction

" Check if the character at lnum:col is inside a string.
function s:IsInString(lnum, col)
  return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
endfunction

" Check if the character at lnum:col is inside a multi-line comment.
function s:IsInMultilineComment(lnum, col)
  return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
endfunction

" Check if the character at lnum:col is a line comment.
function s:IsLineComment(lnum, col)
  return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
endfunction

" Find line above 'lnum' that isn't empty, in a comment, or in a string.
function s:PrevNonBlankNonString(lnum)
  let in_block = 0
  let lnum = prevnonblank(a:lnum)
  while lnum > 0
    " Go in and out of blocks comments as necessary.
    " If the line isn't empty (with opt. comment) or in a string, end search.
    let line = getline(lnum)
    if line =~ '/\*'
      if in_block
        let in_block = 0
      else
        break
      endif
    elseif !in_block && line =~ '\*/'
      let in_block = 1
    elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
      break
    endif
    let lnum = prevnonblank(lnum - 1)
  endwhile
  return lnum
endfunction

" Find line above 'lnum' that started the continuation 'lnum' may be part of.
function s:GetMSL(lnum, in_one_line_scope)
  " Start on the line we're at and use its indent.
  let msl = a:lnum
  let lnum = s:PrevNonBlankNonString(a:lnum - 1)
  while lnum > 0
    " If we have a continuation line, or we're in a string, use line as MSL.
    " Otherwise, terminate search as we have found our MSL already.
    let line = getline(lnum)
    let col = match(line, s:msl_regex) + 1
    if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
      let msl = lnum
    else
      " Don't use lines that are part of a one line scope as msl unless the
      " flag in_one_line_scope is set to 1
      "
      if a:in_one_line_scope
        break
      end
      let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
      if msl_one_line == 0
        break
      endif
    endif
    let lnum = s:PrevNonBlankNonString(lnum - 1)
  endwhile
  return msl
endfunction

function s:RemoveTrailingComments(content)
  let single = '\/\/\(.*\)\s*$'
  let multi = '\/\*\(.*\)\*\/\s*$'
  return substitute(substitute(a:content, single, '', ''), multi, '', '')
endfunction

" Find if the string is inside var statement (but not the first string)
function s:InMultiVarStatement(lnum)
  let lnum = s:PrevNonBlankNonString(a:lnum - 1)

"  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')

  " loop through previous expressions to find a var statement
  while lnum > 0
    let line = getline(lnum)

    " if the line is a js keyword
    if (line =~ s:js_keywords)
      " check if the line is a var stmt
      " if the line has a comma first or comma last then we can assume that we
      " are in a multiple var statement
      if (line =~ s:var_stmt)
        return lnum
      endif

      " other js keywords, not a var
      return 0
    endif

    let lnum = s:PrevNonBlankNonString(lnum - 1)
  endwhile

  " beginning of program, not a var
  return 0
endfunction

" Find line above with beginning of the var statement or returns 0 if it's not
" this statement
function s:GetVarIndent(lnum)
  let lvar = s:InMultiVarStatement(a:lnum)
  let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)

  if lvar
    let line = s:RemoveTrailingComments(getline(prev_lnum))

    " if the previous line doesn't end in a comma, return to regular indent
    if (line !~ s:comma_last)
      return indent(prev_lnum) - shiftwidth()
    else
      return indent(lvar) + shiftwidth()
    endif
  endif

  return -1
endfunction


" Check if line 'lnum' has more opening brackets than closing ones.
function s:LineHasOpeningBrackets(lnum)
  let open_0 = 0
  let open_2 = 0
  let open_4 = 0
  let line = getline(a:lnum)
  let pos = match(line, '[][(){}]', 0)
  while pos != -1
    if !s:IsInStringOrComment(a:lnum, pos + 1)
      let idx = stridx('(){}[]', line[pos])
      if idx % 2 == 0
        let open_{idx} = open_{idx} + 1
      else
        let open_{idx - 1} = open_{idx - 1} - 1
      endif
    endif
    let pos = match(line, '[][(){}]', pos + 1)
  endwhile
  return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
endfunction

function s:Match(lnum, regex)
  let col = match(getline(a:lnum), a:regex) + 1
  return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
endfunction

function s:IndentWithContinuation(lnum, ind, width)
  " Set up variables to use and search for MSL to the previous line.
  let p_lnum = a:lnum
  let lnum = s:GetMSL(a:lnum, 1)
  let line = getline(lnum)

  " If the previous line wasn't a MSL and is continuation return its indent.
  " TODO: the || s:IsInString() thing worries me a bit.
  if p_lnum != lnum
    if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
      return a:ind
    endif
  endif

  " Set up more variables now that we know we aren't continuation bound.
  let msl_ind = indent(lnum)

  " If the previous line ended with [*+/.-=], start a continuation that
  " indents an extra level.
  if s:Match(lnum, s:continuation_regex)
    if lnum == p_lnum
      return msl_ind + a:width
    else
      return msl_ind
    endif
  endif

  return a:ind
endfunction

function s:InOneLineScope(lnum)
  let msl = s:GetMSL(a:lnum, 1)
  if msl > 0 && s:Match(msl, s:one_line_scope_regex)
    return msl
  endif
  return 0
endfunction

function s:ExitingOneLineScope(lnum)
  let msl = s:GetMSL(a:lnum, 1)
  if msl > 0
    " if the current line is in a one line scope ..
    if s:Match(msl, s:one_line_scope_regex)
      return 0
    else
      let prev_msl = s:GetMSL(msl - 1, 1)
      if s:Match(prev_msl, s:one_line_scope_regex)
        return prev_msl
      endif
    endif
  endif
  return 0
endfunction

" 3. GetTypescriptIndent Function {{{1
" =========================

function GetTypescriptIndent()
  " 3.1. Setup {{{2
  " ----------

  " Set up variables for restoring position in file.  Could use v:lnum here.
  let vcol = col('.')

  " 3.2. Work on the current line {{{2
  " -----------------------------

  let ind = -1
  " Get the current line.
  let line = getline(v:lnum)
  " previous nonblank line number
  let prevline = prevnonblank(v:lnum - 1)

  " If we got a closing bracket on an empty line, find its match and indent
  " according to it.  For parentheses we indent to its column - 1, for the
  " others we indent to the containing line's MSL's level.  Return -1 if fail.
  let col = matchend(line, '^\s*[],})]')
  if col > 0 && !s:IsInStringOrComment(v:lnum, col)
    call cursor(v:lnum, col)

    let lvar = s:InMultiVarStatement(v:lnum)
    if lvar
      let prevline_contents = s:RemoveTrailingComments(getline(prevline))

      " check for comma first
      if (line[col - 1] =~ ',')
        " if the previous line ends in comma or semicolon don't indent
        if (prevline_contents =~ '[;,]\s*$')
          return indent(s:GetMSL(line('.'), 0))
        " get previous line indent, if it's comma first return prevline indent
        elseif (prevline_contents =~ s:comma_first)
          return indent(prevline)
        " otherwise we indent 1 level
        else
          return indent(lvar) + shiftwidth()
        endif
      endif
    endif


    let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
    if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
      if line[col-1]==')' && col('.') != col('$') - 1
        let ind = virtcol('.')-1
      else
        let ind = indent(s:GetMSL(line('.'), 0))
      endif
    endif
    return ind
  endif

  " If the line is comma first, dedent 1 level
  if (getline(prevline) =~ s:comma_first)
    return indent(prevline) - shiftwidth()
  endif

  if (line =~ s:ternary)
    if (getline(prevline) =~ s:ternary_q)
      return indent(prevline)
    else
      return indent(prevline) + shiftwidth()
    endif
  endif

  " If we are in a multi-line comment, cindent does the right thing.
  if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
    return cindent(v:lnum)
  endif

  " Check for multiple var assignments
"  let var_indent = s:GetVarIndent(v:lnum)
"  if var_indent >= 0
"    return var_indent
"  endif

  " 3.3. Work on the previous line. {{{2
  " -------------------------------

  " If the line is empty and the previous nonblank line was a multi-line
  " comment, use that comment's indent. Deduct one char to account for the
  " space in ' */'.
  if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
    return indent(prevline) - 1
  endif

  " Find a non-blank, non-multi-line string line above the current line.
  let lnum = s:PrevNonBlankNonString(v:lnum - 1)

  " If the line is empty and inside a string, use the previous line.
  if line =~ '^\s*$' && lnum != prevline
    return indent(prevnonblank(v:lnum))
  endif

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  " Set up variables for current line.
  let line = getline(lnum)
  let ind = indent(lnum)

  " If the previous line ended with a block opening, add a level of indent.
  if s:Match(lnum, s:block_regex)
    return indent(s:GetMSL(lnum, 0)) + shiftwidth()
  endif

  " If the previous line contained an opening bracket, and we are still in it,
  " add indent depending on the bracket type.
  if line =~ '[[({]'
    let counts = s:LineHasOpeningBrackets(lnum)
    if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
      if col('.') + 1 == col('$')
        return ind + shiftwidth()
      else
        return virtcol('.')
      endif
   ‹  Œ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         elseif counts[1] == '1' || counts[2] == '1'
      return ind + shiftwidth()
    else
      call cursor(v:lnum, vcol)
    end
  endif

  " 3.4. Work on the MSL line. {{{2
  " --------------------------

  let ind_con = ind
  let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())

  " }}}2
  "
  "
  let ols = s:InOneLineScope(lnum)
  if ols > 0
    let ind = ind + shiftwidth()
  else
    let ols = s:ExitingOneLineScope(lnum)
    while ols > 0 && ind > 0
      let ind = ind - shiftwidth()
      let ols = s:InOneLineScope(ols - 1)
    endwhile
  endif

  return ind
endfunction

" }}}1

let &cpo = s:cpo_save
unlet s:cpo_save

function! Fixedgq(lnum, count)
    let l:tw = &tw ? &tw : 80

    let l:count = a:count
    let l:first_char = indent(a:lnum) + 1

    if mode() == 'i' " gq was not pressed, but tw was set
        return 1
    endif

    " This gq is only meant to do code with strings, not comments
    if s:IsLineComment(a:lnum, l:first_char) || s:IsInMultilineComment(a:lnum, l:first_char)
        return 1
    endif

    if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
        return 1
    endif

    " Put all the lines on one line and do normal splitting after that
    if l:count > 1
        while l:count > 1
            let l:count -= 1
            normal J
        endwhile
    endif

    let l:winview = winsaveview()

    call cursor(a:lnum, l:tw + 1)
    let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
    call cursor(a:lnum, l:tw + 1)
    let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)

    " No need for special treatment, normal gq handles edgecases better
    if breakpoint[1] == orig_breakpoint[1]
        call winrestview(l:winview)
        return 1
    endif

    " Try breaking after string
    if breakpoint[1] <= indent(a:lnum)
        call cursor(a:lnum, l:tw + 1)
        let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
    endif


    if breakpoint[1] != 0
        call feedkeys("r\<CR>")
    else
        let l:count = l:count - 1
    endif

    " run gq on new lines
    if l:count == 1
        call feedkeys("gqq")
    endif

    return 0
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Vim indent file
" Language:	VisualBasic (ft=vb) / Basic (ft=basic) / SaxBasic (ft=vb)
" Author:	Johannes Zellner <johannes@zellner.org>
" Last Change:	Fri, 18 Jun 2004 07:22:42 CEST
"		Small update 2010 Jul 28 by Maxim Kim

if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

setlocal autoindent
setlocal indentexpr=VbGetIndent(v:lnum)
setlocal indentkeys&
setlocal indentkeys+==~else,=~elseif,=~end,=~wend,=~case,=~next,=~select,=~loop,<:>

let b:undo_indent = "set ai< indentexpr< indentkeys<"

" Only define the function once.
if exists("*VbGetIndent")
    finish
endif

fun! VbGetIndent(lnum)
    " labels and preprocessor get zero indent immediately
    let this_line = getline(a:lnum)
    let LABELS_OR_PREPROC = '^\s*\(\<\k\+\>:\s*$\|#.*\)'
    if this_line =~? LABELS_OR_PREPROC
	return 0
    endif

    " Find a non-blank line above the current line.
    " Skip over labels and preprocessor directives.
    let lnum = a:lnum
    while lnum > 0
	let lnum = prevnonblank(lnum - 1)
	let previous_line = getline(lnum)
	if previous_line !~? LABELS_OR_PREPROC
	    break
	endif
    endwhile

    " Hit the start of the file, use zero indent.
    if lnum == 0
	return 0
    endif

    let ind = indent(lnum)

    " Add
    if previous_line =~? '^\s*\<\(begin\|\%(\%(private\|public\|friend\)\s\+\)\=\%(function\|sub\|property\)\|select\|case\|default\|if\|else\|elseif\|do\|for\|while\|enum\|with\)\>'
	let ind = ind + shiftwidth()
    endif

    " Subtract
    if this_line =~? '^\s*\<end\>\s\+\<select\>'
	if previous_line !~? '^\s*\<select\>'
	    let ind = ind - 2 * shiftwidth()
	else
	    " this case is for an empty 'select' -- 'end select'
	    " (w/o any case statements) like:
	    "
	    " select case readwrite
	    " end select
	    let ind = ind - shiftwidth()
	endif
    elseif this_line =~? '^\s*\<\(end\|else\|elseif\|until\|loop\|next\|wend\)\>'
	let ind = ind - shiftwidth()
    elseif this_line =~? '^\s*\<\(case\|default\)\>'
	if previous_line !~? '^\s*\<select\>'
	    let ind = ind - shiftwidth()
	endif
    endif

    return ind
endfun

" vim:sw=4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Language:     Verilog HDL
" Maintainer:	Chih-Tsun Huang <cthuang@cs.nthu.edu.tw>
" Last Change:	2017 Aug 25 by Chih-Tsun Huang
" URL:		    http://www.cs.nthu.edu.tw/~cthuang/vim/indent/verilog.vim
"
" Credits:
"   Suggestions for improvement, bug reports by
"     Takuya Fujiwara <tyru.exe@gmail.com>
"     Thilo Six <debian@Xk2c.de>
"     Leo Butlero <lbutler@brocade.com>
"
" Buffer Variables:
"     b:verilog_indent_modules : indenting after the declaration
"				 of module blocks
"     b:verilog_indent_width   : indenting width
"     b:verilog_indent_verbose : verbose to each indenting
"

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetVerilogIndent()
setlocal indentkeys=!^F,o,O,0),=begin,=end,=join,=endcase
setlocal indentkeys+==endmodule,=endfunction,=endtask,=endspecify
setlocal indentkeys+==endconfig,=endgenerate,=endprimitive,=endtable
setlocal indentkeys+==`else,=`elsif,=`endif

" Only define the function once.
if exists("*GetVerilogIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

function GetVerilogIndent()

  if exists('b:verilog_indent_width')
    let offset = b:verilog_indent_width
  else
    let offset = shiftwidth()
  endif
  if exists('b:verilog_indent_modules')
    let indent_modules = offset
  else
    let indent_modules = 0
  endif

  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  let lnum2 = prevnonblank(lnum - 1)
  let curr_line  = getline(v:lnum)
  let last_line  = getline(lnum)
  let last_line2 = getline(lnum2)
  let ind  = indent(lnum)
  let ind2 = indent(lnum - 1)
  let offset_comment1 = 1
  " Define the condition of an open statement
  "   Exclude the match of //, /* or */
  let vlog_openstat = '\(\<or\>\|\([*/]\)\@<![*(,{><+-/%^&|!=?:]\([*/]\)\@!\)'
  " Define the condition when the statement ends with a one-line comment
  let vlog_comment = '\(//.*\|/\*.*\*/\s*\)'
  if exists('b:verilog_indent_verbose')
    let vverb_str = 'INDENT VERBOSE:'
    let vverb = 1
  else
    let vverb = 0
  endif

  " Indent according to last line
  " End of multiple-line comment
  if last_line =~ '\*/\s*$' && last_line !~ '/\*.\{-}\*/'
    let ind = ind - offset_comment1
    if vverb
      echo vverb_str "De-indent after a multiple-line comment."
    endif

  " Indent after if/else/for/case/always/initial/specify/fork blocks
  " Note: We exclude '`if' or '`else' and consider 'end else' 
  "       'end if' is redundant here
  elseif last_line =~ '^\s*\(end\)\=\s*`\@<!\<\(if\|else\)\>' ||
    \ last_line =~ '^\s*\<\(for\|case\%[[zx]]\)\>' ||
    \ last_line =~ '^\s*\<\(always\|initial\)\>' ||
    \ last_line =~ '^\s*\<\(specify\|fork\)\>'
    if last_line !~ '\(;\|\<end\>\)\s*' . vlog_comment . '*$' ||
      \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . vlog_comment . '*$'
      let ind = ind + offset
      if vverb | echo vverb_str "Indent after a block statement." | endif
    endif
  " Indent after function/task/config/generate/primitive/table blocks
  elseif last_line =~ '^\s*\<\(function\|task\|config\|generate\|primitive\|table\)\>'
    if last_line !~ '\<end\>\s*' . vlog_comment . '*$' ||
      \ last_line =~ '\(//\|/\*\).*\(;\|\<end\>\)\s*' . vlog_comment . '*$'
      let ind = ind + offset
      if vverb
	echo vverb_str "Indent after function/task block statement."
      endif
    endif

  " Indent after module/function/task/specify/fork blocks
  elseif last_line =~ '^\s*\<module\>'
    let ind = ind + indent_modules
    if vverb && indent_modules
      echo vverb_str "Indent after module statement."
    endif
    if last_line =~ '[(,]\s*' . vlog_comment . '*$' &&
      \ last_line !~ '\(//\|/\*\).*[(,]\s*' . vlog_comment . '*$'
      let ind = ind + offset
      if vverb
	echo vverb_str "Indent after a multiple-line module statement."
      endif
    endif

  " Indent after a 'begin' statement
  elseif last_line =~ '\(\<begin\>\)\(\s*:\s*\w\+\)*' . vlog_comment . '*$' &&
    \ last_line !~ '\(//\|/\*\).*\(\<begin\>\)' &&
    \ ( last_line2 !~ vlog_openstat . '\s*' . vlog_comment . '*$' ||
    \ last_line2 =~ '^\s*[^=!]\+\s*:\s*' . vlog_comment . '*$' )
    let ind = ind + offset
    if vverb | echo vverb_str "Indent after begin statement." | endif

  " De-indent for the end of one-line block
  elseif ( last_line !~ '\<begin\>' ||
    \ last_line =~ '\(//\|/\*\).*\<begin\>' ) &&
    \ last_line2 =~ '\<\(`\@<!if\|`\@<!else\|for\|always\|initial\)\>.*' .
      \ vlog_comment . '*$' &&
    \ last_line2 !~
      \ '\(//\|/\*\).*\<\(`\@<!if\|`\@<!else\|for\|always\|initial\)\>' &&
    \ last_line2 !~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
    \ ( last_line2 !~ '\<begin\>' ||
    \ last_line2 =~ '\(//\|/\*\).*\<begin\>' )
    let ind = ind - offset
    if vverb
      echo vverb_str "De-indent after the end of one-line statement."
    endif

    " Multiple-line statement (including case statement)
    " Open statement
    "   Ident the first open line
    elseif  last_line =~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
      \ last_line !~ '\(//\|/\*\).*' . vlog_openstat . '\s*$' &&
      \ last_line2 !~ vlog_openstat . '\s*' . vlog_comment . '*$'
      let ind = ind + offset
      if vverb | echo vverb_str "Indent after an open statement." | endif

    " Close statement
    "   De-indent for an optional close parenthesis and a semicolon, and only
    "   if there exists precedent non-whitespace char
    elseif last_line =~ ')*\s*;\s*' . vlog_comment . '*$' &&
      \ last_line !~ '^\s*)*\s*;\s*' . vlog_comment . '*$' &&
      \ last_line !~ '\(//\|/\*\).*\S)*\s*;\s*' . vlog_comment . '*$' &&
      \ ( last_line2 =~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
      \ last_line2 !~ ';\s*//.*$') &&
      \ last_line2 !~ '^\s*' . vlog_comment . '$'
      let ind = ind - offset
      if vverb | echo vverb_str "De-indent after a close statement." | endif

  " `ifdef or `ifndef or `elsif or `else
  elseif last_line =~ '^\s*`\<\(ifn\?def\|elsif\|else\)\>'
    let ind = ind + offset
    if vverb
      echo vverb_str "Indent after a `ifdef or `ifndef or `elsif or `else statement."
    endif

  endif

  " Re-indent current line

  " De-indent on the end of the block
  " join/end/endcase/endfunction/endtask/endspecify
  if curr_line =~ '^\s*\<\(join\|end\|endcase\)\>' ||
    \ curr_line =~ '^\s*\<\(endfunction\|endtask\|endspecify\)\>' ||
    \ curr_line =~ '^\s*\<\(endconfig\|endgenerate\|endprimitive\|endtable\)\>'
    let ind = ind - offset
    if vverb | echo vverb_str "De-indent the end of a block." | endif
  elseif curr_line =~ '^\s*\<endmodule\>'
    let ind = ind - indent_modules
    if vverb && indent_modules
      echo vverb_str "De-indent the end of a module."
    endif

  " De-indent on a stand-alone 'begin'
  elseif curr_line =~ '^\s*\<begin\>'
    if last_line !~ '^\s*\<\(function\|task\|specify\|module\|config\|generate\|primitive\|table\)\>' &&
      \ last_line !~ '^\s*\()*\s*;\|)\+\)\s*' . vlog_comment . '*$' &&
      \ ( last_line =~
	\ '\<\(`\@<!if\|`\@<!else\|for\|case\%[[zx]]\|always\|initial\)\>' ||
      \ last_line =~ ')\s*' . vlog_comment . '*$' ||
      \ last_line =~ vlog_openstat . '\s*' . vlog_comment . '*$' )
      let ind = ind - offset
      if vverb
	echo vverb_str "De-indent a stand alone begin statement."
      endif
    endif

  " De-indent after the end of multiple-line statement
  elseif curr_line =~ '^\s*)' &&
    \ ( last_line =~ vlog_openstat . '\s*' . vlog_comment . '*$' ||
    \ last_line !~ vlog_openstat . '\s*' . vlog_comment . '*$' &&
    \ last_line2 =~ vlog_openstat . '\s*' . vlog_comment . '*$' )
    let ind = ind - offset
    if vverb
      echo vverb_str "De-indent the end of a multiple statement."
    endif

  " De-indent `elsif or `else or `endif
  elseif curr_line =~ '^\s*`\<\(elsif\|else\|endif\)\>'
    let ind = ind - offset
    if vverb | echo vverb_str "De-indent `elsif or `else or `endif statement." | endif

  endif

  " Return the indentation
  return ind
endfunction

let &cpo = s:cpo_save
unlet s:cpo_save

" vim:sw=2
                        " VHDL indent ('93 syntax)
" Language:    VHDL
" Maintainer:  Gerald Lai <laigera+vim?gmail.com>
" Version:     1.62
" Last Change: 2017 Oct 17
" URL:         http://www.vim.org/scripts/script.php?script_id=1450

" only load this indent file when no other was loaded
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

" setup indent options for local VHDL buffer
setlocal indentexpr=GetVHDLindent()
setlocal indentkeys=!^F,o,O,0(,0)
setlocal indentkeys+==~begin,=~end\ ,=~end\	,=~is,=~select,=~when
setlocal indentkeys+==~if,=~then,=~elsif,=~else
setlocal indentkeys+==~case,=~loop,=~for,=~generate,=~record,=~units,=~process,=~block,=~function,=~component,=~procedure
setlocal indentkeys+==~architecture,=~configuration,=~entity,=~package

" constants
" not a comment
let s:NC = '\%(--.*\)\@<!'
" end of string
let s:ES = '\s*\%(--.*\)\=$'
" no "end" keyword in front
let s:NE = '\%(\<end\s\+\)\@<!'

" option to disable alignment of generic/port mappings
if !exists("g:vhdl_indent_genportmap")
  let g:vhdl_indent_genportmap = 1
endif

" option to disable alignment of right-hand side assignment "<=" statements
if !exists("g:vhdl_indent_rhsassign")
  let g:vhdl_indent_rhsassign = 1
endif

" only define indent function once
if exists("*GetVHDLindent")
  finish
endif

function GetVHDLindent()
  " store current line & string
  let curn = v:lnum
  let curs = getline(curn)

  " find previous line that is not a comment
  let prevn = prevnonblank(curn - 1)
  let prevs = getline(prevn)
  while prevn > 0 && prevs =~ '^\s*--'
    let prevn = prevnonblank(prevn - 1)
    let prevs = getline(prevn)
  endwhile
  let prevs_noi = substitute(prevs, '^\s*', '', '')

  " default indent starts as previous non-comment line's indent
  let ind = prevn > 0 ? indent(prevn) : 0
  " backup default
  let ind2 = ind

  " indent:   special; kill string so it would not affect other filters
  " keywords: "report" + string
  " where:    anywhere in current or previous line
  let s0 = s:NC.'\<report\>\s*".*"'
  if curs =~? s0
    let curs = ""
  endif
  if prevs =~? s0
    let prevs = ""
  endif

  " indent:   previous line's comment position, otherwise follow next non-comment line if possible
  " keyword:  "--"
  " where:    start of current line
  if curs =~ '^\s*--'
    let pn = curn - 1
    let ps = getline(pn)
    if curs =~ '^\s*--\s' && ps =~ '--'
      return indent(pn) + stridx(substitute(ps, '^\s*', '', ''), '--')
    else
      " find nextnonblank line that is not a comment
      let nn = nextnonblank(curn + 1)
      let ns = getline(nn)
      while nn > 0 && ns =~ '^\s*--'
        let nn = nextnonblank(nn + 1)
        let ns = getline(nn)
      endwhile
      let n = indent(nn)
      return n != -1 ? n : ind
    endif
  endif

  " ****************************************************************************************
  " indent:   align generic variables & port names
  " keywords: "procedure" + name, "generic", "map", "port" + "(", provided current line is part of mapping
  " where:    anywhere in previous 2 lines
  " find following previous non-comment line
  let pn = prevnonblank(prevn - 1)
  let ps = getline(pn)
  while pn > 0 && ps =~ '^\s*--'
    let pn = prevnonblank(pn - 1)
    let ps = getline(pn)
  endwhile
  if (curs =~ '^\s*)' || curs =~? '^\s*\%(\<\%(procedure\|generic\|map\|port\)\>.*\)\@<!\w\+\s*\w*\s*\((.*)\)*\s*\%(=>\s*\S\+\|:[^=]\@=\s*\%(\%(in\|out\|inout\|buffer\|linkage\)\>\|\s\+\)\)') && (prevs =~? s:NC.'\<\%(procedure\s\+\S\+\|generic\|map\|port\)\s*(\%(\s*\w\)\=' || (ps =~? s:NC.'\<\%(procedure\|generic\|map\|port\)'.s:ES && prevs =~ '^\s*('))
    " align closing ")" with opening "("
    if curs =~ '^\s*)'
      return ind2 + stridx(prevs_noi, '(')
    endif
    let m = matchend(prevs_noi, '(\s*\ze\w')
    if m != -1
      return ind2 + m
    else
      if g:vhdl_indent_genportmap
        return ind2 + stridx(prevs_noi, '(') + shiftwidth()
      else
        return ind2 + shiftwidth()
      endif
    endif
  endif

  " indent:   align conditional/select statement
  " keywords: variable + "<=" without ";" ending
  " where:    start of previous line
  if prevs =~? '^\s*\S\+\s*<=[^;]*'.s:ES
    if g:vhdl_indent_rhsassign
      return ind2 + matchend(prevs_noi, '<=\s*\ze.')
    else
      return ind2 + shiftwidth()
    endif
  endif

  " indent:   backtrace previous non-comment lines for next smaller or equal size indent
  " keywords: "end" + "record", "units"
  " where:    start of previous line
  " keyword:  ")"
  " where:    start of previous line
  " keyword:  without "<=" + ";" ending
  " where:    anywhere in previous line
  " keyword:  "=>" + ")" ending, provided current line does not begin with ")"
  " where:    anywhere in previous line
  " _note_:   indent allowed to leave this filter
  let m = 0
  if prevs =~? '^\s*end\s\+\%(record\|units\)\>'
    let m = 3
  elseif prevs =~ '^\s*)'
    let m = 1
  elseif prevs =~ s:NC.'\%(<=.*\)\@<!;'.s:ES || (curs !~ '^\s*)' && prevs =~ s:NC.'=>.*'.s:NC.')'.s:ES)
    let m = 2
  endif

  if m > 0
    let pn = prevnonblank(prevn - 1)
    let ps = getline(pn)
    while pn > 0
      let t = indent(pn)
      if ps !~ '^\s*--' && (t < ind || (t == ind && m == 3))
        " make sure one of these is true
        " keywords: variable + "<=" without ";" ending
        " where:    start of previous non-comment line
        " keywords: "procedure", "generic", "map", "port"
        " where:    anywhere in previous non-comment line
        " keyword:  "("
        " where:    start of previous non-comment line
        if m < 3 && ps !~? '^\s*\S\+\s*<=[^;]*'.s:ES
          if ps =~? s:NC.'\<\%(procedure\|generic\|map\|port\)\>' || ps =~ '^\s*('
            let ind = t
          endif
          break
        endif
        let ind = t
        if m > 1
          " find following previous non-comment line
          let ppn = prevnonblank(pn - 1)
          let pps = getline(ppn)
          while ppn > 0 && pps =~ '^\s*--'
            let ppn = prevnonblank(ppn - 1)
            let pps = getline(ppn)
          endwhile
          " indent:   follow
          " keyword:  "select"
          " where:    end of following previous non-comment line
          " keyword:  "type"
          " where:    start of following previous non-comment line
          if m == 2
            let s1 = s:NC.'\<select'.s:ES
            if ps !~? s1 && pps =~? s1
              let ind = indent(ppn)
            endif
          elseif m == 3
            let s1 = '^\s*type\>'
            if ps !~? s1 && pps =~? s1
              let ind = indent(ppn)
            endif
          endif
        endif
        break
      endif
      let pn = prevnonblank(pn - 1)
      let ps = getline(pn)
    endwhile
  endif

  " indent:   follow indent of previous opening statement, otherwise -sw
  " keyword:  "begin"
  " where:    anywhere in current line
  if curs =~? s:NC.'\<begin\>'
    " find previous opening statement of
    " keywords: "architecture", "block", "entity", "function", "generate", "procedure", "process"
    let s2 = s:NC.s:NE.'\<\%(architecture\|block\|entity\|function\|generate\|procedure\|process\)\>'

    let pn = prevnonblank(curn - 1)
    let ps = getline(pn)
    while pn > 0 && (ps =~ '^\s*--' || ps !~? s2)
      let pn = prevnonblank(pn - 1)
      let ps = getline(pn)

      if (ps =~? s:NC.'\<begin\>')
        return indent(pn) - shiftwidth()
      endif
    endwhile

    if (pn == 0)
      return ind - shiftwidth()
    else
      return indent(pn)
    endif
  endif

  " indent:   +sw if previous line is previous opening statement
  " keywords: "record", "units"
  " where:    anywhere in current line
  if curs =~? s:NC.s:NE.'\<\%(record\|units\)\>'
    " find previous opening statement of
    " keyword: "type"
    let s3 = s:NC.s:NE.'\<type\>'
    if curs !~? s3.'.*'.s:NC.'\<\%(record\|units\)\>.*'.s:ES && prevs =~? s3
      let ind = ind + shiftwidth()
    endif
    return ind
  endif

  " ****************************************************************************************
  " indent:   0
  " keywords: "architecture", "configuration", "entity", "library", "package"
  " where:    start of current line
  if curs =~? '^\s*\%(architecture\|configuration\|entity\|library\|package\)\>'
    return 0
  endif

  " indent:   maintain indent of previous opening statement
  " keyword:  "is"
  " where:    start of current line
  " find previous opening statement of
  " keywords: "architecture", "block", "configuration", "entity", "function", "package", "procedure", "process", "type"
  if curs =~? '^\s*\<is\>' && prevs =~? s:NC.s:NE.'\<\%(architecture\|block\|configuration\|entity\|function\|package\|procedure\|process\|type\)\>'
    return ind2
  endif

  " indent:   maintain indent of previous opening statement
  " keyword:  "then"
  " where:    start of current line
  " find previous opening statement of
  " keywords: "elsif", "if"
  if curs =~? '^\s*\<then\>' && prevs =~? s:NC.'\%(\<elsif\>\|'.s:NE.'\<if\>\)'
    return ind2
  endif

  " indent:   maintain indent of previous opening statement
  " keyword:  "generate"
  " where:    start of current line
  " find previous opening statement of
  " keywords: "for", "if"
  if curs =~? '^\s*\<generate\>' && prevs =~? s:NC.s:NE.'\%(\%(\<wait\s\+\)\@<!\<for\|\<if\)\>'
    return ind2
  endif

  " indent:   +sw
  " keywords: "block", "process"
  " removed:  "begin", "case", "elsif", "if", "loop", "record", "units", "while"
  " where:    anywhere in previous line
  if prevs =~? s:NC.s:NE.'\<\%(block\|process\)\>'
    return ind + shiftwidth()
  endif

  " indent:   +sw
  " keywords: "architecture", "configuration", "entity", "package"
  " removed:  "component", "for", "when", "with"
  " where:    start of previous line
  if prevs =~? '^\s*\%(architecture\|configuration\|entity\|package\)\>'
    return ind + shiftwidth()
  endif

  " indent:   +sw
  " keyword:  "select"
  " removed:  "generate", "is", "=>"
  " where:    end of previous line
  if prevs =~? s:NC.'\<select'.s:ES
    return ind + shiftwidth()
  endif

  " indent:   +sw
  " keyword:  "begin", "loop", "record", "units"
  " where:    anywhere in previous line
  " keyword:  "component", "else", "for"
  " where:    start of previous line
  " keyword:  "generate", "is", "then", "=>"
  " where:    end of previous line
  " _note_:   indent allowed to leave this filter
  if prevs =~? s:NC.'\%(\<begin\>\|'.s:NE.'\<\%(loop\|record\|units\)\>\)' || prevs =~? '^\s*\%(component\|else\|for\)\>' || prevs =~? s:NC.'\%('.s:NE.'\<generate\|\<\%(is\|then\)\|=>\)'.s:ES
    let ind = ind + shiftwidth()
  endif

  " ****************************************************************************************
  " indent:   -sw
  " keywords: "when", provided previous line does not begin with "when", does not end with "is"
  " where:    start of current line
  let s4 = '^\s*when\>'
  if curs =~? s4
    if prevs =~? s:NC.'\<is'.s:ES
      return ind
    elseif prevs !~? s4
      return ind - shiftwidth()
    else
      return ind2
    endif
  endif

  " indent:   -sw
  " keywords: "else", "elsif", "end" + "block", "for", "function", "generate", "if", "loop", "procedure", "process", "record", "units"
  " where:    start of current line
  let s5 = 'block\|for\|function\|generate\|if\|loop\|procedure\|process\|record\|units'
  if curs =~? '^\s*\%(else\|elsif\|end\s\+\%('.s5.'\)\)\>'
    if prevs =~? '^\s*\%(elsif\|'.s5.'\)'
      return ind
    else
      return ind - shiftwidth()
    endif
  endif

  " indent:   backtrace previous non-comment lines
  " keyword:  "end" + "case", "component"
  " where:    start of current line
  let m = 0
  if curs =~? '^\s*end\s\+case\>'
    let m = 1
  elseif curs =~? '^\s*end\s\+component\>'
    let m = 2
  endif

  if m > 0
    " find following previous non-comment line
    let pn = prevn
    let ps = getline(pn)
    while pn > 0
      if ps !~ '^\s*--'
        "indent:   -2sw
        "keywords: "end" + "case"
        "where:    start of previous non-comment line
        "indent:   -sw
        "keywords: "when"
        "where:    start of previous non-comment line
        "indent:   follow
        "keywords: "case"
        "where:    start of previous non-comment line
        if m == 1
          if ps =~? '^\s*end\s\+case\>'
            return indent(pn) - ¦  §  ¨                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      2 * shiftwidth()
          elseif ps =~? '^\s*when\>'
            return indent(pn) - shiftwidth()
          elseif ps =~? '^\s*case\>'
            return indent(pn)
          endif
        "indent:   follow
        "keyword:  "component"
        "where:    start of previous non-comment line
        elseif m == 2
          if ps =~? '^\s*component\>'
            return indent(pn)
          endif
        endif
      endif
      let pn = prevnonblank(pn - 1)
      let ps = getline(pn)
    endwhile
    return ind - shiftwidth()
  endif

  " indent:   -sw
  " keyword:  ")"
  " where:    start of current line
  if curs =~ '^\s*)'
    return ind - shiftwidth()
  endif

  " indent:   0
  " keywords: "end" + "architecture", "configuration", "entity", "package"
  " where:    start of current line
  if curs =~? '^\s*end\s\+\%(architecture\|configuration\|entity\|package\)\>'
    return 0
  endif

  " indent:   -sw
  " keywords: "end" + identifier, ";"
  " where:    start of current line
  "if curs =~? '^\s*end\s\+\w\+\>'
  if curs =~? '^\s*end\%(\s\|;'.s:ES.'\)'
    return ind - shiftwidth()
  endif

  " ****************************************************************************************
  " indent:   maintain indent of previous opening statement
  " keywords: without "procedure", "generic", "map", "port" + ":" but not ":=" + "in", "out", "inout", "buffer", "linkage", variable & ":="
  " where:    start of current line
  if curs =~? '^\s*\%(\<\%(procedure\|generic\|map\|port\)\>.*\)\@<!\w\+\s*\w*\s*:[^=]\@=\s*\%(\%(in\|out\|inout\|buffer\|linkage\)\>\|\w\+\s\+:=\)'
    return ind2
  endif

  " ****************************************************************************************
  " indent:     maintain indent of previous opening statement, corner case which
  "             does not end in ;, but is part of a mapping
  " keywords:   without "procedure", "generic", "map", "port" + ":" but not ":=", never + ;$ and
  "             prevline without "procedure", "generic", "map", "port" + ":" but not ":=" + eventually ;$
  " where:      start of current line
  if curs =~? '^\s*\%(\<\%(procedure\|generic\|map\|port\)\>.*\)\@<!\w\+\s*\w*\s*:[^=].*[^;].*$'
    if prevs =~? '^\s*\%(\<\%(procedure\|generic\|map\|port\)\>.*\)\@<!\w\+\s*\w*\s*:[^=].*;.*$'
      return ind2
    endif
  endif

  " return leftover filtered indent
  return ind
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim indent file
" Language:	Vim script
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Nov 03

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetVimIndent()
setlocal indentkeys+==end,=},=else,=cat,=finall,=END,0\\,0=\"\\\ 
setlocal indentkeys-=0#

let b:undo_indent = "setl indentkeys< indentexpr<"

" Only define the function once.
if exists("*GetVimIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

function GetVimIndent()
  let ignorecase_save = &ignorecase
  try
    let &ignorecase = 0
    return GetVimIndentIntern()
  finally
    let &ignorecase = ignorecase_save
  endtry
endfunc

let s:lineContPat = '^\s*\(\\\|"\\ \)'

function GetVimIndentIntern()
  " Find a non-blank line above the current line.
  let lnum = prevnonblank(v:lnum - 1)

  " The previous line, ignoring line continuation
  let prev_text_end = lnum > 0 ? getline(lnum) : ''

  " If the current line doesn't start with '\' or '"\ ' and below a line that
  " starts with '\' or '"\ ', use the indent of the line above it.
  let cur_text = getline(v:lnum)
  if cur_text !~ s:lineContPat
    while lnum > 0 && getline(lnum) =~ s:lineContPat
      let lnum = lnum - 1
    endwhile
  endif

  " At the start of the file use zero indent.
  if lnum == 0
    return 0
  endif

  " the start of the previous line, skipping over line continuation
  let prev_text = getline(lnum)
  let found_cont = 0

  " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
  " and :else.  Add it three times for a line that starts with '\' or '"\ '
  " after a line that doesn't (or g:vim_indent_cont if it exists).
  let ind = indent(lnum)

  " In heredoc indenting works completely differently.
  if has('syntax_items') 
    let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
    if syn_here =~ 'vimLetHereDocStop'
      " End of heredoc: use indent of matching start line
      let lnum = v:lnum - 1
      while lnum > 0
	let attr = synIDattr(synID(lnum, 1, 1), "name")
	if attr != '' && attr !~ 'vimLetHereDoc'
	  return indent(lnum)
	endif
	let lnum -= 1
      endwhile
      return 0
    endif
    if syn_here =~ 'vimLetHereDoc'
      if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
	" First line in heredoc: increase indent
	return ind + shiftwidth()
      endif
      " Heredoc continues: no change in indent
      return ind
    endif
  endif

  if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
    let found_cont = 1
    if exists("g:vim_indent_cont")
      let ind = ind + g:vim_indent_cont
    else
      let ind = ind + shiftwidth() * 3
    endif
  elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
    let ind = ind + shiftwidth()
  else
    " A line starting with :au does not increment/decrement indent.
    " A { may start a block or a dict.  Assume that when a } follows it's a
    " terminated dict.
    if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
      let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|fu\%[nction]\|def\|el\%[seif]\)\>\)')
      if i >= 0
	let ind += shiftwidth()
	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\|PatSep\)$'
	  let ind -= shiftwidth()
	endif
      endif
    endif
  endif

  " If the previous line contains an "end" after a pipe, but not in an ":au"
  " command.  And not when there is a backslash before the pipe.
  " And when syntax HL is enabled avoid a match inside a string.
  let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
  if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
    if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
      let ind = ind - shiftwidth()
    endif
  endif

  " For a line starting with "}" find the matching "{".  If it is at the start
  " of the line align with it, probably end of a block.
  " Use the mapped "%" from matchit to find the match, otherwise we may match
  " a { inside a comment or string.
  if cur_text =~ '^\s*}'
    if maparg('%') != ''
      exe v:lnum
      silent! normal %
      if line('.') < v:lnum && getline('.') =~ '^\s*{'
	let ind = indent('.')
      endif
    else
      " todo: use searchpair() to find a match
    endif
  endif

  " Below a line starting with "}" find the matching "{".  If it is at the
  " end of the line we must be below the end of a dictionary.
  if prev_text =~ '^\s*}'
    if maparg('%') != ''
      exe lnum
      silent! normal %
      if line('.') == lnum || getline('.') !~ '^\s*{'
	let ind = ind - shiftwidth()
      endif
    else
      " todo: use searchpair() to find a match
    endif
  endif

  " Below a line starting with "]" we must be below the end of a list.
  " Include a "}" and "},} in case a dictionary ends too.
  if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
    let ind = ind - shiftwidth()
  endif

  let ends_in_comment = has('syntax_items')
	\ && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'

  " A line ending in "{" or "[" is most likely the start of a dict/list literal,
  " indent the next line more.  Not for a continuation line or {{{.
  if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
    let ind = ind + shiftwidth()
  endif

  " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
  " :endfun, :enddef, :else and :augroup END.
  if cur_text =~ '^\s*\(ene\@!\|cat\|finall\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
    let ind = ind - shiftwidth()
  endif

  return ind
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:sw=2
                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim indent file
" Language:	Vroom (vim testing and executable documentation)
" Maintainer:	David Barnett (https://github.com/google/vim-ft-vroom)
" Last Change:	2014 Jul 23

if exists('b:did_indent')
  finish
endif
let b:did_indent = 1

let s:cpo_save = &cpo
set cpo-=C


let b:undo_indent = 'setlocal autoindent<'

setlocal autoindent


let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim indent file
" Language:     WebAssembly
" Maintainer:   rhysd <lin90162@yahoo.co.jp>
" Last Change:  Jul 29, 2018
" For bugs, patches and license go to https://github.com/rhysd/vim-wasm

if exists("b:did_indent")
    finish
endif
let b:did_indent = 1

" WebAssembly text format is S-expression. We can reuse LISP indentation
" logic.
setlocal indentexpr=lispindent('.')
setlocal noautoindent nosmartindent

let b:undo_indent = "setl lisp< indentexpr<"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      " Vim indent file
" Language:             XFree86 Configuration File
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-12-20

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetXF86ConfIndent()
setlocal indentkeys=!^F,o,O,=End
setlocal nosmartindent

if exists("*GetXF86ConfIndent")
  finish
endif

function GetXF86ConfIndent()
  let lnum = prevnonblank(v:lnum - 1)

  if lnum == 0
    return 0
  endif

  let ind = indent(lnum)

  if getline(lnum) =~? '^\s*\(Sub\)\=Section\>'
    let ind = ind + shiftwidth()
  endif

  if getline(v:lnum) =~? '^\s*End\(Sub\)\=Section\>'
    let ind = ind - shiftwidth()
  endif

  return ind
endfunction
                                                                                                                                                                                                                                                                                                                           " Vim indent file
" Language:	XHTML
" Maintainer:	Bram Moolenaar <Bram@vim.org> (for now)
" Last Change:	2005 Jun 24

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Handled like HTML for now.
runtime! indent/html.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim indent file
" Language:             xinetd.conf(5) configuration file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-12-20

if exists("b:did_indent")
  finish
endif
let b:did_indent = 1

setlocal indentexpr=GetXinetdIndent()
setlocal indentkeys=0{,0},!^F,o,O
setlocal nosmartindent

if exists("*GetXinetdIndent")
  finish
endif
let s:keepcpo= &cpo
set cpo&vim

function s:count_braces(lnum, count_open)
  let n_open = 0
  let n_close = 0
  let line = getline(a:lnum)
  let pattern = '[{}]'
  let i = match(line, pattern)
  while i != -1
    if synIDattr(synID(a:lnum, i + 1, 0), 'name') !~ 'ld\%(Comment\|String\)'
      if line[i] == '{'
        let n_open += 1
      elseif line[i] == '}'
        if n_open > 0
          let n_open -= 1
        else
          let n_close += 1
        endif
      endif
    endif
    let i = match(line, pattern, i + 1)
  endwhile
  return a:count_open ? n_open : n_close
endfunction

function GetXinetdIndent()
  let pnum = prevnonblank(v:lnum - 1)
  if pnum == 0
    return 0
  endif

  return indent(pnum) + s:count_braces(pnum, 1) * shiftwidth()
        \ - s:count_braces(v:lnum, 0) * shiftwidth()
endfunction

let &cpo = s:keepcpo
unlet s:keepcpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Language: XML
" Maintainer: Christian Brabandt <cb@256bit.org>
" Repository: https://github.com/chrisbra/vim-xml-ftplugin
" Previous Maintainer: Johannes Zellner <johannes@zellner.org>
" Last Changed: 2020 Nov 4th
" Last Change:
" 20200529 - Handle empty closing tags correctly
" 20191202 - Handle docbk filetype
" 20190726 - Correctly handle non-tagged data
" 20190204 - correctly handle wrap tags
"            https://github.com/chrisbra/vim-xml-ftplugin/issues/5
" 20190128 - Make sure to find previous tag
"            https://github.com/chrisbra/vim-xml-ftplugin/issues/4
" 20181116 - Fix indentation when tags start with a colon or an underscore
"            https://github.com/vim/vim/pull/926
" 20181022 - Do not overwrite indentkeys setting
"            https://github.com/chrisbra/vim-xml-ftplugin/issues/1
" 20180724 - Correctly indent xml comments https://github.com/vim/vim/issues/3200
"
" Notes:
"   1) does not indent pure non-xml code (e.g. embedded scripts)
"       2) will be confused by unbalanced tags in comments
"       or CDATA sections.
"       2009-05-26 patch by Nikolai Weibull
" TODO:     implement pre-like tags, see xml_indent_open / xml_indent_close

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
    finish
endif
let b:did_indent = 1
let s:keepcpo= &cpo
set cpo&vim

" [-- local settings (must come before aborting the script) --]
" Attention: Parameter use_syntax_check is used by the docbk.vim indent script
setlocal indentexpr=XmlIndentGet(v:lnum,1)
setlocal indentkeys=o,O,*<Return>,<>>,<<>,/,{,},!^F
" autoindent: used when the indentexpr returns -1
setlocal autoindent

if !exists('b:xml_indent_open')
    let b:xml_indent_open = '.\{-}<[:A-Z_a-z]'
    " pre tag, e.g. <address>
    " let b:xml_indent_open = '.\{-}<[/]\@!\(address\)\@!'
endif

if !exists('b:xml_indent_close')
    let b:xml_indent_close = '.\{-}</\|/>.\{-}'
    " end pre tag, e.g. </address>
    " let b:xml_indent_close = '.\{-}</\(address\)\@!'
endif

let &cpo = s:keepcpo
unlet s:keepcpo

" [-- finish, if the function already exists --]
if exists('*XmlIndentGet')
    finish
endif

let s:keepcpo= &cpo
set cpo&vim

fun! <SID>XmlIndentWithPattern(line, pat)
    let s = substitute('x'.a:line, a:pat, "\1", 'g')
    return strlen(substitute(s, "[^\1].*$", '', ''))
endfun

" [-- check if it's xml --]
fun! <SID>XmlIndentSynCheck(lnum)
    if &syntax != ''
        let syn1 = synIDattr(synID(a:lnum, 1, 1), 'name')
        let syn2 = synIDattr(synID(a:lnum, strlen(getline(a:lnum)) - 1, 1), 'name')
        if syn1 != '' && syn1 !~ 'xml' && syn2 != '' && syn2 !~ 'xml'
            " don't indent pure non-xml code
            return 0
        endif
    endif
    return 1
endfun

" [-- return the sum of indents of a:lnum --]
fun! <SID>XmlIndentSum(line, style, add)
    if <SID>IsXMLContinuation(a:line) && a:style == 0 && !<SID>IsXMLEmptyClosingTag(a:line)
        " no complete tag, add one additional indent level
        " but only for the current line
        return a:add + shiftwidth()
    elseif <SID>HasNoTagEnd(a:line)
        " no complete tag, return initial indent
        return a:add
    endif
    if a:style == match(a:line, '^\s*</')
        return (shiftwidth() *
        \  (<SID>XmlIndentWithPattern(a:line, b:xml_indent_open)
        \ - <SID>XmlIndentWithPattern(a:line, b:xml_indent_close)
        \ - <SID>XmlIndentWithPattern(a:line, '.\{-}/>'))) + a:add
    else
        return a:add
    endif
endfun

" Main indent function
fun! XmlIndentGet(lnum, use_syntax_check)
    " Find a non-empty line above the current line.
    if prevnonblank(a:lnum - 1) == 0
        " Hit the start of the file, use zero indent.
        return 0
    endif
    " Find previous line with a tag (regardless whether open or closed,
    " but always restrict the match to a line before the current one
    " Note: xml declaration: <?xml version="1.0"?>
    "       won't be found, as it is not a legal tag name
    let ptag_pattern = '\%(.\{-}<[/:A-Z_a-z]\)'. '\%(\&\%<'. a:lnum .'l\)'
    let ptag = search(ptag_pattern, 'bnW')
    " no previous tag
    if ptag == 0
        return 0
    endif

    let pline = getline(ptag)
    let pind  = indent(ptag)

    let syn_name_start = '' " Syntax element at start of line (excluding whitespace)
    let syn_name_end = ''   " Syntax element at end of line
    let curline = getline(a:lnum)
    if a:use_syntax_check
        let check_lnum = <SID>XmlIndentSynCheck(ptag)
        let check_alnum = <SID>XmlIndentSynCheck(a:lnum)
        if check_lnum == 0 || check_alnum == 0
            return indent(a:lnum)
        endif
        let syn_name_end   = synIDattr(synID(a:lnum, strlen(curline) - 1, 1), 'name')
        let syn_name_start = synIDattr(synID(a:lnum, match(curline, '\S') + 1, 1), 'name')
        let prev_syn_name_end   = synIDattr(synID(ptag, strlen(pline) - 1, 1), 'name')
        " not needed (yet?)
        " let prev_syn_name_start = synIDattr(synID(ptag, match(pline, '\S') + 1, 1), 'name')
    endif

    if syn_name_end =~ 'Comment' && syn_name_start =~ 'Comment'
        return <SID>XmlIndentComment(a:lnum)
    elseif empty(syn_name_start) && empty(syn_name_end) && a:use_syntax_check
        " non-xml tag content: use indent from 'autoindent'
        if pline =~ b:xml_indent_close
            return pind
        elseif !empty(prev_syn_name_end)
            " only indent by an extra shiftwidth, if the previous line ends
            " with an XML like tag
           return pind + shiftwidth()
        else
            " no extra indent, looks like a text continuation line
           return pind
        endif
    endif

    " Get indent from previous tag line
    let ind = <SID>XmlIndentSum(pline, -1, pind)
    " Determine indent from current line
    let ind = <SID>XmlIndentSum(curline, 0, ind)
    return ind
endfun

func! <SID>IsXMLContinuation(line)
    " Checks, whether or not the line matches a start-of-tag
    return a:line !~ '^\s*<' && &ft is# 'xml'
endfunc

func! <SID>HasNoTagEnd(line)
    " Checks whether or not the line matches '>' (so finishes a tag)
    return a:line !~ '>\s*$'
endfunc

func! <SID>IsXMLEmptyClosingTag(line)
    " Checks whether the line ends with an empty closing tag such as <lb/>
    return a:line =~? '<[^>]*/>\s*$'
endfunc

" return indent for a commented line,
" the middle part might be indented one additional level
func! <SID>XmlIndentComment(lnum)
    let ptagopen = search('.\{-}<[:A-Z_a-z]\_[^/]\{-}>.\{-}', 'bnW')
    let ptagclose = search(b:xml_indent_close, 'bnW')
    if getline(a:lnum) =~ '<!--'
        " if previous tag was a closing tag, do not add
        " one additional level of indent
        if ptagclose > ptagopen && a:lnum > ptagclose
            " If the previous tag was closed on the same line as it was
            " declared, we should indent with its indent level.
            if !<SID>IsXMLContinuation(getline(ptagclose))
                return indent(ptagclose)
            else
                return indent(ptagclose) - shiftwidth()
            endif
        elseif ptagclose == ptagopen
            return indent(ptagclose)
        else
            " start of comment, add one indentation level
            return indent(ptagopen) + shiftwidth()
        endif
    elseif getline(a:lnum) =~ '-->'
        " end of comment, same as start of comment
        return indent(search('<!--', 'bnW'))
    else
        " middle part of comment, add one additional level
        return indent(search('<!--', 'bnW')) + shiftwidth()
    endif
endfunc

let &cpo = s:keepcpo
unlet s:keepcpo

" vim:ts=4 et sts=-1 sw=0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            " Vim indent file
" Language: 	.xsd files (XML Schema)
" Maintainer:	Nobody
" Last Change:	2005 Jun 09

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Use XML formatting rules
runtime! indent/xml.vim

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   " Vim indent file
" Language:    XSLT .xslt files
" Maintainer:  David Fishburn <fishburn@ianywhere.com>
" Last Change: Wed May 14 2003 8:48:41 PM

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

" Use XML formatting rules
runtime! indent/xml.vim

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       " Vim indent file
" Language:             YACC input file
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2006-12-20

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
  finish
endif

let b:did_indent = 1

setlocal indentexpr=GetYaccIndent()
setlocal indentkeys=!^F,o,O
setlocal nosmartindent

" Only define the function once.
if exists("*GetYaccIndent")
  finish
endif

function GetYaccIndent()
  if v:lnum == 1
    return 0
  endif

  let ind = indent(v:lnum - 1)
  let line = getline(v:lnum - 1)

  if line == ''
    let ind = 0
  elseif line =~ '^\w\+\s*:'
    let ind = ind + matchend(line, '^\w\+\s*')
  elseif line =~ '^\s*;'
    let ind = 0
  else
    let ind = indent(v:lnum)
  endif

  return ind
endfunction
                                                                                                                                                                                                                                                   " Vim indent file
" Language:	YAML
" Maintainer:	Nikolai Pavlov <zyx.vim@gmail.com>
" Last Update:	Lukas Reineke
" Last Change:	2021 Aug 13

" Only load this indent file when no other was loaded.
if exists('b:did_indent')
  finish
endif

let b:did_indent = 1

setlocal indentexpr=GetYAMLIndent(v:lnum)
setlocal indentkeys=!^F,o,O,0#,0},0],<:>,0-
setlocal nosmartindent

let b:undo_indent = 'setlocal indentexpr< indentkeys< smartindent<'

" Only define the function once.
if exists('*GetYAMLIndent')
    finish
endif

let s:save_cpo = &cpo
set cpo&vim

function s:FindPrevLessIndentedLine(lnum, ...)
    let prevlnum = prevnonblank(a:lnum-1)
    let curindent = a:0 ? a:1 : indent(a:lnum)
    while           prevlnum
                \&&  indent(prevlnum) >=  curindent
                \&& getline(prevlnum) !~# '^\s*#'
        let prevlnum = prevnonblank(prevlnum-1)
    endwhile
    return prevlnum
endfunction

function s:FindPrevLEIndentedLineMatchingRegex(lnum, regex)
    let plilnum = s:FindPrevLessIndentedLine(a:lnum, indent(a:lnum)+1)
    while plilnum && getline(plilnum) !~# a:regex
        let plilnum = s:FindPrevLessIndentedLine(plilnum)
    endwhile
    return plilnum
endfunction

let s:mapkeyregex='\v^\s*\#@!\S@=%(\''%([^'']|\''\'')*\'''.
                \                 '|\"%([^"\\]|\\.)*\"'.
                \                 '|%(%(\:\ )@!.)*)\:%(\ |$)'
let s:liststartregex='\v^\s*%(\-%(\ |$))'

let s:c_ns_anchor_char = '\v%([\n\r\uFEFF \t,[\]{}]@!\p)'
let s:c_ns_anchor_name = s:c_ns_anchor_char.'+'
let s:c_ns_anchor_property =  '\v\&'.s:c_ns_anchor_name

let s:ns_word_char = '\v[[:alnum:]_\-]'
let s:ns_tag_char  = '\v%('.s:ns_word_char.'|[#/;?:@&=+$.~*''()])'
let s:c_named_tag_handle     = '\v\!'.s:ns_word_char.'+\!'
let s:c_secondary_tag_handle = '\v\!\!'
let s:c_primary_tag_handle   = '\v\!'
let s:c_tag_handle = '\v%('.s:c_named_tag_handle.
            \            '|'.s:c_secondary_tag_handle.
            \            '|'.s:c_primary_tag_handle.')'
let s:c_ns_shorthand_tag = '\v'.s:c_tag_handle . s:ns_tag_char.'+'
let s:c_non_specific_tag = '\v\!'
let s:ns_uri_char  = '\v%('.s:ns_word_char.'\v|[#/;?:@&=+$,.!~*''()[\]])'
let s:c_verbatim_tag = '\v\!\<'.s:ns_uri_char.'+\>'
let s:c_ns_tag_property = '\v'.s:c_verbatim_tag.
            \               '\v|'.s:c_ns_shorthand_tag.
            \               '\v|'.s:c_non_specific_tag

let s:block_scalar_header = '\v[|>]%([+-]?[1-9]|[1-9]?[+-])?'

function GetYAMLIndent(lnum)
    if a:lnum == 1 || !prevnonblank(a:lnum-1)
        return 0
    endif

    let prevlnum = prevnonblank(a:lnum-1)
    let previndent = indent(prevlnum)

    let line = getline(a:lnum)
    if line =~# '^\s*#' && getline(a:lnum-1) =~# '^\s*#'
        " Comment blocks should have identical indent
        return previndent
    elseif line =~# '^\s*[\]}]'
        " Lines containing only closing braces should have previous indent
        return indent(s:FindPrevLessIndentedLine(a:lnum))
    endif

    " Ignore comment lines when calculating indent
    while getline(prevlnum) =~# '^\s*#'
        let prevlnum = prevnonblank(prevlnum-1)
        if !prevlnum
            return previndent
        endif
    endwhile

    let prevline = getline(prevlnum)
    let previndent = indent(prevlnum)

    " Any examples below assume that shiftwidth=2
    if prevline =~# '\v[{[:]$|[:-]\ [|>][+\-]?%(\s+\#.*|\s*)$'
        " Mapping key:
        "     nested mapping: ...
        "
        " - {
        "     key: [
        "         list value
        "     ]
        " }
        "
        " - |-
        "     Block scalar without indentation indicator
        return previndent+shiftwidth()
    elseif prevline =~# '\v[:-]\ [|>]%(\d+[+\-]?|[+\-]?\d+)%(\#.*|\s*)$'
        " - |+2
        "   block scalar with indentation indicator
        "#^^ indent+2, not indent+shiftwidth
        return previndent + str2nr(matchstr(prevline,
                    \'\v([:-]\ [|>])@<=[+\-]?\d+%([+\-]?%(\s+\#.*|\s*)$)@='))
    elseif prevline =~# '\v\"%([^"\\]|\\.)*\\$'
        "    "Multiline string \
        "     with escaped end"
        let qidx = match(prevline, '\v\"%([^"\\]|\\.)*\\')
        return virtcol([prevlnum, qidx+1])
    elseif line =~# s:liststartregex
        " List line should have indent equal to previous list line unless it was 
        " caught by one of the previous rules
        return indent(s:FindPrevLEIndentedLineMatchingRegex(a:lnum,
                    \                                       s:liststartregex))
    elseif line =~# s:mapkeyregex
        " Same for line containing mapping key
        let prevmapline = s:FindPrevLEIndentedLineMatchingRegex(a:lnum,
                    \                                           s:mapkeyregex)
        if getline(prevmapline) =~# '^\s*- '
            return indent(prevmapline) + 2
        else
            return indent(prevmapline)
        endif
    elseif prevline =~# '^\s*- '
        " - List with
        "   multiline scalar
        return previndent+2
    elseif prevline =~# s:mapkeyregex . '\v\s*%(%('.s:c_ns_tag_property.
                \                              '\v|'.s:c_ns_anchor_property.
                \                              '\v|'.s:block_scalar_header.
                \                             '\v)%(\s+|\s*%(\#.*)?$))*'
        " Mapping with: value
        "     that is multiline scalar
        return previndent+shiftwidth()
    endif
    return previndent
endfunction

let &cpo = s:save_cpo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 " Vim indent file
" Language:	Zimbu
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2021 Sep 26

" Only load this indent file when no other was loaded.
if exists("b:did_indent")
   finish
endif
let b:did_indent = 1

setlocal ai nolisp nocin
setlocal indentexpr=GetZimbuIndent(v:lnum)
setlocal indentkeys=0{,0},!^F,o,O,0=ELSE,0=ELSEIF,0=CASE,0=DEFAULT,0=FINALLY

" We impose recommended defaults: no Tabs, 'shiftwidth' = 2
setlocal sw=2 et

let b:undo_indent = "setl ai< cin< et< indentkeys< indentexpr< lisp< sw<"

" Only define the function once.
if exists("*GetZimbuIndent")
  finish
endif

let s:cpo_save = &cpo
set cpo&vim

" Come here when loading the script the first time.

let s:maxoff = 50	" maximum number of lines to look backwards for ()

func GetZimbuIndent(lnum)
  let prevLnum = prevnonblank(a:lnum - 1)
  if prevLnum == 0
    " This is the first non-empty line, use zero indent.
    return 0
  endif

  " Taken from Python indenting:
  " If the previous line is inside parenthesis, use the indent of the starting
  " line.
  " Trick: use the non-existing "dummy" variable to break out of the loop when
  " going too far back.
  call cursor(prevLnum, 1)
  let parlnum = searchpair('(\|{\|\[', '', ')\|}\|\]', 'nbW',
	  \ "line('.') < " . (prevLnum - s:maxoff) . " ? dummy :"
	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
	  \ . " =~ '\\(Comment\\|String\\|Char\\)$'")
  if parlnum > 0
    let plindent = indent(parlnum)
    let plnumstart = parlnum
  else
    let plindent = indent(prevLnum)
    let plnumstart = prevLnum
  endif


  " When inside parenthesis: If at the first line below the parenthesis add
  " two 'shiftwidth', otherwise same as previous line.
  " i = (a
  "       + b
  "       + c)
  call cursor(a:lnum, 1)
  let p = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
	  \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
	  \ . " =~ '\\(Comment\\|String\\|Char\\)$'")
  if p > 0
    if p == prevLnum
      " When the start is inside parenthesis, only indent one 'shiftwidth'.
      let pp = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
	  \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
	  \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
	  \ . " =~ '\\(Comment\\|String\\|Char\\)$'")
      if pp > 0
	return indent(prevLnum) + shiftwidth()
      endif
      return indent(prevLnum) + shiftwidth() * 2
    endif
    if plnumstart == p
      return indent(prevLnum)
    endif
    return plindent
  endif

  let prevline = getline(prevLnum)
  let thisline = getline(a:lnum)

  " If this line is not a comment and the previous one is then move the
  " previous line further back.
  if thisline !~ '^\s*#'
    while prevline =~ '^\s*#'
      let prevLnum = prevnonblank(prevLnum - 1)
      if prevLnum == 0
	" Only comment lines before this, no indent
	return 0
      endif
      let prevline = getline(prevLnum)
      let plindent = indent(prevLnum)
    endwhile
  endif

  if prevline =~ '^\s*\(IF\|\|ELSEIF\|ELSE\|GENERATE_IF\|\|GENERATE_ELSEIF\|GENERATE_ELSE\|WHILE\|REPEAT\|TRY\|CATCH\|FINALLY\|FOR\|DO\|SWITCH\|CASE\|DEFAULT\|FUNC\|VIRTUAL\|ABSTRACT\|DEFINE\|REPLACE\|FINAL\|PROC\|MAIN\|NEW\|ENUM\|CLASS\|INTERFACE\|BITS\|MODULE\|SHARED\)\>'
    let plindent += shiftwidth()
  endif
  if thisline =~ '^\s*\(}\|ELSEIF\>\|ELSE\>\|CATCH\|FINALLY\|GENERATE_ELSEIF\>\|GENERATE_ELSE\>\|UNTIL\>\)'
    let plindent -= shiftwidth()
  endif
  if thisline =~ '^\s*\(CASE\>\|DEFAULT\>\)' && prevline !~ '^\s*SWITCH\>'
    let plindent -= shiftwidth()
  endif

  " line up continued comment that started after some code
  "   String something   # comment comment
  "                      # comment
  if a:lnum == prevLnum + 1 && thisline =~ '^\s*#' && prevline !~ '^\s*#'
    let n = match(prevline, '#')
    if n > 1
      let plindent = n
    endif
  endif

  return plindent
endfunc

let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                     " Vim indent file
" Language:             Zsh shell script
" Maintainer:           Christian Brabandt <cb@256bit.org>
" Previous Maintainer:  Nikolai Weibull <now@bitwi.se>
" Latest Revision:      2015-05-29
" License:              Vim (see :h license)
" Repository:           https://github.com/chrisbra/vim-zsh

if exists("b:did_indent")
  finish
endif

" Same as sh indenting for now.
runtime! indent/sh.vim
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Vim support file to switch on loading indent files for file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2008 Feb 22

if exists("did_indent_on")
  finish
endif
let did_indent_on = 1

augroup filetypeindent
  au FileType * call s:LoadIndent()
  func! s:LoadIndent()
    if exists("b:undo_indent")
      exe b:undo_indent
      unlet! b:undo_indent b:did_indent
    endif
    let s = expand("<amatch>")
    if s != ""
      if exists("b:did_indent")
	unlet b:did_indent
      endif

      " When there is a dot it is used to separate filetype names.  Thus for
      " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
      for name in split(s, '\.')
	exe 'runtime! indent/' . name . '.vim'
      endfor
    endif
  endfunc
augroup END
                                                                                                                                                                                                                                                                 " Vim support file to switch off loading indent files for file types
"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2001 Jun 11

if exists("did_indent_on")
  unlet did_indent_on
endif

" Remove all autocommands in the filetypeindent group
silent! au! filetypeindent *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      °   .   n   ..  ±   
README.txt  ²   editexisting.vim³   hanoi   ·   justify.vim ¸   less.bat¹   less.sh º   less.vim»   life¾   matchit.vim ¿   mazeÈ   shellmenu.vim   É   swapmous.vimÊ  urm                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     The macros in the maze, hanoi and urm directories can be used to test Vim for
vi compatibility.  They have been written for vi to show its unlimited
possibilities.	The life macros can be used for performance comparisons.

hanoi	Macros that solve the tower of hanoi problem.
life	Macros that run Conway's game of life.
maze	Macros that solve a maze (amazing!).
urm	Macros that simulate a simple computer: "Universal Register Machine"



The other files contain some handy utilities.  They also serve as examples for
how to use Vi and Vim functionality.

less.sh + less.vim	make Vim work like less (or more)



The following have been moved to an optional package.  Add the command to your
vimrc file to use the package:

packadd! dvorak		" Dvorak keyboard support; adds mappings

packadd! editexisting	" when editing a file that is already edited with
			" another Vim instance, go to that Vim instance

packadd! justify	" justifying text.

packadd! matchit	" makes the % command work better

packadd! shellmenu	" menus for editing shell scripts in the GUI version

packadd! swapmouse	" swap left and right mouse buttons
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                " Load the editexisting package.
" For those users who were loading the editexisting plugin from here.
packadd editexisting
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ³   .   °   ..  ´   click.meµ   	hanoi.vim   ¶  Äposter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

See Vim solve the towers of Hanoi!

Instructions:
   type ":so hanoi.vim<RETURN>" to load the macros
   type "g" to start it

and watch it go.

     to quit type ":q!<RETURN>"
to interrupt type CTRL-C

(This text will disappear as soon as you type "g")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 set remap
set noterse
set wrapscan
" to set the height of the tower, change the digit in the following
" two lines to the height you want (select from 1 to 9)
map t 7
map! t 7
map L 1G/tX/^0$P1GJ$An$BGC0e$X0E0F$X/T@f@h$A1GJ@f0l$Xn$PU
map g IL

map J /^0[^t]*$
map X x
map P p
map U L
map A "fyl
map B "hyl
map C "fp
map e "fy2l
map E "hp
map F "hy2l

" initialisations:
" KM	cleanup buffer
" Y	create tower of desired height
" NOQ	copy it and insert a T
" NO	copy this one
" S	change last char into a $
" R	change last char in previous line into a n
" T	insert two lines containing a zero
" V	add a last line containing a backslash
map I KMYNOQNOSkRTV

"create empty line
map K 1Go

"delete to end of file
map M dG

"yank one line
map N yy

"put
map O p

"delete more than height-of-tower characters
map q tllD

"create a tower of desired height
map Y o0123456789Z0q

"insert a T in column 1
map Q 0iT

"substitute last character with a n
map R $rn

"substitute last character with a $
map S $r$

"insert two lines containing a zero
map T ko00

"add a backslash at the end
map V Go/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Article 2913 of alt.sources:
Path: oce-rd1!hp4nl!mcsun!uunet!munnari.oz.au!metro!cluster!swift!softway!otc!gregm
From: gregm@otc.otca.oz.au (Greg McFarlane)
Newsgroups: comp.sources.d,alt.sources,comp.editors
Subject: VI SOLVES HANOI
Message-ID: <2323@otc.otca.oz>
Date: 19 Feb 91 01:32:14 GMT
Sender: news@otc.otca.oz
Reply-To: gregm@otc.otca.oz.au (Greg McFarlane)
Organization: OTC Development Unit, Australia
Lines: 80
Xref: oce-rd1 comp.sources.d:5702 alt.sources:2913 comp.editors:2313

Submitted-by: gregm@otc.otca.oz.au
Archive-name: hanoi.vi.macros/part01

Everyone seems to be writing stupid Tower of Hanoi programs.
Well, here is the stupidest of them all: the hanoi solving vi macros.

Save this article, unshar it, and run uudecode on hanoi.vi.macros.uu.
This will give you the macro file hanoi.vi.macros.
Then run vi (with no file: just type "vi") and type:
	:so hanoi.vi.macros
	g
and watch it go.

The default height of the tower is 7 but can be easily changed by editing
the macro file.

The disks aren't actually shown in this version, only numbers representing
each disk, but I believe it is possible to write some macros to show the
disks moving about as well. Any takers?

(For maze solving macros, see alt.sources or comp.editors)

Greg
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     " Load the justify package.
" For those users who were loading the justify plugin from here.
packadd justify
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   @echo off
rem batch file to start Vim with less.vim.
rem Read stdin if no arguments were given.
rem Written by Ken Takata.

if "%1"=="" (
  vim --cmd "let no_plugin_maps = 1" -c "runtime! macros/less.vim" -
) else (
  vim --cmd "let no_plugin_maps = 1" -c "runtime! macros/less.vim" %*
)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #!/bin/sh
# Shell script to start Vim with less.vim.
# Read stdin if no arguments were given and stdin was redirected.

if test -t 1; then
  if test $# = 0; then
    if test -t 0; then
      echo "Missing filename" 1>&2
      exit
    fi
    vim --cmd 'let no_plugin_maps = 1' -c 'runtime! macros/less.vim' -
  else
    vim --cmd 'let no_plugin_maps = 1' -c 'runtime! macros/less.vim' "$@"
  fi
else
  # Output is not a terminal, cat arguments or stdin
  if test $# = 0; then
    if test -t 0; then
      echo "Missing filename" 1>&2
      exit
    fi
    cat
  else
    cat "$@"
  fi
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                    " Vim script to work like "less"
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2020 Dec 17

" Avoid loading this file twice, allow the user to define his own script.
if exists("loaded_less")
  finish
endif
let loaded_less = 1

" If not reading from stdin, skip files that can't be read.
" Exit if there is no file at all.
if argc() > 0
  let s:i = 0
  while 1
    if filereadable(argv(s:i))
      if s:i != 0
	sleep 3
      endif
      break
    endif
    if isdirectory(argv(s:i))
      echomsg "Skipping directory " . argv(s:i)
    elseif getftime(argv(s:i)) < 0
      echomsg "Skipping non-existing file " . argv(s:i)
    else
      echomsg "Skipping unreadable file " . argv(s:i)
    endif
    echo "\n"
    let s:i = s:i + 1
    if s:i == argc()
      quit
    endif
    next
  endwhile
endif

" we don't want 'compatible' here
if &cp
  set nocp
endif

" enable syntax highlighting if not done already
if !get(g:, 'syntax_on', 0)
  syntax enable
endif

set so=0
set hlsearch
set incsearch
nohlsearch
" Don't remember file names and positions
set viminfo=
set nows
" Inhibit screen updates while searching
let s:lz = &lz
set lz

" Allow the user to define a function, which can set options specifically for
" this script.
if exists('*LessInitFunc')
  call LessInitFunc()
endif

" Used after each command: put cursor at end and display position
if &wrap
  noremap <SID>L L0:redraw<CR>:file<CR>
  au VimEnter * normal! L0
else
  noremap <SID>L Lg0:redraw<CR>:file<CR>
  au VimEnter * normal! Lg0
endif

" When reading from stdin don't consider the file modified.
au VimEnter * set nomod

" Can't modify the text or write the file.
set nomodifiable readonly

" Give help
noremap h :call <SID>Help()<CR>
map H h
fun! s:Help()
  echo "<Space>   One page forward          b         One page backward"
  echo "d         Half a page forward       u         Half a page backward"
  echo "<Enter>   One line forward          k         One line backward"
  echo "G         End of file               g         Start of file"
  echo "N%        percentage in file"
  echo "\n"
  echo "/pattern  Search for pattern        ?pattern  Search backward for pattern"
  echo "n         next pattern match        N         Previous pattern match"
  if &foldmethod != "manual"
  echo "\n"
    echo "zR        open all folds            zm        increase fold level"
  endif
  echo "\n"
  echo ":n<Enter> Next file                 :p<Enter> Previous file"
  echo "\n"
  echo "q         Quit                      v         Edit file"
  let i = input("Hit Enter to continue")
endfun

" Scroll one page forward
noremap <script> <Space> :call <SID>NextPage()<CR><SID>L
map <C-V> <Space>
map f <Space>
map <C-F> <Space>
map <PageDown> <Space>
map <kPageDown> <Space>
map <S-Down> <Space>
" If 'foldmethod' was changed keep the "z" commands, e.g. "zR" to open all
" folds.
if &foldmethod == "manual"
  map z <Space>
endif
map <Esc><Space> <Space>
fun! s:NextPage()
  if line(".") == line("$")
    if argidx() + 1 >= argc()
      " Don't quit at the end of the last file
      return
    endif
    next
    1
  else
    exe "normal! \<C-F>"
  endif
endfun

" Re-read file and page forward "tail -f"
map F :e<CR>G<SID>L:sleep 1<CR>F

" Scroll half a page forward
noremap <script> d <C-D><SID>L
map <C-D> d

" Scroll one line forward
noremap <script> <CR> <C-E><SID>L
map <C-N> <CR>
map e <CR>
map <C-E> <CR>
map j <CR>
map <C-J> <CR>
map <Down> <CR>

" Scroll one page backward
noremap <script> b <C-B><SID>L
map <C-B> b
map <PageUp> b
map <kPageUp> b
map <S-Up> b
map w b
map <Esc>v b

" Scroll half a page backward
noremap <script> u <C-U><SID>L
noremap <script> <C-U> <C-U><SID>L

" Scroll one line backward
noremap <script> k <C-Y><SID>L
map y k
map <C-Y> k
map <C-P> k
map <C-K> k
map <Up> k

" Redraw
noremap <script> r <C-L><SID>L
noremap <script> <C-R> <C-L><SID>L
noremap <script> R <C-L><SID>L

" Start of file
noremap <script> g gg<SID>L
map < g
map <Esc>< g
map <Home> g
map <kHome> g

" End of file
noremap <script> G G<SID>L
map > G
map <Esc>> G
map <End> G
map <kEnd> G

" Go to percentage
noremap <script> % %<SID>L
map p %

" Search
noremap <script> / H$:call <SID>Forward()<CR>/
if &wrap
  noremap <script> ? H0:call <SID>Backward()<CR>?
else
  noremap <script> ? Hg0:call <SID>Backward()<CR>?
endif

fun! s:Forward()
  " Searching forward
  noremap <script> n H$nzt<SID>L
  if &wrap
    noremap <script> N H0Nzt<SID>L
  else
    noremap <script> N Hg0Nzt<SID>L
  endif
  cnoremap <silent> <script> <CR> <CR>:cunmap <lt>CR><CR>zt<SID>L
endfun

fun! s:Backward()
  " Searching backward
  if &wrap
    noremap <script> n H0nzt<SID>L
  else
    noremap <script> n Hg0nzt<SID>L
  endif
  noremap <script> N H$Nzt<SID>L
  cnoremap <silent> <script> <CR> <CR>:cunmap <lt>CR><CR>zt<SID>L
endfun

call s:Forward()
cunmap <CR>

" Quitting
noremap q :q<CR>

" Switch to editing (switch off less mode)
map v :silent call <SID>End()<CR>
fun! s:End()
  set ma
  if exists('s:lz')
    let &lz = s:lz
  endif
  unmap h
  unmap H
  unmap <Space>
  unmap <C-V>
  unmap f
  unmap <C-F>
  unmap z
  unmap <Esc><Space>
  unmap F
  unmap d
  unmap <C-D>
  unmap <CR>
  unmap <C-N>
  unmap e
  unmap <C-E>
  unmap j
  unmap <C-J>
  unmap b
  unmap <C-B>
  unmap w
  unmap <Esc>v
  unmap u
  unmap <C-U>
  unmap k
  unmap y
  unmap <C-Y>
  unmap <C-P>
  unmap <C-K>
  unmap r
  unmap <C-R>
  unmap R
  unmap g
  unmap <
  unmap <Esc><
  unmap G
  unmap >
  unmap <Esc>>
  unmap %
  unmap p
  unmap n
  unmap N
  unmap q
  unmap v
  unmap /
  unmap ?
  unmap <Up>
  unmap <Down>
  unmap <PageDown>
  unmap <kPageDown>
  unmap <PageUp>
  unmap <kPageUp>
  unmap <S-Down>
  unmap <S-Up>
  unmap <Home>
  unmap <kHome>
  unmap <End>
  unmap <kEnd>
endfun

" vim: sw=2
                                                                                                                                                                                                                                                                                                                                                                                                                 »   .   °   ..  ¼   click.me½  Ølife.vim                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
To run the "Conway's game of life" macros:

  1.  Type ":so life.vim".  This loads the macros.
  2.  Type "g" to run the macros.
  3.  Type CTRL-C to interrupt.
  4.  Type ":q!" to get out.

See life.vim for more advanced usage.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " Macros to play Conway's Game of Life in vi
" Version 1.0m: edges wrap
" by Eli-the-Bearded Benjamin Elijah Griffin <vim@eli.users.panix.com>
" Sept 1996
" This file may be free distributed so long as these credits remain unchanged.
"
" Modified by Bram Moolenaar (Bram@vim.org), 1996 Sept 10
" - Made it quite a bit faster, but now needs search patterns in the text
" - Changed the order of mappings to top-down.
" - Made "g" run the whole thing, "C" run one generation.
" - Added support for any uppercase character instead of 'X'
"
" Rules:
"   If a germ has 0 or 1 live neighbors it dies of loneliness
"   If a germ has 2 or 3 live neighbors it survives
"   If a germ has 4 to 8 live neighbors it dies of starvation
"   If an empty box has 3 live neighbors a new germ is born
"
"   A new born germ is an "A".	Every generation it gets older: B, C, etc.
"   A germ dies of old age when it reaches "Z".
"
" Notice the rules do not mention edges. This version has the edges wrap
" around. I have an earlier version that offers the option of live edges or
" dead edges. Email me if you are interested. -Eli-
"
" Note: This is slow!  One generation may take up to ten minutes (depends on
" your computer and the vi version).
"
" Quite a lot of the messy stuff is to work around the vi error "Can't yank
" inside global/macro".  Still doesn't work for all versions of vi.
"
" To use these macros:
"
" vi		start vi/vim
"
" :so life.mac	Source this file
"
" g		'g'o!  runs everything until interrupted: "IR".
"
" I		Initialize everything. A board will be drawn at the end
"		of the current buffer. All line references in these macros
"		are relative to the end of the file and playing the game
"		can be done safely with any file as the current buffer.
"
"	Change the left field with spaces and uppercase letters to suit
"	your taste.
"
" C		'C'ompute one generation.
" +		idem, time running one generation.
" R		'R'un 'C'ompute until interrupted.
" i<nr><Esc>z	Make a number the only thing on the current line and use
"		'z' to time that many generations.
"
" Time to run 30 generations on my 233 AMD K6 (FreeBSD 3.0):
"   vim   5.4 xterm	51 sec
"   gvim  5.4 Athena	42 sec
"   gvim  5.4 Motif	42 sec
"   gvim  5.4 GTK	50 sec
"   nvi   1.79 xterm	58 sec
"   vi	  3.7 xterm	2 min 30 sec
"   Elvis 2.1 xterm	7 min 50 sec
"   Elvis 2.1 X11	6 min 31 sec
"
" Time to run 30 generations on my 850 AMD Duron (FreeBSD 4.2):
"   vim   5.8   xterm    21 sec
"   vim   6.0   xterm    24 sec
"   vim   6.0   Motif    32 sec
"   nvi   1.79  xterm	 29 sec
"   vi    3.7   xterm    32 sec
"   elvis 2.1.4 xterm    34 sec
"
" And now the macros, more or less in top-down order.
"
"  ----- macros that can be used by the human -----
"
" 'g'o: 'I'nitialize and then 'R'un 'C'ompute recursively (used by the human)
map g IR
"
"
" 'R'un 'C'ompute recursively (used by the human and 'g'o)
map R CV
" work around "tail recursion" problem in vi, "V" == "R".
map V R
"
"
" 'I'nitialize the board (used by the human and 'g'o)
map I G)0)0)0)0)1)0)0)2)0)0)0)0,ok,-11k,-,R,IIN
"
"
" 'C'ompute next generation (used by the human and others)
map C T>>>>>>>>B&
"
"
" Time running one generation (used by the human)
map + <1C<2
"
"
" Time running N generations, where N is the number on the current line.
" (used by the human)
map z ,^,&,*,&<1,*<2
"
"  ----- END of macros that can be used by the human -----
"
"  ----- Initialisation -----
"
map ,- :s/./-/g
map ,o oPut 'X's in the left box, then hit 'C' or 'R'
map ,R 03stop
"
" Write a new line (used by 'I'nitialize board)
" In remembrance of John Conway, 26 December 1937 â€“ 11 April 2020.
map )0 o-                    --....................--....................-
map )1 o-    JOHN CONWAY     --....................--....................-
map )2 o-       LIVES        --....................--....................-
"
"
" Initialisation of the pattern/command to execute for working out a square.
" Pattern is: "#<germ><count>"
" where <germ>   is " " if the current germ is dead, "X" when living.
"       <count>  is the number of living neighbours (including current germ)
"                expressed in X's
"
map ,Il8 O#XXXXXXXXXX .`a22lr 
map ,Id8 o# XXXXXXXX .`a22lr 
map ,Il7 o#XXXXXXXXX .`a22lr 
map ,Id7 o# XXXXXXX .`a22lr 
map ,Il6 o#XXXXXXXX .`a22lr 
map ,Id6 o# XXXXXX .`a22lr 
map ,Il5 o#XXXXXXX .`a22lr 
map ,Id5 o# XXXXX .`a22lr 
map ,Il4 o#XXXXXX .`a22lr 
map ,Id4 o# XXXX .`a22lr 
map ,Il3 o#XXXXX .,a
map ,Id3 o# XXX .`a22lrA
map ,Il2 o#XXXX .,a
map ,Id2 o# XX .`a22lr 
map ,Il1 o#XXX .`a22lr 
map ,Id1 o# X .`a22lr 
map ,Il0 o#XX .`a22lr 
map ,Id0 o#  .`a22lr 
"
" Patterns used to replace a germ with its next generation
map ,Iaa o=AB =BC =CD =DE =EF =FG =GH =HI =IJ =JK =KL =LM =MN =NO =OP =PQ =QR
map ,Iab o=RS =ST =TU =UV =VW =WX =XY =YZ =Z 
"
" Insert the searched patterns above the board
map ,IIN G?^top,Il8,Id8,Il7,Id7,Il6,Id6,Il5,Id5,Il4,Id4,Il3,Id3,Il2,Id2,Il1,Id1,Il0,Id0,Iaa,Iab
"
"  ----- END of Initialisation -----
"
"  ----- Work out one line -----
"
" Work out 'T'op line (used by show next)
map T G,c2k,!9k,@,#j>2k,$j
"
" Work out 'B'ottom line (used by show next)
map B ,%k>,$
"
" Work out a line (used by show next, work out top and bottom lines)
map > 0 LWWWWWWWWWWWWWWWWWW,rj
"
" Refresh board (used by show next)
map & :%s/^\(-[ A-Z]*-\)\(-[ A-Z]*-\)\(-[.]*-\)$/\2\3\3/
"
"
" Work around vi multiple yank/put in a single macro limitation
" (used by work out top and/or bottom line)
map ,$ dd
map ,% "cp
map ,! "byy
map ,@ "cyy
map ,# "bP
map ,c c$
"
"  ----- END of Work out one line -----
"
"  ----- Work out one square -----
"
" The next three work out a square: put all nine chars around the current
" character on the bottom line (the bottom line must be empty when starting).
"
" 'W'ork out a center square (used by work out line)
map W makh,3`ah,3`ajh,3(
"
"
" Work out a 'L'eft square (used by work out line)
map L makf-h,1`ak,2`af-h,1`a,2`ajf-h,1`aj,2(
"
"
" Work out a 'R'ight square (used by work out line)
map ,r makh,2`akF-l,1`ah,2`aF-l,1`ajh,2`ajF-l,1(
"
" 'M'ove a character to the end of the file (used by all work out square
" macros)
"
map ,1 y G$p
map ,2 2y G$p
map ,3 3y G$p
"
"
"  ----- END of Work out one square -----
"
"  ----- Work out one germ -----
"
" Generate an edit command that depends on the number of living in the last
" line, and then run the edit command. (used by work out square).
" Leaves the cursor on the next character to be processed.
"
map ( ,s,i,X0i?^#A 0,df.l,Y21h
"
" Delete 's'paces (deads);
" The number of remaining characters is the number of living neighbours.
map ,s :.g/ /s///g
"
" Insert current character in the last line
map ,i `ay GP
"
" Replace any uppercase letter with 'X';
map ,X :.g/[A-Z]/s//X/g
"
" Delete and execute the rest of the line
map ,d "qd$@q
"
" Yank and execute the rest of the line
map ,Y "qy$@q
"
" Yank the character under the cursor
map ,j y 
"
" Put the current cut buffer after the cursor
map ,m p
"
" Delete the character under the cursor
map ,n x
"
" Replace a character by its next, A --> B,  B --> C, etc.
map ,a `a,jGi?=,ma0,dll,j`a21l,ml,nh
"
"  ----- END of Work out one germ -----
"
"  ----- timing macros  -----
"
" Get current date (used by time a generation)
map << :r!date
map <1 G?^topO<<
map <2 G?^topk<<
"
"
" Turn number on current line into edit command (used by time N generations)
map ,^ AiC
"
"
" Delete current line and save current line (used by time N generations)
map ,& 0"gd$
"
"
" Run saved line (used by time N generations)
map ,* @g
"
"  ----- END of timing macros  -----
"
" End of the macros.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               " Load the matchit package.
" For those users who were loading the matchit plugin from here.
if 1
    packadd matchit
endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ¿   .   °   ..  À   MakefileÁ   
README.txt  Â   maze.c  Ã   	maze_5.78   Ä   maze_macÅ   
mazeansi.c  Æ   mazeclean.c Ç  hposter                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          # It's simple...

maze: mazeansi.c
	cc -o maze mazeansi.c

mazeclean: mazeclean.c
	cc -o mazeclean mazeclean.c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 To run the maze macros with Vim:

	vim -u maze_mac maze_5.78
	press "g"

The "-u maze.mac" loads the maze macros and skips loading your .vimrc, which
may contain settings and mappings that get in the way.


The original README:

To prove that you can do anything in vi, I wrote a couple of macros that
allows vi to solve mazes. It will solve any maze produced by maze.c
that was posted to the net recently.

Just follow this recipe and SEE FOR YOURSELF.
	1. run uudecode on the file "maze.vi.macros.uu" to
		produce the file "maze.vi.macros"
	(If you can't wait to see the action, jump to step 4)
	2. compile maze.c with "cc -o maze maze.c"
	3. run maze > maze.out and input a small number (for example 10 if
		you are on a fast machine, 3-5 if slow) which
		is the size of the maze to produce
	4. edit the maze (vi maze.out)
	5. include the macros with the vi command:
		:so maze.vi.macros
	6. type the letter "g" (for "go") and watch vi solve the maze
	7. when vi solves the maze, you will see why it lies
	8. now look at maze.vi.macros and all will be revealed

Tested on a sparc, a sun and a pyramid (although maze.c will not compile
on the pyramid).

Anyone who can't get the maze.c file to compile, get a new compiler,
try maze.ansi.c which was also posted to the net.
If you can get it to compile but the maze comes out looking like a fence
and not a maze and you are using SysV or DOS replace the "27" on the
last line of maze.c by "11"
Thanks to John Tromp (tromp@piring.cwi.nl) for maze.c.
Thanks to antonyc@nntp-server.caltech.edu (Bill T. Cat) for maze.ansi.c.

Any donations should be in unmarked small denomination bills :^)=.

		   ACSnet:  gregm@otc.otca.oz.au
Greg McFarlane	     UUCP:  {uunet,mcvax}!otc.otca.oz.au!gregm
|||| OTC ||	    Snail:  OTC R&D GPO Box 7000, Sydney 2001, Australia
		    Phone:  +61 2 287 3139    Fax: +61 2 287 3299


                                                                                                                                                                                          char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);
--            E;             J[              E]             =T
[E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
)    ,   A    =              39              ,C             --
)    ;   Z    ||    printf   (M   ))M[Z]=Z[A-(E   =A[J-Z])&&!C
&    A   ==             T[                                  A]
|6<<27<rand()||!C&!Z?J[T[E]=T[A]]=E,J[T[A]=A-Z]=A,"_.":" |"];}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
| ._| . . ._| | |_._._. . ._|_._._._._. ._|_. ._|_._. ._| . ._|_. | . ._._. |
| ._|_| |_. | | | | ._._|_._|_._. . |_. | | | ._._| |_._._| | ._. ._| . . |_|
|_._._._. | ._|_. ._._._. | | ._. |_._. . | ._._| |_. | ._._._. |_. | |_|_| |
| | . |_._| . ._._._| ._._. ._._| | | |_| . | |_. . ._|_| ._._. |_._|_| . | |
|_._|_._._._|_._._._|_|_._._._|_._|_._._._|_._._._|_._._._|_._._._._._._|_._|

See Vim solve a maze!

   type ":so maze_mac<RETURN>" to load the macros

   type "g" to start

to interrupt type "<CTRL-C>"
     to quit type ":q!<RETURN>"

                                                                                                                                                                                                                                                                                                                                                                                                              " These macros 'solve' any maze produced by the a-maze-ing maze.c program.
"
" First, a bit of maze theory.
" If you were put into a maze, a guaranteed method of finding your way
" out of the maze is to put your left hand onto a wall and just keep walking,
" never taking your hand off the wall. This technique is only guaranteed to
" work if the maze does not have any 'islands', or if the 'exit' is on the
" same island as your starting point. These conditions hold for the mazes
" under consideration.
"
" Assuming that the maze is made up of horizontal and vertical walls spaced
" one step apart and that you can move either north, south, east or west,
" then you can automate this procedure by carrying out the following steps.
"
" 1. Put yourself somewhere in the maze near a wall.
" 2. Check if you have a wall on your left. If so, go to step 4.
" 3. There is no wall on your left, so turn on the spot to your left and step
"    forward by one step and repeat step 2.
" 4. Check what is directly in front of you. If it is a wall, turn on the
"    spot to your right by 90 degrees and repeat step 4.
" 5. There is no wall in front of you, so step forward one step and
"    go to step 2.
"
" In this way you will cover all the corridors of the maze (until you get back
" to where you started from, if you do not stop).
"
" By examining a maze produced by the maze.c program you will see that
" each square of the maze is one character high and two characters wide.
" To go north or south, you move by a one character step, but to move east or
" west you move by a two character step. Also note that in any position
" there are four places where walls could be put - to the north, to the south,
" to the east and to the west.
" A wall exists to the north of you if the character to the north of
" you is a _ (otherwise it is a space).
" A wall exists to the east of you if the character to the east of you
" is a | (otherwise it is a .).
" A wall exists to the west of you if the character to the west of you
" is a | (otherwise it is a .).
" A wall exists to the south of you if the character where you are
" is a _ (otherwise it is a space).
"
" Note the difference for direction south, where we must examine the character
" where the cursor is rather than an adjacent cell.
"
" If you were implementing the above procedure is a normal computer language
" you could use a loop with if statements and continue statements,
" However, these constructs are not available in vi macros so I have used
" a state machine with 8 states. Each state signifies the direction you
" are going in and whether or not you have checked if there is a wall on
" your left.
"
" The transition from state to state and the actions taken on each transition
" are given in the state table below.
" The names of the states are N1, N2, S1, S2, E1, E2, W1, W2, where each letter
" stands for a direction of the compass, the number 1 indicates that the we
" have not yet checked to see if there is a wall on our left and the number 2
" indicates that we have checked and there is a wall on our left.
"
" For each state we must consider the existence or not of a wall in a
" particular direction. This direction is given in the following table.
"
" NextChar table:
" state        direction       vi commands
"  N1              W               hF
"  N2              N               kF
"  S1              E               lF
"  S2              S               F
"  E1              N               kF
"  E2              E               lF
"  W1              S               F
"  W2              W               hF
"
" where F is a macro which yanks the character under the cursor into
" the NextChar register (n).
"
" State table:
" In the 'vi commands' column is given the actions to carry out when in
" this state and the NextChar is as given. The commands k, j, ll, hh move
" the current position north, south, east and west respectively. The
" command mm is used as a no-op command.
" In the 'next state' column is given the new state of the machine after
" the action is carried out.
"
" current state        NextChar    vi commands  next state
"      N1                 .            hh          W1
"      N1                 |            mm          N2
"      N2                 _            mm          E1
"      N2               space          k           N1
"      S1                 .            ll          E1
"      S1                 |            mm          S2
"      S2                 _            mm          W1
"      S2               space          j           S1
"      E1               space          k           N1
"      E1                 _            mm          E2
"      E2                 |            mm          S1
"      E2                 .            ll          E1
"      W1               space          j           S1
"      W1                 _            mm          W2
"      W2                 |            mm          N1
"      W2                 .            hh          W1
"
"
" Complaint about vi macros:
" It seems that you cannot have more than one 'undo-able' vi command
" in the one macro, so you have to make lots of little macros and
" put them together.
"
" I'll explain what I mean by an example. Edit a file and
" type ':map Q rXY'. This should map the Q key to 'replace the
" character under the cursor with X and yank the line'.
" But when I type Q, vi tells me 'Can't yank inside global/macro' and
" goes into ex mode. However if I type ':map Q rXT' and ':map T Y',
" everything is OK. I`m doing all this on a Sparcstation.
" If anyone reading this has an answer to this problem, the author would
" love to find out. Mail to gregm@otc.otca.oz.au.
"
" The macros:
" The macro to run the maze solver is 'g'. This simply calls two other
" macros: I, to initialise everything, and L, to loop forever running
" through the state table.
" Both of these macros are long sequences of calls to other macros. All
" of these other macros are quite simple and so to understand how this
" works, all you need to do is examine macros I and L and learn what they
" do (a simple sequence of vi actions) and how L loops (by calling U, which
" simply calls L again).
"
" Macro I sets up the state table and NextChar table at the end of the file.
" Macro L then searches these tables to find out what actions to perform and
" what state changes to make.
"
" The entries in the state table all begin with a key consisting of the
" letter 's', the current state and the NextChar.  After this is the
" action to take in this state and after this is the next state to change to.
"
" The entries in the NextChar table begin with a key consisting of the
" letter 'n' and the current state. After this is the action to take to
" obtain NextChar - the character that must be examined to change state.
"
" One way to see what each part of the macros is doing is to type in the
" body of the macros I and L manually (instead of typing 'g') and see
" what happens at each step.
"
" Good luck.
"
" Registers used by the macros:
" s (State)        - holds the state the machine is in
" c (Char)         - holds the character under the current position
" m (Macro)        - holds a vi command string to be executed later
" n (NextChar)     - holds the character we must examine to change state
" r (Second Macro) - holds a second vi command string to be executed later
"
set remap
set nomagic
set noterse
set wrapscan
"
"================================================================
" g - go runs the whole show
"        I - initialise
"        L - then loop forever
map g   IL
"
"================================================================
" I - initialise everything before running the loop
"   G$?.^M - find the last . in the maze
"        ^ - replace it with an X (the goal)
"   GYKeDP - print the state table and next char table at the end of the file
"       0S - initialise the state of the machine to E1
"      2Gl - move to the top left cell of the maze
map I   G$?.^GYKeDP0S2Gl
"
"================================================================
" L - the loop which is executed forever
"        Q - save the current character in the Char register
"        A - replace the current character with an 'O'
"       ma - mark the current position with mark 'a'
"      GNB - on bottom line, create a command to search the NextChar table
"            for the current state
" 0M0E@m^M - yank the command into the Macro register and execute it
"       wX - we have now found the entry in the table, now yank the
"            following word into the Macro register
"     `a@m - go back to the current position and execute the macro, this will
"            yank the NextChar in register n
"   GT$B$R - on bottom line, create a command to search the state table
"            for the current state and NextChar
" 0M0E@m^M - yank the command into the Macro register and execute it
"      2WS - we have now found the entry in the table, now yank the
"            next state into the State macro
"       bX - and yank the action corresponding to this state table entry
"            into the Macro register
"      GVJ - on bottom line, create a command to restore the current character
"       0H - and save the command into the second Macro register
"     `a@r - go back to the current position and exectute the macro to restore
"            the current character
"       @m - execute the action associated with this state
"        U - and repeat
map L   QAmaGNB0M0E@mwX`a@mGT$B$R0M0E@m2WSbXGVJ0H`a@r@mU
"
"================================================================
" U - no tail recursion allowed in vi macros so cheat and set U = L
map U   L
"
"================================================================
" S - yank the next two characters into the State register
map S   "sy2l
"
"================================================================
" Q - save the current character in the Char register
map Q   "cyl
"
"================================================================
" A - replace the current character with an 'O'
map A   rO
"
"================================================================
" N - replace this line with the string 'n'
map N   C/n
"
"================================================================
" B - put the current state
map B   "sp
"
"================================================================
" M - yank this line into the Macro register
map M   "my$
"
"================================================================
" E - delete to the end of the line
map E   d$
"
"================================================================
" X - yank this word into the Macro register
map X   "myt 
"
"================================================================
" T - replace this line with the string 's'
map T   C/s
"
"================================================================
" R - put NextChar
map R   "np
"
"================================================================
" V - add the letter 'r' (the replace vi command)
map V   ar
"
"================================================================
" J - restore the current character
map J   "cp
"
"================================================================
" H - yank this line into the second Macro register
map H   "ry$
"
"================================================================
" F - yank NextChar (this macro is called from the Macro register)
map F   "nyl
"
"================================================================
" ^ - replace the current character with an 'X'
map ^   rX
"
"================================================================
" YKeDP - create the state table, NextChar table and initial state
" Note that you have to escape the bar character, since it is special to
" the map command (it indicates a new line).
map Y   osE1  k  N1       sE1_ mm E2       sE2| mm S1       sE2. ll E1
map K   osW1  j  S1       sW1_ mm W2       sW2| mm N1       sW2. hh W1
map e   osN1. hh W1       sN1| mm N2       sN2  k  N1       sN2_ mm E1
map D   osS1. ll E1       sS1| mm S2       sS2  j  S1       sS2_ mm W1
map P   onE1 kF nE2 lF nW1 G$JF nW2 hF nN1 hF nN2 kF nS1 lF nS2 G$JF E1
                                                                                                                                           char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&
C)            ;--            E;J             [E            ]=M
[E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
)    ,   A    =              39              ,C             --
)    ;   Z    ||    printf   (T   ))T[Z]=Z[A-(E   =A[J-Z])&&!C
&    A   ==             M[                                  A]
|6<<27<rand()||!C&!Z?J[M[E]=M[A]]=E,J[M[A]=A-Z]=A,"_.":" |"];}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * Cleaned-up version of the maze program.
 * Doesn't look as nice, but should work with all C compilers.
 * Sascha Wilde, October 2003
 */
#include <stdio.h>
#include <stdlib.h>

char *M, A, Z, E = 40, line[80], T[3];
int
main (C)
{
  for (M = line + E, *line = A = scanf ("%d", &C); --E; line[E] = M[E] = E)
    printf ("._");
  for (; (A -= Z = !Z) || (printf ("\n|"), A = 39, C--); Z || printf (T))
    T[Z] = Z[A - (E = A[line - Z]) && !C
	     & A == M[A]
	     | RAND_MAX/3 < rand ()
	     || !C & !Z ? line[M[E] = M[A]] = E, line[M[A] = A - Z] =
	     A, "_." : " |"];
  return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                              Article 2846 of alt.sources:
Path: oce-rd1!hp4nl!mcsun!uunet!munnari.oz.au!metro!otc!gregm
From: gregm@otc.otca.oz.au (Greg McFarlane)
Newsgroups: alt.sources
Subject: VI SOLVES MAZE (commented macros)
Message-ID: <2289@otc.otca.oz>
Date: 10 Feb 91 23:31:02 GMT
Sender: news@otc.otca.oz
Reply-To: gregm@otc.otca.oz.au (Greg McFarlane)
Organization: OTC Development Unit, Australia
Lines: 464

Submitted-by: gregm@otc.otca.oz.au
Archive-name: maze_solving_vi_macros

A real working model. See it walk the maze in front of your very own eyes.

To prove that you can do anything in vi, I wrote a couple of macros that
allows vi to solve mazes. It will solve any maze produced by maze.c
that was posted to the alt.sources last month. (Maze.c is also included
in this posting as well as an example of its output.)

The uncommented version of the macros was sent to alt.sources last month.
However, so many people mailed me requesting the commented version of the
macros that I decided to post it. I have made some modifications t